<!doctype html><html class="js no-touch progressive-image no-reduced-motion progressive" lang=zh-hans><head><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=icon href=/img/favicon.ico><meta name=keyword content><meta property="og:url" content="https://booslip.rpcx.io/posts/grpc-microservices-in-go/"><meta property="og:site_name" content="竹简书摘"><meta property="og:title" content="GRPC Microservices in Go"><meta property="og:description" content="使用Go语言开发gRPC微服务"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-09T18:05:12+08:00"><meta property="article:modified_time" content="2025-01-09T18:05:12+08:00"><meta property="article:tag" content="Go"><meta property="article:tag" content="Grpc"><title>GRPC Microservices in Go</title>
<link rel=canonical href=/posts/grpc-microservices-in-go/><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/custom.css><link rel=stylesheet href=/css/search.css><link href="https://fonts.googleapis.com/css?family=Bree+Serif" rel=stylesheet><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?c80136b2ed102610dcafb84941e8df30",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head></head><body class=page-article><header><nav class=nav><div class=nav-wrapper><div class=nav-content-wrapper><div class=nav-content><a href=/ class=nav-title>竹简书摘</a><div class=nav-menu><div class=nav-item-wrapper><a href=/posts class=nav-item-content>书摘</a></div><div class=nav-item-wrapper><a href=/index.xml class=nav-item-content target=_blank>RSS</a></div></div></div></div></div></nav><script>function toggleSearchModal(){const t=`
    <div class="modal-body">
      <div id="autocomplete" onclick="event.stopPropagation();"></div>
    </div>
    `,e=document.querySelector("#modal-wrapper");if(e)document.body.removeAttribute("style"),document.body.removeChild(e);else{const e=document.createElement("div");document.body.setAttribute("style","overflow: hidden;"),e.setAttribute("id","modal-wrapper"),e.setAttribute("onclick","toggleSearchModal()"),e.innerHTML=t;const n=document.createElement("script");n.setAttribute("src","https://booslip.rpcx.io/js/algolia.js"),e.appendChild(n),document.body.append(e)}}</script></header><main id=main class=main><section><article class=article><div class=article-header><div class="category component"><div class=component-content><div class=category-eyebrow><span class="category-eyebrow__category category_original">go
</span><span class=category-eyebrow__date>2025年1月9日</span></div></div></div><div class="pagetitle component"><div class=component-content><h1 class=hero-headline>GRPC Microservices in Go</h1></div></div><div class="component article-subhead"><div class=component-content>使用Go语言开发gRPC微服务</div></div><div class="tagssheet component"><div class=component-content><a href=/tags/go class=tag>go
</a><a href=/tags/grpc class=tag>grpc</a></div></div></div><div class="book-card component"><div class=book-cover><img data-src=/covers/GRPC-Microservices-in-Go.jpg alt=书籍封面></div><div class=book-info><h1 class=book-title>GRPC Microservices in Go</h1><div class=book-meta><span>作者：Hüseyin Babal</span>
<span>出版日期：2023-11-14</span>
<span>出版社：Manning</span></div><div class=book-description>本书《gRPC Microservices in Go》是一本关于使用Go语言和gRPC框架构建微服务的指南。它涵盖了微服务架构理论、Go语言基础、gRPC原理及实践、以及在Kubernetes上的部署和监控等方面的内容。书中通过一个电子商务应用的例子，逐步讲解了gRPC微服务的生命周期，包括开发、测试、部署和运维等各个阶段，并提供了大量的代码示例和最佳实践，适合有一定Go语言基础的开发者阅读。</div></div></div><div class=pagebody><div class="component-content pagebody component"><h2 id=第一章go-grpc-微服务简介 class=pagebody-header><strong>第一章：Go gRPC 微服务简介</strong></h2></div><div class="component-content component"><ul><li><strong>gRPC 的跨平台和多语言兼容性</strong>：gRPC 工具和库与多种平台和语言兼容，包括 Go、Java、Python、Ruby、JavaScript 和 C# 等。Protobuf 二进制线格式和代码生成功能使开发者能够构建高性能的跨平台应用程序。</li><li><strong>gRPC 的优势</strong>：gRPC 越来越受欢迎，因为它能够快速生成客户端存根，为不同语言的服务提供 SDK。开发者只需定义业务对象和方法，gRPC 就可以生成特定语言的实现，使得服务器端和客户端可以使用不同的开发语言进行通信。</li><li><strong>容错能力</strong>：容错是指系统在发生故障时仍能继续运行的能力。<strong>幂等操作是实现容错环境的关键</strong>，因为它可以确保即使多次调用同一操作，资源的状态也不会发生改变。此外，容错还包括限流、熔断和故障注入等主题，这些将在第六章详细介绍。</li><li><strong>多语言开发环境</strong>：gRPC 非常适合多语言开发环境，因为可以使用 Python 客户端访问用 Java 编写的 Payment 服务，客户端存根生成非常方便。</li><li><strong>微服务验证机制</strong>：当服务定义发生更改时，客户端的测试会失败，这是一种用于验证微服务的有效机制。</li></ul></div><div class="component-content pagebody component"><h2 id=第二章grpc-与微服务 class=pagebody-header><strong>第二章：gRPC 与微服务</strong></h2></div><div class="component-content component"><ul><li><strong>微服务架构的优势</strong>：单体架构在产品开发的初期阶段很有帮助，但在评估产品的可扩展性、开发和部署问题后，以及熟悉业务能力和服务上下文后，切换到微服务架构是一种最佳实践。</li><li><strong>扩展立方体（Scale Cube）</strong>：扩展立方体是一个三维可扩展模型，包括 X 轴扩展（运行多个相同应用副本）、Y 轴扩展（根据功能分解服务）和 Z 轴扩展（根据请求属性路由请求）。</li><li><strong>异步通信</strong>：发布/订阅（Pub/Sub）或命令通道机制是异步通信的示例，而请求/响应风格（如 gRPC）是同步通信的示例。</li><li><strong>Saga 模式</strong>：基于编排（Choreography）和协调器（Orchestrator）的 Saga 模式提供了分布式环境中的数据一致性。</li><li><strong>gRPC 的应用</strong>：gRPC 是一种现代、轻量级的通信协议，也是一个高性能的 RPC 框架，它通过协议缓冲区高效地连接微服务环境中的服务，并内置支持负载均衡、跟踪、健康检查和身份验证。</li><li><strong>.proto 文件</strong>：使用 Protocol Buffers 定义消息和服务函数，并通过协议缓冲区编译器（protoc）生成服务器和客户端存根。</li><li><strong>gRPC 的工作流程</strong>：定义 .proto 文件，生成客户端和服务器存根，实现服务器端和客户端的业务逻辑，最后运行服务和客户端。</li><li><strong>流式处理</strong>：gRPC 支持客户端和服务器端的流式处理，允许客户端连续发送请求，服务器可以返回一个对象流。</li></ul></div><div class="component-content pagebody component"><h2 id=第三章开始使用-grpc-和-golang class=pagebody-header><strong>第三章：开始使用 gRPC 和 Golang</strong></h2></div><div class="component-content component"><ul><li><strong>Protocol Buffers</strong>：Protocol Buffers 允许序列化结构化数据以便通过网络传输，并定义服务函数以生成特定语言的源代码。</li><li><strong>.proto 文件</strong>：.proto 文件是配置文件的形式，包含消息和服务函数的定义，也包含协议的版本信息（例如 proto3）。</li><li><strong>消息类型定义</strong>：消息字段可以是单数（最多一个）、重复（多个值，包括零）或者保留的。字段类型可以是标量类型（如字符串和整数）、枚举或其他嵌入消息类型。</li><li><strong>消息编码</strong>：协议缓冲区将消息转换为二进制格式进行传输，包括元数据部分和数据部分。</li><li><strong>生成存根</strong>：protoc 工具可以接受多种参数来生成特定语言的源代码。</li><li><strong>维护 .proto 文件</strong>：维护 .proto 文件需要考虑版本控制和向后/向前兼容性，通常会将 .proto 文件保存在单独的仓库中。</li><li><strong>在 CI/CD 管道中添加存根生成过程</strong>：使用 GitHub Actions 可以自动化存根的生成过程。</li><li><strong>Go 代码生成</strong>：使用 protoc 生成 Go 源代码，包括 go_package 选项和源代码相对路径。</li><li><strong>消息和服务的定义</strong>: 了解如何在 .proto 文件中定义消息（message）类型，包括字段规则、字段类型以及保留字段。同时，也包含了服务（service）的定义，以及如何使用 rpc 调用定义服务函数。</li></ul></div><div class="component-content pagebody component"><h2 id=第四章微服务项目设置 class=pagebody-header><strong>第四章：微服务项目设置</strong></h2></div><div class="component-content component"><ul><li><strong>六边形架构</strong>：六边形架构通过端口允许外部参与者使用、实现和编排业务逻辑。</li><li><strong>项目文件夹</strong>：一个典型的 Go 项目包含以下文件夹：application（包含业务逻辑），cmd（包含入口点），config（包含配置），internal/adapters（包含适配器），internal/ports（包含端口），以及 domain （包含核心业务实体）。</li><li><strong>应用核心的实现</strong>：应用核心是业务逻辑的组合，包括领域模型和 API，外层依赖于内层，这使得先实现应用核心，再实现外层依赖变得更容易。</li><li><strong>端口和适配器</strong>：端口是定义应用核心与外部世界交互的接口，适配器是端口的具体实现。</li><li><strong>依赖注入</strong>：通过依赖注入来组合端口和适配器，然后运行应用。</li><li><strong>配置管理</strong>：使用环境变量来分离生产和非生产环境，并读取数据库连接 URL 和应用端口。</li><li><strong>使用 grpcurl 测试 gRPC 端点</strong>：使用 grpcurl 工具可以发送请求并测试 gRPC 服务。</li></ul></div><div class="component-content pagebody component"><h2 id=第五章服务间通信 class=pagebody-header><strong>第五章：服务间通信</strong></h2></div><div class="component-content component"><ul><li><strong>gRPC 存根</strong>：gRPC 存根用于在服务之间进行通信，它是由 .proto 文件生成的 Go 源代码。</li><li><strong>依赖模块和实现端口和适配器</strong>：解释了如何在 Order 服务中依赖 Payment 服务，并实现相应的端口和适配器。</li><li><strong>gRPC 客户端配置</strong>：使用 <code>grpc.WithTransportCredentials(insecure.NewCredentials())</code> 来禁用 TLS 握手，使用 <code>payment.NewPaymentClient(conn)</code> 来初始化 payment 存根实例。</li><li><strong>错误处理</strong>：gRPC 使用预定义的状态码来表示不同的错误情况，并提供了一种结构化的方式来处理错误。</li><li><strong>错误详情</strong>：通过 <code>errdetails.BadRequest_FieldViolation</code> 和 <code>errdetails.BadRequest</code> 可以传递详细的错误信息，包括字段和描述。</li><li><strong>状态码</strong>：详细列出了 gRPC 中常用的状态码，例如 OK，CANCELLED, INVALID_ARGUMENT, ALREADY_EXISTS, PERMISSION_DENIED, RESOURCE_EXHAUSTED 等，这些状态码用于在服务间传递错误信息。</li></ul></div><div class="component-content pagebody component"><h2 id=第六章弹性通信 class=pagebody-header><strong>第六章：弹性通信</strong></h2></div><div class="component-content component"><ul><li><strong>弹性模式</strong>：弹性模式是用于处理分布式系统中网络故障的模式，包括超时、重试和熔断器。</li><li><strong>超时模式</strong>：使用 <code>context.WithTimeout</code> 或 <code>context.WithDeadline</code> 来设置请求超时，防止长时间等待。</li><li><strong>重试模式</strong>：使用 <code>grpc_retry</code> 中间件来自动重试失败的请求，并使用 <code>WithCodes</code>、<code>WithMax</code> 和 <code>WithBackoff</code> 等配置来控制重试行为。</li><li><strong>熔断器模式</strong>：熔断器模式可以防止级联故障，并在服务恢复后自动重置。使用 <code>gobreaker</code> 包来实现熔断器，通过 <code>MaxRequests</code>、<code>ReadyToTrip</code> 和 <code>OnStateChange</code> 等配置来控制熔断器的行为。</li><li><strong>gRPC 错误模型</strong>：gRPC 使用 <code>status</code> 包来处理错误，包括 Code、Status 和 Message 三个主要字段，以及 <code>ErrorDetails</code> 部分来包含详细的错误列表。</li><li><strong>TLS 配置</strong>：使用 TLS 配置来保护服务间的通信，包括证书生成和 gRPC TLS 凭证的使用。</li></ul></div><div class="component-content pagebody component"><h2 id=第七章测试微服务 class=pagebody-header><strong>第七章：测试微服务</strong></h2></div><div class="component-content component"><ul><li><strong>测试金字塔</strong>：测试金字塔将软件测试分为单元测试、集成测试和端到端测试三个类别，单元测试占比最大，端到端测试占比最小。</li><li><strong>单元测试</strong>：单元测试用于验证软件的特定单元，例如类或函数。测试工作流程包括设置、调用 SUT（被测系统）、验证和拆卸。</li><li><strong>系统测试（SUT）</strong>：SUT 可以是类或整个应用程序，测试套件用于验证 SUT 的行为。</li><li><strong>Mock</strong>：使用 Mock 来模拟依赖项，从而快速验证系统行为。使用 testify/mock 或 mockery 来生成 Mock。</li><li><strong>集成测试</strong>：使用 Testcontainers 来初始化数据库等外部依赖项，并使用 Go 的测试框架来验证集成。</li><li><strong>端到端测试</strong>：使用 Docker Compose 来定义和运行应用程序堆栈，并通过测试来验证整个流程。</li><li><strong>测试覆盖率</strong>: 使用 <code>go test -cover</code> 命令来查看测试覆盖率，并使用 <code>-coverprofile</code> 来生成覆盖率报告。</li></ul></div><div class="component-content pagebody component"><h2 id=第八章部署 class=pagebody-header><strong>第八章：部署</strong></h2></div><div class="component-content component"><ul><li><strong>Kubernetes</strong>：Kubernetes 是一个用于自动化部署、扩展和管理容器化应用程序的开源平台。</li><li><strong>Kubernetes 的核心组件</strong>：包括 API 服务器、调度器、控制器管理器、etcd 和 kubelet 等。</li><li><strong>Kubernetes 部署</strong>：通过 Deployment 资源来管理 Pod 的部署和更新。</li><li><strong>Service</strong>：使用 Service 资源来暴露 Pod 作为内部或公共端点。</li><li><strong>部署策略</strong>：包括 RollingUpdate、Blue-Green 和 Canary 等部署策略。</li><li><strong>证书管理</strong>：介绍如何在 Kubernetes 环境中进行证书管理，包括 ClusterIssuer 和 Certificate 的使用。</li><li><strong>使用 kubectl 进行部署</strong>: 详细介绍了如何使用 kubectl 命令来部署 Kubernetes 资源，包括 Deployment 和 Service。</li><li><strong>GitOps</strong>：使用 ArgoCD 和 FluxCD 等工具来自动化部署过程。</li></ul></div><div class="component-content pagebody component"><h2 id=第九章可观测性 class=pagebody-header><strong>第九章：可观测性</strong></h2></div><div class="component-content component"><ul><li><strong>可观测性</strong>：可观测性是跟踪和分析分布式系统中问题的根本原因的关键，它通过跟踪、指标和日志来帮助我们了解系统状态。</li><li><strong>跟踪（Traces）</strong>：跟踪是记录跨多个服务的请求旅程，包括操作和跨度（spans）。</li><li><strong>指标（Metrics）</strong>：指标是用于量化系统性能的度量，例如延迟、请求数和错误率。</li><li><strong>服务级别目标 (SLO)</strong>：定义了服务应达到的目标，例如正常运行时间或响应延迟。</li><li><strong>日志（Logs）</strong>：日志是应用程序产生的消息，可以帮助我们理解发生了什么 。</li><li><strong>OpenTelemetry</strong>：OpenTelemetry 是一组 API、SDK 和工具，用于收集和发送跟踪、指标和日志数据。</li><li><strong>Jaeger</strong>：Jaeger 是一个用于分布式跟踪的开源系统。</li><li><strong>Prometheus</strong>：Prometheus 是一个用于收集和存储指标的开源系统。</li><li><strong>Fluent Bit</strong>：Fluent Bit 是一个轻量级的日志收集器，用于将日志转发到 Elasticsearch。</li><li><strong>Elasticsearch</strong>：Elasticsearch 是一个用于存储和搜索日志的开源系统 。</li><li><strong>Kibana</strong>：Kibana 是一个用于可视化日志的开源工具 。</li><li><strong>整合可观察性工具</strong>: 详细介绍了如何将 OpenTelemetry、Jaeger、Prometheus、Fluent Bit、Elasticsearch 和 Kibana 集成在一起，以建立一个完整的可观察性堆栈。</li></ul></div></div><div id=comments class=utterances><script src=https://utteranc.es/client.js repo=smallnest/booslip.rpcx.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></article></section></main><script>var script=document.createElement("script");script.src="https://booslip.rpcx.io/js/initPost.js",document.head.appendChild(script)</script><div class=footer-main><div class="content-body footer-wraper"><div class=footer-box><div class=foot-nav><div class=foot-nav-items><div class=item><div class=logo></div><div class=email>Email: <a href=mailto:smallnest@gmail.com>smallnest@gmail.com</a></div></div><div class="item community"><div class=item-title>社交媒体</div><a href=https://github.com/smallnest target=_blank>Github</a></div><div class="item resources"><div class=item-title>友链</div><a href=https://colobu.com/ target=_blank>鸟窝</a></div></div></div><div class=bottom><div class="item copyright">鸟窝 &copy; 2025 All Rights Reserved.</div></div></div></div></div></body></html>