<!doctype html><html class="js no-touch progressive-image no-reduced-motion progressive" lang=zh-hans><head><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=icon href=/img/favicon.ico><meta name=keyword content><meta property="og:url" content="https://booslip.rpcx.io/posts/build-your-own-database-from-scratch-in-go-2nd/"><meta property="og:site_name" content="竹简书摘"><meta property="og:title" content="Build Your Own Database From Scratch in Go 2nd"><meta property="og:description" content="使用Go语言从零构建你自己的数据库(第二版)"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-21T18:07:50+08:00"><meta property="article:modified_time" content="2025-01-21T18:07:50+08:00"><meta property="article:tag" content="Go"><meta property="article:tag" content="Database"><title>Build Your Own Database From Scratch in Go 2nd</title>
<link rel=canonical href=/posts/build-your-own-database-from-scratch-in-go-2nd/><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/custom.css><link rel=stylesheet href=/css/search.css><link href="https://fonts.googleapis.com/css?family=Bree+Serif" rel=stylesheet><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?c80136b2ed102610dcafb84941e8df30",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head></head><body class=page-article><header><nav class=nav><div class=nav-wrapper><div class=nav-content-wrapper><div class=nav-content><a href=/ class=nav-title>竹简书摘</a><div class=nav-menu><div class=nav-item-wrapper><a href=/posts class=nav-item-content>书摘</a></div><div class=nav-item-wrapper><a href=/index.xml class=nav-item-content target=_blank>RSS</a></div></div></div></div></div></nav><script>function toggleSearchModal(){const t=`
    <div class="modal-body">
      <div id="autocomplete" onclick="event.stopPropagation();"></div>
    </div>
    `,e=document.querySelector("#modal-wrapper");if(e)document.body.removeAttribute("style"),document.body.removeChild(e);else{const e=document.createElement("div");document.body.setAttribute("style","overflow: hidden;"),e.setAttribute("id","modal-wrapper"),e.setAttribute("onclick","toggleSearchModal()"),e.innerHTML=t;const n=document.createElement("script");n.setAttribute("src","https://booslip.rpcx.io/js/algolia.js"),e.appendChild(n),document.body.append(e)}}</script></header><main id=main class=main><section><article class=article><div class=article-header><div class="category component"><div class=component-content><div class=category-eyebrow><span class="category-eyebrow__category category_original">go
</span><span class=category-eyebrow__date>2025年1月21日</span></div></div></div><div class="pagetitle component"><div class=component-content><h1 class=hero-headline>Build Your Own Database From Scratch in Go 2nd</h1></div></div><div class="component article-subhead"><div class=component-content>使用Go语言从零构建你自己的数据库(第二版)</div></div><div class="tagssheet component"><div class=component-content><a href=/tags/go class=tag>go
</a><a href=/tags/database class=tag>database</a></div></div></div><div class="book-card component"><div class=book-cover><img data-src=/covers/Build-Your-Own-Database-From-Scratch-in-Go alt=书籍封面></div><div class=book-info><h1 class=book-title>Build Your Own Database From Scratch in Go 2nd</h1><div class=book-meta><span>作者：James Smith</span>
<span>出版日期：2024-06-11</span>
<span>出版社：build-your-own.org</span></div><div class=book-description>本书详细讲解了如何从零开始构建一个具有事务处理能力的关系型数据库。教程循序渐进地介绍了构建数据库的核心概念和技术，包括持久化存储、B+树索引、崩溃恢复机制、事务并发控制以及SQL查询语言的解析与执行。 它通过构建一个简单的键值存储系统逐步扩展到关系型数据库，并强调了在每一步中理解基本原理的重要性，而不是死记硬背专业术语。 教程包含大量的代码示例，帮助读者理解每个步骤的实现细节。 最终目标是让读者通过约3000行代码掌握构建数据库的核心技术。</div></div></div><div class=pagebody><div class="component-content pagebody component"><h2 id=第-00-章导论 class=pagebody-header><strong>第 00 章：导论</strong></h2></div><div class="component-content component"><ul><li>本章强调通过<strong>实践</strong>来掌握数据库的基本原理，而不是陷入复杂的术语。</li><li>核心学习内容包括：<div class="component-content component"><ul><li><strong>原子性和持久性</strong>：确保数据更新要么全部成功，要么全部失败，并且更新后的数据能够可靠地保存。</li><li>基于 <strong>B 树的键值存储</strong>：使用 B 树作为磁盘数据结构的基础。</li><li><strong>关系型数据库构建于键值存储之上</strong>：理解表和索引如何映射到低级别的 B 树。</li><li><strong>并发事务控制</strong>：管理多个并发事务。</li></ul></div></li><li>通过约 3000 行代码逐步构建一个数据库。</li><li>数据库的核心原理并不复杂，每个人都可以尝试构建。</li><li>本章提到了 SQLite 在智能手机上的广泛使用，并强调了数据库在崩溃时保护数据的重要性。</li></ul></div><div class="component-content pagebody component"><h2 id=第-01-章从文件到数据库 class=pagebody-header><strong>第 01 章：从文件到数据库</strong></h2></div><div class="component-content component"><ul><li>本章讨论了直接使用文件存储数据时面临的问题，例如在更新过程中崩溃导致的数据损坏。</li><li><strong>原子重命名</strong>：通过将新文件重命名为旧文件的路径来实现原子替换，避免了在原位置更新数据。<div class="component-content component"><ul><li>这种方法确保了在更新中断时，可以从旧文件恢复，并且并发读取不会读取到一半写入的数据。</li><li>重命名操作在文件系统中是原子的，成本与数据大小无关。</li><li>重命名对于并发读取是原子的，但对于断电不是原子的，需要额外的 <code>fsync</code> 操作。</li></ul></div></li><li><strong>使用校验和进行原子日志更新</strong>：通过在每个日志条目中添加校验和，可以检测到日志条目的损坏，并确保日志更新的原子性。</li><li>总结了数据库面临的挑战：<div class="component-content component"><ul><li>避免在原位置更新。</li><li>使用仅追加日志进行增量更新。</li><li>使用 <code>fsync</code> 来保证数据持久化。</li></ul></div></li><li>提出了需要解决的问题：<div class="component-content component"><ul><li>如何索引数据结构并更新它们。</li><li>如何重用仅追加文件中的空间。</li><li>如何将日志与索引数据结构结合。</li><li>如何处理并发。</li></ul></div></li></ul></div><div class="component-content pagebody component"><h2 id=第-02-章索引数据结构 class=pagebody-header><strong>第 02 章：索引数据结构</strong></h2></div><div class="component-content component"><ul><li>介绍了三种主要的 SQL 查询类型：<div class="component-content component"><ul><li><strong>扫描整个数据集</strong>（不使用索引）。</li><li><strong>点查询</strong>（通过特定键查询索引）。</li><li><strong>范围查询</strong>（通过范围查询索引，索引是排序的）。</li></ul></div></li><li><strong>LSM 树（Log-Structured Merge-Tree）</strong>：<div class="component-content component"><ul><li>通过缓冲更新来减少写入放大，避免每次都重写整个数据集。</li><li>多层结构，每一层都包含排序的数据。</li><li>级别呈指数增长，通过合并大小相似的级别来减少写入放大。</li><li>查询时需要合并来自每一层的结果。</li><li>使用 Bloom 过滤器优化点查询，减少搜索的级别。</li><li>删除的键用 tombstone 标记，并在合并过程中回收空间。</li><li>SSTable（Sorted String Table）、MemTable 和日志是 LSM 树的实现细节。</li></ul></div></li></ul></div><div class="component-content pagebody component"><h2 id=第-03-章b-树和崩溃恢复 class=pagebody-header><strong>第 03 章：B 树和崩溃恢复</strong></h2></div><div class="component-content component"><ul><li><strong>B 树</strong>：<div class="component-content component"><ul><li>是一种高度平衡的 n 叉树，所有叶子节点的高度相同。</li><li>每个节点可以有 2、3 或 4 个子节点的 2-3-4 树是 B 树的一个例子。</li><li>可以通过排序数组来理解 B 树。</li><li>只有叶子节点包含值，内部节点包含键，指示子树的键范围。</li></ul></div></li><li><strong>维护 B+ 树的三个不变量</strong>：<div class="component-content component"><ul><li>所有叶子节点的高度相同。</li><li>节点大小受限于一个常量。</li><li>节点不为空。</li></ul></div></li><li><strong>通过拆分节点来增长 B 树</strong>：当插入导致节点超出大小限制时，将节点拆分为更小的节点，并可能导致父节点也需要拆分，最终导致树的高度增加。</li><li><strong>通过合并节点来缩小 B 树</strong>：删除可能导致空节点，此时需要将空节点与其兄弟节点合并，合并操作也可能传播到根节点，导致树的高度降低。</li><li><strong>Copy-on-write B 树</strong>：<div class="component-content component"><ul><li>为了安全地更新 B 树，先复制节点，并在副本上进行修改，更新父节点指向新节点，复制操作传播到根节点，形成新的树根。</li><li>原树保持不变，可以从旧的根访问。</li><li>这种方法被称为 copy-on-write 数据结构，也称为不可变或持久性。</li><li>解决了如何找到树根的问题，并使用空闲列表来复用旧版本的节点。</li><li>优点包括免费获得快照隔离，以及轻松的崩溃恢复。</li><li>适用于多读单写并发模型。</li></ul></div></li><li><strong>In-place 更新的双写技术</strong>：<div class="component-content component"><ul><li>通过保存更新节点的副本，<code>fsync</code> 保存的副本，进行原位置更新，并再次 <code>fsync</code> 更新，实现崩溃恢复。</li><li>在崩溃后，使用保存的副本来恢复数据结构。</li><li>双写使更新具有幂等性，允许 DB 重试更新。</li></ul></div></li><li><strong>崩溃恢复的原则</strong>：确保在任何时候都有足够的信息来恢复到旧状态或新状态。</li></ul></div><div class="component-content pagebody component"><h2 id=第-04-章b-树节点和插入 class=pagebody-header><strong>第 04 章：B+ 树节点和插入</strong></h2></div><div class="component-content component"><ul><li><strong>B+ 树节点的设计</strong>：所有 B+ 树节点大小相同，以便使用空闲列表。<div class="component-content component"><ul><li>节点包含固定大小的头部，包括节点类型和键的数量。</li><li>内部节点包含指向子节点的指针列表。</li><li>节点包含键值对列表和指向键值对的偏移列表，用于二分查找。</li><li>简化了实现，仅关注基本原理。</li></ul></div></li><li><strong>数据结构与 IO 解耦</strong>：使用回调来抽象空间分配和释放，在数据结构和 DB 的其余部分之间建立边界。</li><li><strong>节点格式</strong>：<div class="component-content component"><ul><li>头部：节点类型 (2B) 和键的数量 (2B)。</li><li>子节点指针：<code>nkeys * 8B</code>。</li><li>键值对偏移量：<code>nkeys * 2B</code>。</li><li>键值对：<code>klen (2B) | vlen (2B) | key | val</code>。</li></ul></div></li><li><strong>节点更新</strong>：在叶子节点插入键值对时，使用 <code>nodeLookupLE</code> 找到插入位置，然后将所有内容复制到包含新键的新节点中。</li><li><strong>节点拆分</strong>：<div class="component-content component"><ul><li>当节点过大时，将其拆分为 2 或 3 个节点。</li><li><code>nodeSplit2</code> 将节点拆分为两个。</li><li><code>nodeSplit3</code> 将节点拆分为最多三个。</li></ul></div></li><li><strong>B+ 树插入</strong>：从根节点开始进行键查找，直到到达叶子节点，然后执行插入操作，可能会导致节点拆分。<div class="component-content component"><ul><li><code>treeInsert</code> 函数递归地插入键值对。</li><li><code>nodeInsert</code> 函数处理内部节点的插入。</li></ul></div></li></ul></div><div class="component-content pagebody component"><h2 id=第-05-章b-树删除和测试 class=pagebody-header><strong>第 05 章：B+ 树删除和测试</strong></h2></div><div class="component-content component"><ul><li><strong>高层接口</strong>：<div class="component-content component"><ul><li><code>Insert</code> 函数用于插入新键或更新现有键。</li><li><code>Delete</code> 函数用于删除键，并返回键是否存在。</li></ul></div></li><li><strong>维护根节点</strong>：<div class="component-content component"><ul><li>如果树为空，则创建根节点。</li><li>如果根节点拆分，则添加新的根节点。</li></ul></div></li><li><strong>哨兵值</strong>：在创建第一个根时插入一个空键，以消除边缘情况。</li><li><strong>合并条件</strong>：删除可能导致空节点，此时可以将空节点与兄弟节点合并。<div class="component-content component"><ul><li><code>shouldMerge</code> 函数判断是否应该与兄弟节点合并。</li></ul></div></li><li><strong>测试 B+ 树</strong>：<div class="component-content component"><ul><li>使用内存模拟页面的方式来测试 B+ 树。</li><li><code>C</code> 结构体包含一个 <code>BTree</code>，一个引用数据 <code>ref</code> 和一个内存页面的映射 <code>pages</code>。</li><li>使用 <code>C.pages</code> 来验证指针并读取页面。</li><li>验证结构是否有效（键是否排序，节点大小是否在限制内）和数据是否与引用匹配。</li></ul></div></li></ul></div><div class="component-content pagebody component"><h2 id=第-06-章仅追加键值存储 class=pagebody-header><strong>第 06 章：仅追加键值存储</strong></h2></div><div class="component-content component"><ul><li><strong>基于文件的键值存储</strong>：<div class="component-content component"><ul><li>使用 copy-on-write B+ 树，并使用文件作为持久化存储。</li><li>文件是仅追加的，空间重用将在下一章节讨论。</li><li>忽略并发，假设在一个进程内进行顺序访问。</li><li>实现了处理磁盘页面的三个 B+ 树回调。</li></ul></div></li><li><strong>两阶段更新</strong>：<div class="component-content component"><ul><li>先写入新节点，<code>fsync</code> 来保证顺序。</li><li>然后原子地更新根指针，再次 <code>fsync</code> 来使一切持久化。</li></ul></div></li><li><strong>使用日志的持久性</strong>：<div class="component-content component"><ul><li>双写方案也需要两个 <code>fsync</code> 阶段。</li><li>双写类似于日志，只需要一个 <code>fsync</code> 进行更新。</li></ul></div></li><li><strong>内存数据的并发</strong>：<div class="component-content component"><ul><li>可以使用互斥锁或原子 CPU 指令实现内存数据的原子性。</li><li>内存数据的可见性需要内存屏障，类似于 <code>fsync</code>。</li></ul></div></li><li><strong>文件布局</strong>：<div class="component-content component"><ul><li>数据库是一个文件，分为多个页面。</li><li>第一页是元页面，包含指向最新根节点的指针和辅助数据。</li><li>新节点以日志形式追加，文件的页面数量存储在元页面中。</li></ul></div></li><li><strong>目录上的 <code>fsync</code></strong>：在创建新文件后，需要在父目录上执行 <code>fsync</code>。</li><li><strong><code>mmap</code>、页面缓存和 IO</strong>：<code>mmap</code> 允许像内存缓冲区一样读写文件，磁盘 IO 是隐式和自动的。</li><li><strong>管理磁盘页面</strong>：使用 <code>mmap</code> 实现页面管理回调。</li><li><strong>元页面</strong>：元页面包含魔术字节、根指针和页面使用数量，并使用 <code>saveMeta</code> 和 <code>loadMeta</code> 函数来保存和加载。<div class="component-content component"><ul><li>使用 <code>pwrite</code> 原子地更新元页面。</li></ul></div></li><li><strong>错误处理</strong>：<div class="component-content component"><ul><li>IO 错误后，可以回滚到旧的树根。</li><li>需要处理临时写入错误。</li></ul></div></li></ul></div><div class="component-content pagebody component"><h2 id=第-07-章空闲列表回收和重用 class=pagebody-header><strong>第 07 章：空闲列表：回收和重用</strong></h2></div><div class="component-content component"><ul><li><strong>内存管理技术</strong>：讨论了手动和自动内存管理，以及如何重用未使用的对象。</li><li><strong>空闲列表</strong>：存储未使用的页面列表，以便重用。</li><li><strong>嵌入式链表</strong>：最简单的方案是在对象内部嵌入链表指针，但与 copy-on-write 冲突。</li><li><strong>空闲列表磁盘布局</strong>：每个节点都包含指向下一个节点的指针，项目追加到尾节点，并从头节点消费。</li><li><strong>更新空闲列表节点</strong>：列表节点的更新是在原位置进行的，但在页面内部是追加的，不需要额外的崩溃恢复。</li><li><strong>空闲列表接口</strong>：<code>FreeList</code> 结构体包含页面管理回调和元数据。<div class="component-content component"><ul><li><code>PopHead</code> 函数从列表头部获取一个项目。</li><li><code>PushTail</code> 函数将项目添加到尾部。</li></ul></div></li><li><strong>空闲列表数据结构</strong>：<div class="component-content component"><ul><li>使用 <code>headSeq</code> 和 <code>tailSeq</code> 作为单调递增的索引。</li><li><code>SetMaxSeq</code> 函数设置 <code>maxSeq</code>，以防止消耗新添加的项目。</li></ul></div></li><li><strong>从空闲列表消费</strong>：<code>flPop</code> 函数从头部删除一个项目，并移动到下一个节点。</li><li><strong>推送到空闲列表</strong>：<code>PushTail</code> 函数将项目追加到尾部节点，如果尾部节点满了，则添加新的空尾部节点。</li><li><strong>带空闲列表的 KV</strong>：<div class="component-content component"><ul><li>页面管理现在可以使用空闲列表。</li><li><code>pageAlloc</code> 函数优先使用空闲列表，再追加页面。</li><li><code>pageWrite</code> 函数返回一个可写的页面副本。</li><li><code>pageRead</code> 函数优先从待更新映射中读取，再从文件中读取.</li></ul></div></li><li><strong>更新元页面</strong>：元页面现在包括空闲列表指针，和树根一起原子更新。</li></ul></div><div class="component-content pagebody component"><h2 id=第-08-章键值存储上的表 class=pagebody-header><strong>第 08 章：键值存储上的表</strong></h2></div><div class="component-content component"><ul><li><strong>将行编码为 KV</strong>：<div class="component-content component"><ul><li>在关系型数据库中，数据被建模为二维表，由行和列组成。</li><li>定义了 <code>Record</code> 结构体来表示表行。</li><li>定义了 <code>TableDef</code> 结构体来表示表模式。</li></ul></div></li><li><strong>内部表</strong>：<div class="component-content component"><ul><li>使用预定义的内部表来存储表模式。</li><li><code>TDEF_TABLE</code> 表存储表定义。</li><li><code>TDEF_META</code> 表存储自动递增的计数器。</li></ul></div></li><li><strong>获取、更新、插入、删除、创建</strong>：<div class="component-content component"><ul><li>提供了读取和写入单行的接口。</li><li><code>DB</code> 结构体是 <code>KV</code> 的包装器。</li><li>使用 <code>decodeValues</code> 函数将值解码为列。</li><li>使用 <code>checkRecord</code> 函数重新排序记录并检查缺少的列。</li><li>使用 <code>encodeKey</code> 函数对 KV 的键进行编码。</li><li>使用 <code>getTableDef</code> 函数获取表模式。</li><li><code>dbGet</code> 函数从内部表读取表定义。</li></ul></div></li><li><strong>插入或更新行</strong>：<div class="component-content component"><ul><li><code>INSERT</code>、<code>UPDATE</code> 和 <code>UPSERT</code> 语句在处理现有行方面有所不同。</li><li>使用 <code>MODE_UPSERT</code>、<code>MODE_UPDATE_ONLY</code> 和 <code>MODE_INSERT_ONLY</code> 标志来区分。</li><li><code>dbUpdate</code> 函数处理行的插入和更新。</li></ul></div></li><li><strong>创建表</strong>：<div class="component-content component"><ul><li>创建表的过程包括检查重复名称，读取和更新表前缀计数器，并将模式插入到 <code>@table</code>。</li></ul></div></li><li><strong>迭代器接口</strong>：<div class="component-content component"><ul><li>使用 <code>SeekLE</code> 函数查找小于或等于输入键的最接近位置。</li><li>使用 <code>BIter</code> 结构体表示 B+ 树的位置，使用 <code>Deref</code> 函数获取当前 KV 对，使用 <code>Valid</code> 函数判断是否有效，使用 <code>Prev</code> 和 <code>Next</code> 函数向后和向前移动。</li></ul></div></li></ul></div><div class="component-content pagebody component"><h2 id=第-09-章范围查询 class=pagebody-header><strong>第 09 章：范围查询</strong></h2></div><div class="component-content component"><ul><li><strong>范围查询</strong>：介绍了 <code>Scan</code> 接口，用于执行范围查询。</li><li><strong>顺序保留编码</strong>：为了支持范围查询，序列化的键必须按照它们的数据类型进行比较。<div class="component-content component"><ul><li>将无符号整数编码为大端整数。</li><li>将有符号整数转换为无符号整数并翻转符号位。</li><li>使用转义字符来编码字符串，并在末尾添加分隔符。</li><li>通过逐列比较来处理多列比较。</li></ul></div></li><li><strong>范围查询</strong>：<code>Scanner</code> 结构体是 B+ 树迭代器的包装器。<div class="component-content component"><ul><li><code>dbScan</code> 函数选择合适的索引，然后执行查询。</li></ul></div></li><li><strong>将缺失的列编码为无穷大</strong>：使用 <code>"\xff"</code> 作为 <code>+∞</code>，使用 <code>""</code> 作为 <code>-∞</code>。<div class="component-content component"><ul><li>通过添加列类型代码作为标签，来支持前缀列上的范围查询。</li><li>使用 <code>encodeKeyPartial</code> 函数为输入范围进行编码。</li></ul></div></li></ul></div><div class="component-content pagebody component"><h2 id=第-10-章二级索引 class=pagebody-header><strong>第 10 章：二级索引</strong></h2></div><div class="component-content component"><ul><li><strong>二级索引</strong>：通过在更新时删除旧的索引键并插入新的索引键来维护二级索引。</li><li><strong>多键更新的原子性</strong>：多个键涉及的更新会丢失原子性，需要回滚到之前的状态。</li><li><strong>事务接口</strong>：<div class="component-content component"><ul><li>添加 <code>Begin</code>、<code>Commit</code> 和 <code>Abort</code> 接口来允许原子执行一组操作。</li><li>使用 copy-on-write 来实现原子性，commit 和 rollback 都只是更新根指针。</li></ul></div></li><li><strong>替代方案</strong>：使用日志来实现原子性，在日志 <code>fsync</code> 后，DB 可以将成功返回给客户端。</li></ul></div><div class="component-content pagebody component"><h2 id=第-11-章原子事务 class=pagebody-header><strong>第 11 章：原子事务</strong></h2></div><div class="component-content component"><ul><li><strong>将树操作移动到事务</strong>：将树操作与事务关联，并将它们移动到 <code>KVTX</code>。</li><li><strong>事务表操作</strong>：为基于表的接口添加包装类型 <code>DBTX</code>。</li><li><strong>可选择的优化</strong>：<div class="component-content component"><ul><li>减少多键更新时的复制.</li><li>压缩公共前缀。</li></ul></div></li></ul></div><div class="component-content pagebody component"><h2 id=第-12-章并发控制 class=pagebody-header><strong>第 12 章：并发控制</strong></h2></div><div class="component-content component"><ul><li><strong>并发级别</strong>：<div class="component-content component"><ul><li>讨论了并发客户端的事务操作，区分了只读事务和读写事务。</li><li>介绍了读者-写者锁（RWLock）。</li><li>介绍了读取-复制-更新（RCU）。</li><li>介绍了乐观并发控制和悲观并发控制。</li></ul></div></li><li><strong>快照隔离</strong>：使用 copy-on-write，事务操作在 B+ 树的快照上。<div class="component-content component"><ul><li><code>KVTX</code> 结构体包含一个只读快照和本地更新。</li><li><code>Get</code> 函数首先从 <code>KVTX.pending</code> 中读取，然后从 <code>KVTX.snapshot</code> 中读取。</li><li><code>CombinedIter</code> 结构体用于合并两个树的范围查询。</li></ul></div></li><li><strong>空闲列表中的版本号</strong>：<div class="component-content component"><ul><li>为每个版本分配一个单调递增的版本号。</li><li>空闲列表永远不会给出比最旧事务更新的页面。</li></ul></div></li><li><strong>处理写入冲突</strong>：<div class="component-content component"><ul><li>将所有读取添加到 <code>KVTX.reads</code>。</li><li>将每个成功提交添加到 <code>KV.history</code>。</li><li>使用 <code>detectConflicts</code> 函数检测冲突。</li><li>序列化内部数据结构。</li></ul></div></li></ul></div><div class="component-content pagebody component"><h2 id=第-13-章sql-解析器 class=pagebody-header><strong>第 13 章：SQL 解析器</strong></h2></div><div class="component-content component"><ul><li><strong>语法、解析器和解释器</strong>：<div class="component-content component"><ul><li>查询语言是解析为树结构用于进一步处理的字符串。</li><li>示例：SELECT 语句和表达式的树表示。</li><li>通过访问树节点来评估表达式.</li><li>介绍了 <code>INDEX BY</code> 和 <code>FILTER</code> 子句。</li><li>使用 <code>QLNode</code> 结构体表示表达式树节点.</li></ul></div></li><li><strong>递归下降</strong>：<div class="component-content component"><ul><li>每个语句都被划分为更小的部分，包括表达式节点 <code>QLNode</code>.</li><li><code>QLSelect</code>、<code>QLUpdate</code> 和 <code>QLDelete</code> 结构体表示不同类型的语句。</li><li>顶级解析器函数 <code>pStmt</code> 确定语句的类型，然后将其分派给具体的函数。</li><li><code>pKeyword</code> 函数匹配和消耗输入中的关键字。</li><li>将输入分成越来越小的部分，直到结束为一个操作符、名称或文字值。</li><li>使用递归将中缀操作符转换为二叉树。</li><li><code>pExprOr</code> 是解析表达式的最高级函数，调用 <code>pExprAnd</code> 等低优先级函数。</li></ul></div></li></ul></div><div class="component-content pagebody component"><h2 id=第-14-章查询语言 class=pagebody-header><strong>第 14 章：查询语言</strong></h2></div><div class="component-content component"><ul><li><strong>表达式评估</strong>：使用 <code>QLEvalContex</code> 结构体评估表达式。<div class="component-content component"><ul><li><code>qlEval</code> 函数评估表达式树。</li></ul></div></li><li><strong>范围查询</strong>：<div class="component-content component"><ul><li><code>QLScan</code> 结构体表示一个范围查询。</li><li><code>qlScanInit</code> 函数初始化扫描器，将 <code>QLNode</code> 转换为 <code>Record</code> 和 <code>CMP_??</code>。</li><li>根据 <code>Key1</code> 和 <code>Key2</code> 的类型来设置比较操作符。</li></ul></div></li><li><strong>重新审视无穷大编码</strong>：使用空元组来处理仅使用前缀的查询。<div class="component-content component"><ul><li>使用 <code>covered</code> 函数来判断索引是否覆盖。</li></ul></div></li><li><strong>结果迭代器</strong>：<div class="component-content component"><ul><li><code>RecordIter</code> 接口定义了迭代器的通用接口。</li><li><code>qlSelectIter</code> 结构体用于在 SELECT 中计算表达式。</li><li><code>qlScanIter</code> 结构体处理过滤。</li></ul></div></li><li><strong>结论和下一步</strong>：总结了实现的多个接口，以及下一步的计划。<div class="component-content component"><ul><li>创建一个网络协议，让 DB 在不同的进程或机器上运行。</li><li>创建一门编程语言并编译为机器代码。</li></ul></div></li></ul></div></div><div id=comments class=utterances><script src=https://utteranc.es/client.js repo=smallnest/booslip.rpcx.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></article></section></main><script>var script=document.createElement("script");script.src="https://booslip.rpcx.io/js/initPost.js",document.head.appendChild(script)</script><div class=footer-main><div class="content-body footer-wraper"><div class=footer-box><div class=foot-nav><div class=foot-nav-items><div class=item><div class=logo></div><div class=email>Email: <a href=mailto:smallnest@gmail.com>smallnest@gmail.com</a></div></div><div class="item community"><div class=item-title>社交媒体</div><a href=https://github.com/smallnest target=_blank>Github</a></div><div class="item resources"><div class=item-title>友链</div><a href=https://colobu.com/ target=_blank>鸟窝</a></div></div></div><div class=bottom><div class="item copyright">鸟窝 &copy; 2025 All Rights Reserved.</div></div></div></div></div></body></html>