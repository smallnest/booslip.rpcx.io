<!doctype html><html class="js no-touch progressive-image no-reduced-motion progressive" lang=zh-hans><head><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=icon href=/img/favicon.ico><meta name=keyword content><meta property="og:url" content="https://booslip.rpcx.io/posts/effective-rust/"><meta property="og:site_name" content="竹简书摘"><meta property="og:title" content="Effective Rust"><meta property="og:description" content="35个提升Rust代码质量的途径"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-28T18:42:32+08:00"><meta property="article:modified_time" content="2024-12-28T18:42:32+08:00"><meta property="article:tag" content="Rust"><title>Effective Rust</title>
<link rel=canonical href=/posts/effective-rust/><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/custom.css><link rel=stylesheet href=/css/search.css><link href="https://fonts.googleapis.com/css?family=Bree+Serif" rel=stylesheet><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?c80136b2ed102610dcafb84941e8df30",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head></head><body class=page-article><header><nav class=nav><div class=nav-wrapper><div class=nav-content-wrapper><div class=nav-content><a href=/ class=nav-title>竹简书摘</a><div class=nav-menu><div class=nav-item-wrapper><a href=/posts class=nav-item-content>书摘</a></div><div class=nav-item-wrapper><a href=/index.xml class=nav-item-content target=_blank>RSS</a></div></div></div></div></div></nav><script>function toggleSearchModal(){const t=`
    <div class="modal-body">
      <div id="autocomplete" onclick="event.stopPropagation();"></div>
    </div>
    `,e=document.querySelector("#modal-wrapper");if(e)document.body.removeAttribute("style"),document.body.removeChild(e);else{const e=document.createElement("div");document.body.setAttribute("style","overflow: hidden;"),e.setAttribute("id","modal-wrapper"),e.setAttribute("onclick","toggleSearchModal()"),e.innerHTML=t;const n=document.createElement("script");n.setAttribute("src","https://booslip.rpcx.io/js/algolia.js"),e.appendChild(n),document.body.append(e)}}</script></header><main id=main class=main><section><article class=article><div class=article-header><div class="category component"><div class=component-content><div class=category-eyebrow><span class="category-eyebrow__category category_original">rust
</span><span class=category-eyebrow__date>2024年12月28日</span></div></div></div><div class="pagetitle component"><div class=component-content><h1 class=hero-headline>Effective Rust</h1></div></div><div class="component article-subhead"><div class=component-content>35个提升Rust代码质量的途径</div></div><div class="tagssheet component"><div class=component-content><a href=/tags/rust class=tag>rust</a></div></div></div><div class="book-card component"><div class=book-cover><img data-src=/covers/effective-rust.jpg alt=书籍封面></div><div class=book-info><h1 class=book-title>Effective Rust</h1><div class=book-meta><span>作者：Mara Bos</span>
<span>出版日期：2024-05-07</span>
<span>出版社：O'Reilly Media, Inc.</span></div><div class=book-description>书中以35个具体的例子，详细讲解如何改进Rust代码。内容涵盖类型系统（例如枚举、Result、类型转换）、特性（trait）、生命周期、借用检查器、并发编程、错误处理、依赖管理以及工具的使用等方面，旨在帮助读者编写更有效、更安全、更易于维护的Rust代码。书中还强调了Rust的内存安全特性，并讨论了如何处理与其他语言（例如C和C++）的互操作性。 最后，还介绍了一些提高开发效率的工具和方法，例如持续集成系统。</div></div></div><div class=pagebody><div class="component-content pagebody component"><h2 id=第一章类型types class=pagebody-header>第一章：类型（Types）</h2></div><p class="component-content component">本章主要讨论 Rust 的类型系统及其在表达数据结构和行为方面的应用。</p><div class="component-content component"><ul><li><strong>使用类型系统表达数据结构</strong>：<div class="component-content component"><ul><li>强调 Rust 的类型系统能够帮助开发者清晰地表达数据结构，提高代码的可读性和可维护性。</li><li>介绍了 <strong>元组结构体 (tuple structs)</strong>，其字段通过数字索引访问，例如 <code>m.0</code>。</li><li>深入探讨了 <strong>枚举 (enums)</strong>，它是 Rust 类型系统的核心。枚举可以定义一组互斥的值，并可以附带数值。<div class="component-content pagebody component code"><div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>HttpResultCode</span> {
</span></span><span style=display:flex><span>    Ok <span style=color:#f92672>=</span> <span style=color:#ae81ff>200</span>,
</span></span><span style=display:flex><span>    NotFound <span style=color:#f92672>=</span> <span style=color:#ae81ff>404</span>,
</span></span><span style=display:flex><span>    Teapot <span style=color:#f92672>=</span> <span style=color:#ae81ff>418</span>,
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></div></li><li>使用枚举可以增强代码的可读性和类型安全性，避免使用布尔值参数时可能出现的混淆。例如，使用 <code>Sides::Both</code> 和 <code>Output::BlackAndWhite</code> 比使用 <code>true</code> 和 <code>false</code> 更清晰易懂。</li><li><strong>match 表达式</strong> 用于处理枚举的不同变体，Rust 编译器会强制检查所有变体是否都被覆盖，从而避免遗漏情况。</li><li>如果枚举仅仅是一个 C 风格的数值列表，可以使用 <code>non_exhaustive</code> 属性来避免添加新变体时的破坏性变更。</li></ul></div></li><li><strong>使用类型系统表达通用行为</strong>：<div class="component-content component"><ul><li>函数 (functions) 可以通过 <code>fn</code> 关键字定义，并可以指定返回值类型。函数也可以仅用于副作用，没有返回值。<div class="component-content pagebody component code"><div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>div</span>(x: <span style=color:#66d9ef>f64</span>, y: <span style=color:#66d9ef>f64</span>) -&gt; <span style=color:#66d9ef>f64</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> y <span style=color:#f92672>==</span> <span style=color:#ae81ff>0.0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>f64</span>::<span style=color:#66d9ef>NAN</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    x <span style=color:#f92672>/</span> y
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>show</span>(x: <span style=color:#66d9ef>f64</span>) {
</span></span><span style=display:flex><span>    println!(<span style=color:#e6db74>&#34;x = </span><span style=color:#e6db74>{x}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></div></li><li><strong>方法 (methods)</strong> 与特定的数据结构关联，通过 <code>self</code> 引用该数据结构。方法可以修改、读取或消耗数据结构. 方法可以被添加到 <code>enum</code> 类型和 <code>struct</code> 类型。<div class="component-content pagebody component code"><div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Shape</span> {
</span></span><span style=display:flex><span>    Rectangle { width: <span style=color:#66d9ef>f64</span>, height: <span style=color:#66d9ef>f64</span> },
</span></span><span style=display:flex><span>    Circle { radius: <span style=color:#66d9ef>f64</span> },
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> Shape {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>area</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>f64</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> self {
</span></span><span style=display:flex><span>            Shape::Rectangle { width, height } <span style=color:#f92672>=&gt;</span> width <span style=color:#f92672>*</span> height,
</span></span><span style=display:flex><span>            Shape::Circle { radius } <span style=color:#f92672>=&gt;</span> std::<span style=color:#66d9ef>f64</span>::consts::<span style=color:#66d9ef>PI</span> <span style=color:#f92672>*</span> radius <span style=color:#f92672>*</span> radius,
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></div></li><li><strong>函数指针 (function pointers)</strong> 可以作为参数传递，允许代码在运行时改变行为。函数指针类型实现了 <code>Copy</code> 和 <code>Eq</code> 等 trait. 函数的名称需要显式转换为 <code>fn</code> 类型.</li><li><strong>闭包 (closures)</strong> 是一种匿名函数，可以捕获其所在环境中的变量。闭包通过 <code>FnOnce</code>、<code>FnMut</code> 和 <code>Fn</code> 等 trait 来表达不同的捕获行为. 使用 <strong>最通用的 <code>Fn*</code> trait</strong> 可以为调用者提供最大的灵活性.</li></ul></div></li><li><strong>优先使用 <code>Option</code> 和 <code>Result</code> 的转换方法</strong>：<div class="component-content component"><ul><li><code>Option&lt;T></code> 用于表示可能存在或不存在的值，而 <code>Result&lt;T, E></code> 用于表示可能成功或失败的操作。</li><li>标准库为 <code>Option</code> 和 <code>Result</code> 提供了多种转换方法，以避免显式使用 <code>match</code> 表达式，从而使代码更简洁。</li></ul></div></li><li><strong>优先使用惯用的错误类型</strong>：<div class="component-content component"><ul><li>当函数可能产生多种不同类型的错误时，可以使用枚举 (enum) 来统一表示。</li><li><code>From</code> trait 可以实现不同错误类型之间的自动转换，配合 <code>?</code> 操作符，可以简化错误处理.</li><li>可以使用 <code>thiserror</code> crate 来简化错误类型定义。</li></ul></div></li><li><strong>理解类型转换</strong>：<div class="component-content component"><ul><li>Rust 中的类型转换通过 <code>From</code> 和 <code>Into</code> trait 实现。如果类型 <code>U</code> 实现了 <code>From&lt;T></code>，那么类型 <code>T</code> 会自动实现 <code>Into&lt;U></code>。</li><li><strong>Coercion (强制转换)</strong> 是一种自动类型转换机制，可以发生在某些情况下，例如：数组到切片、具体类型到 trait 对象、较长的生命周期到较短的生命周期。用户定义的类型可以通过实现 <code>Deref</code> 和 <code>DerefMut</code> trait 来影响 coercion 行为。</li></ul></div></li><li><strong>拥抱 newtype 模式</strong>：<div class="component-content component"><ul><li><strong>newtype 模式</strong> 是指创建一个包含单个字段的元组结构体，可以为现有类型赋予新的语义，并解决一些类型安全问题。</li><li>例如，可以使用 newtype 模式来避免单位转换错误。</li><li>newtype 模式也可以用于绕过孤儿规则 (orphan rule)，为外部类型实现外部 trait。</li></ul></div></li><li><strong>使用 Builder 模式处理复杂类型</strong>：<div class="component-content component"><ul><li><strong>Builder 模式</strong> 可以简化复杂类型的构造过程，允许用户链式调用 setter 方法来设置字段值。</li><li>builder 可以用于创建多个实例，并且可以克隆模板。</li><li>可以使用宏 (macros) 或现有的 crate（如 <code>derive_builder</code>）来减少 builder 模式的样板代码。</li></ul></div></li><li><strong>熟悉引用和指针类型</strong>：<div class="component-content component"><ul><li><strong>引用 (references)</strong> 是一种不拥有数据的指针，分为可变引用 (<code>&amp;mut T</code>) 和不可变引用 (<code>&amp;T</code>)。</li><li><strong>切片 (slices)</strong> 可以引用数组的一部分。</li><li><strong>Vec</strong> 是一种动态数组，可以增长和缩小。</li><li><strong>Trait 对象</strong> 是指向实现了特定 trait 的具体类型的指针，通过虚表 (vtable) 实现动态分发。</li><li><code>Deref</code> 和 <code>DerefMut</code> trait 用于智能指针类型，允许像普通引用一样访问它们指向的数据。</li><li><code>AsRef</code> 和 <code>AsMut</code> trait 用于类型之间的引用转换。</li><li><code>Borrow</code> 和 <code>BorrowMut</code> trait 用于处理引用和被移动的值。</li><li><code>Cow</code> 类型可以持有拥有的数据或借用的数据的引用。</li><li><code>Rc&lt;T></code> 用于在单线程环境中共享所有权。<code>Weak&lt;T></code> 是 <code>Rc&lt;T></code> 的弱引用。</li><li><code>Arc&lt;T></code> 是 <code>Rc&lt;T></code> 的线程安全版本，使用原子计数器。</li><li><code>Mutex&lt;T></code> 用于在多线程环境中保护可变数据。</li></ul></div></li><li><strong>考虑使用迭代器转换而不是显式循环</strong>：<div class="component-content component"><ul><li><strong>迭代器 (iterators)</strong> 提供了一种处理集合的便捷方式，避免显式循环。</li><li>迭代器转换方法可以链式调用，实现复杂的数据处理操作。例如 <code>filter</code>, <code>take</code>, <code>map</code>, <code>sum</code>.</li><li><code>iter()</code> 方法用于创建不可变迭代器，<code>iter_mut()</code> 方法用于创建可变迭代器.</li></ul></div></li></ul></div><div class="component-content pagebody component"><h2 id=第二章trait class=pagebody-header>第二章：Trait</h2></div><p class="component-content component">本章主要介绍 Rust 中的 trait 以及一些常用的标准 trait。</p><div class="component-content component"><ul><li><p class="component-content component"><strong>理解标准 trait</strong>:</p><div class="component-content component"><ul><li><strong>Trait</strong> 描述了类型的行为，允许对不同类型进行抽象操作。</li><li>标准库定义了很多有用的 trait，如 <code>Clone</code>、<code>Copy</code>、<code>Default</code>、<code>PartialEq</code>、<code>Eq</code>、<code>PartialOrd</code>、<code>Ord</code>、<code>Hash</code>、<code>Debug</code> 和 <code>Display</code>。</li><li><code>Clone</code> 用于创建类型的副本，<code>Copy</code> 用于指示类型可以通过按位复制来创建副本。</li><li><code>Default</code> trait 可以提供类型的默认值， 方便初始化结构体.</li><li><code>PartialEq</code> trait 定义了类型的相等性比较，<code>Eq</code> trait 表示类型满足等价关系，即<code>x == x</code>。</li><li><code>PartialOrd</code> trait 用于类型的部分排序，<code>Ord</code> trait 用于类型的完全排序。</li><li><code>Hash</code> trait 用于创建类型的哈希值，<code>Debug</code> trait 用于为程序员显示类型，<code>Display</code> trait 用于为用户显示类型。</li><li>当赋值时，带有 <code>Copy</code> 的类型执行位复制，而没有 <code>Copy</code> 的类型会移动（move）.</li><li>对于没有浮点数相关特性的用户定义类型， 应该尽可能实现 <code>Eq</code> trait。</li><li>标准 trait 总结:<div class="component-content component"><ul><li><strong><code>Clone</code></strong>: 克隆自身. <code>clone</code> 方法</li><li><strong><code>Copy</code></strong>: 标记 trait. 编译器处理按位复制</li><li><strong><code>Default</code></strong>: 默认值. <code>default</code> 方法</li><li><strong><code>PartialEq</code></strong>: 部分相等性. <code>eq</code> 方法</li><li><strong><code>Eq</code></strong>: 完全相等性，标记trait</li><li><strong><code>PartialOrd</code></strong>: 部分排序. <code>partial_cmp</code> 方法</li><li><strong><code>Ord</code></strong>: 完全排序. <code>cmp</code> 方法</li><li><strong><code>Hash</code></strong>: 哈希. <code>hash</code> 方法</li><li><strong><code>Debug</code></strong>: 程序员输出. <code>fmt</code> 方法</li><li><strong><code>Display</code></strong>: 用户输出. <code>fmt</code> 方法</li><li><strong><code>Add</code></strong>, <strong><code>Sub</code></strong>, <strong><code>Mul</code></strong>, <strong><code>Div</code></strong>, <strong><code>Rem</code></strong>: 加减乘除， 求余， <code>add</code>, <code>sub</code>, <code>mul</code>, <code>div</code>, <code>rem</code> 方法</li><li><strong><code>AddAssign</code></strong>, <strong><code>SubAssign</code></strong>, <strong><code>MulAssign</code></strong>, <strong><code>DivAssign</code></strong>, <strong><code>RemAssign</code></strong>: 加减乘除赋值， 求余赋值， <code>add_assign</code>, <code>sub_assign</code>, <code>mul_assign</code>, <code>div_assign</code>, <code>rem_assign</code> 方法</li><li><strong><code>BitAnd</code></strong>, <strong><code>BitOr</code></strong>, <strong><code>BitXor</code></strong>: 按位与或异或, <code>bitand</code>, <code>bitor</code>, <code>bitxor</code> 方法</li><li><strong><code>BitAndAssign</code></strong>, <strong><code>BitOrAssign</code></strong>, <strong><code>BitXorAssign</code></strong>: 按位与或异或赋值, <code>bitand_assign</code>, <code>bitor_assign</code>, <code>bitxor_assign</code> 方法</li><li><strong><code>Neg</code></strong>: 取负, <code>neg</code> 方法</li><li><strong><code>Not</code></strong>: 取反, <code>not</code> 方法</li><li><strong><code>Shl</code></strong>, <strong><code>Shr</code></strong>: 左移， 右移, <code>shl</code>, <code>shr</code> 方法</li><li><strong><code>ShlAssign</code></strong>, <strong><code>ShrAssign</code></strong>: 左移赋值， 右移赋值， <code>shl_assign</code>, <code>shr_assign</code> 方法</li><li><strong><code>Fn</code></strong>, <strong><code>FnMut</code></strong>, <strong><code>FnOnce</code></strong>: 函数调用, <code>call</code>, <code>call_mut</code>, <code>call_once</code> 方法</li><li><strong><code>Error</code></strong>: 错误类型. <code>Display + Debug</code> 方法</li><li><strong><code>From</code></strong>, <strong><code>TryFrom</code></strong>: 类型转换, <code>from</code>, <code>try_from</code> 方法</li><li><strong><code>Into</code></strong>, <strong><code>TryInto</code></strong>: 类型转换, <code>into</code>, <code>try_into</code> 方法</li><li><strong><code>AsRef</code></strong>, <strong><code>AsMut</code></strong>: 引用转换, <code>as_ref</code>, <code>as_mut</code> 方法</li><li><strong><code>Borrow</code></strong>, <strong><code>BorrowMut</code></strong>: 借用转换, <code>borrow</code>, <code>borrow_mut</code> 方法</li><li><strong><code>ToOwned</code></strong>: 克隆, <code>to_owned</code> 方法</li><li><strong><code>Deref</code></strong>, <strong><code>DerefMut</code></strong>: 解引用， <code>deref</code>, <code>deref_mut</code> 方法</li><li><strong><code>Index</code></strong>, <strong><code>IndexMut</code></strong>: 索引访问, <code>index</code>, <code>index_mut</code> 方法</li><li><strong><code>Drop</code></strong>: 析构. <code>drop</code> 方法</li></ul></div></li></ul></div></li><li><p class="component-content component"><strong>理解泛型和 trait 对象之间的权衡</strong>:</p><div class="component-content component"><ul><li><strong>泛型 (generics)</strong> 允许编写可以处理多种类型的代码，使用 trait bounds 来约束类型参数。泛型函数在编译时会被单态化，为每种类型生成不同的代码。<div class="component-content pagebody component code"><div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>trait</span> Draw {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>bounds</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#a6e22e>Bounds</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>on_screen</span><span style=color:#f92672>&lt;</span>T: <span style=color:#a6e22e>Draw</span><span style=color:#f92672>&gt;</span>(draw: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>T</span>) -&gt; <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>     overlap(<span style=color:#66d9ef>SCREEN_BOUNDS</span>, draw.bounds()).is_some()
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></div></li><li><strong>Trait 对象</strong> 是指向实现了特定 trait 的类型的指针，允许在运行时进行动态分发。trait 对象的大小不固定 (fat pointers), 包含指向数据和虚表的指针。</li><li>泛型可能会导致代码膨胀，因为编译器为每种类型生成一个副本，而 trait 对象只有一个实例。</li><li>泛型在编译时检查类型，并且可以访问类型的所有方法，trait 对象只能访问 trait 中定义的方法。</li><li>为 trait 实现 blanket implementations 可以简化类型操作。</li></ul></div></li></ul></div><div class="component-content pagebody component"><h2 id=第三章概念concepts class=pagebody-header>第三章：概念（Concepts）</h2></div><p class="component-content component">本章深入探讨 Rust 的一些核心概念，包括生命周期、借用检查器、并发以及错误处理。</p><div class="component-content component"><ul><li><strong>理解生命周期</strong>:<div class="component-content component"><ul><li>Rust 中的每个引用都有一个关联的<strong>生命周期 (lifetime)</strong>，用于确保引用在有效的时间段内使用。</li><li>生命周期标签 (lifetime labels) 表示为 <code>'a</code>，并遵循特定规则。</li><li>生命周期标签可以省略，通过生命周期省略规则来推断.</li><li><strong><code>'static</code> 生命周期</strong> 用于表示永远不会失效的引用，例如全局数据或堆上泄漏的内存。</li><li>生命周期参数的传递遵循 <strong>协变 (covariance)</strong> 规则，即输出的生命周期必须包含在输入的生命周期之内。</li><li><strong>非词法生命周期 (non-lexical lifetimes)</strong> 允许借用检查器更精确地确定引用的生命周期.</li><li>所有 Rust 引用都有生命周期，它影响了数据结构及其引用的生命周期.</li></ul></div></li><li><strong>理解借用检查器</strong>:<div class="component-content component"><ul><li><strong>借用检查器 (borrow checker)</strong> 是 Rust 编译器的重要组成部分，用于确保内存安全和避免数据竞争。</li><li>借用规则包括：可变借用 (mutable borrow) 和不可变借用 (immutable borrow), 一个资源在同一时间只能有一个可变借用或多个不可变借用。</li><li><strong><code>std::mem::replace</code></strong> 可以用于替换可变引用的值。</li><li>使用局部变量和显式类型注释可以帮助理解复杂的类型转换和借用问题。</li><li>解决借用检查器错误的方法包括：使用数据结构设计， 使用局部代码重构， 使用智能指针。</li><li>树形结构可以使用 <code>Rc&lt;RefCell&lt;T>></code> 和 <code>Weak&lt;T></code> 实现。</li></ul></div></li><li><strong>避免编写不安全的代码</strong>:<div class="component-content component"><ul><li><code>unsafe</code> 关键字用于表示一段不安全的代码，需要开发者自行保证内存安全。</li><li>应该尽可能避免使用 <code>unsafe</code> 代码，优先使用标准库或第三方 crate 提供的安全抽象。</li><li><code>once_cell</code>、<code>rand</code>、<code>byteorder</code> 和 <code>cxx</code> 等 crate 封装了不安全代码，提供了常用的功能。</li></ul></div></li><li><strong>警惕共享状态的并行</strong>:<div class="component-content component"><ul><li><strong>数据竞争 (data race)</strong> 指的是多个线程同时访问同一个可变数据，并且至少有一个线程在进行写入操作。</li><li>多线程环境下的数据竞争会导致不确定的行为。</li><li>C++ 中的多线程示例展示了未加锁的代码可能出现的问题。</li><li>可以使用互斥锁 (mutex) 或原子操作来避免数据竞争， 保证多线程安全。</li><li>Rust 中使用 <code>Mutex</code> 和 <code>Arc</code> 类型实现线程安全的数据共享。</li><li>多线程编程时，应该优先考虑简单且明显正确的代码，而不是复杂且不明显错误的代码。</li></ul></div></li><li><strong>不要 panic!</strong>:<div class="component-content component"><ul><li><strong>panic!</strong> 宏会导致程序崩溃，应该尽可能避免使用，而应该优先返回 <code>Result</code> 类型，让调用者处理错误。</li><li><code>Result</code> 类型可以传递错误信息，使错误处理更加明确和可控。</li></ul></div></li><li><strong>避免反射</strong>:<div class="component-content component"><ul><li>Rust 中没有像 Java 那样的运行时反射机制，但可以使用 <code>std::any::type_name</code> 和 <code>std::any::Any</code> trait 来获取类型信息。</li><li><code>type_name</code> 函数在编译时访问类型信息, 没有运行时代码确定类型.</li><li><code>Any</code> trait 对象本质上是指向具体项的原始指针和类型标识符的组合，可以通过 <code>downcast_ref</code> 和 <code>downcast_mut</code> 方法进行类型转换.</li><li>Trait 对象只能访问 trait 中定义的方法，不能动态转换到其他 trait 对象.</li></ul></div></li><li><strong>避免过度优化</strong>:<div class="component-content component"><ul><li>过早优化可能会导致代码难以理解和维护，应该优先编写清晰易懂的代码。</li><li>应该优先编写简单, 容易理解的代码， 而不是那些很难理解的非配零拷贝算法</li><li>一个过早优化的示例是使用生命周期标注的结构体，虽然它避免了内存拷贝，但难以使用。</li><li>拥有数据结构可以改善代码的人体工程学。</li></ul></div></li></ul></div><div class="component-content pagebody component"><h2 id=第四章依赖dependencies class=pagebody-header>第四章：依赖（Dependencies）</h2></div><p class="component-content component">本章讨论 Rust 项目中的依赖管理，包括语义化版本控制、模块和依赖冲突。</p><div class="component-content component"><ul><li><strong>理解语义化版本控制的承诺</strong>:<div class="component-content component"><ul><li><strong>语义化版本控制 (SemVer)</strong> 用于描述库的版本号，并表达不同版本之间的兼容性。</li><li>版本号通常由三个部分组成：主版本号、次版本号和修订号 (major.minor.patch)。</li><li>更改主版本号表示不兼容的 API 更改，更改次版本号表示添加了新的兼容功能，更改修订号表示修复了 bug。</li><li>作为库的作者，应该避免在补丁版本中破坏兼容性，并通过 Git 标签来管理版本。</li><li>避免使用通配符（如 <code>*</code> 或 <code>0.*</code>）指定依赖的版本，这样会导致依赖的版本可能与您的库不兼容。</li></ul></div></li><li><strong>模块的可见性</strong>:<div class="component-content component"><ul><li><code>pub</code> 关键字表示模块项是公开的，可以被其他模块访问。</li><li><code>pub(crate)</code> 表示该项只能在当前 crate 中访问。</li><li><code>pub(in path)</code> 表示该项只能在指定的路径中访问.</li><li><code>pub(super)</code> 和 <code>pub(self)</code> 表示在父模块和当前模块中访问。</li><li>应该优先选择私有代码，而不是公共代码</li></ul></div></li><li><strong>依赖冲突</strong>:<div class="component-content component"><ul><li>依赖冲突可能发生在多个 crate 使用相同名称的类型或 trait 时，可以使用 <code>as</code> 关键字来重命名导入的项.</li><li>当多个 crate 使用相同名称的 trait，并且实现了相同的方法时，可能会出现冲突.</li><li>当直接依赖和传递依赖使用了同一个 crate，但不同版本时，可能会出现依赖冲突。</li><li>Cargo 会尽可能地选择兼容的版本，并生成依赖关系图。</li><li>对于同名的 crate，可以使用别名来消除歧义 .</li></ul></div></li><li><strong>Cargo 功能</strong>:<div class="component-content component"><ul><li><strong>Cargo features</strong> 允许可选地启用或禁用某些功能，使得代码可以有条件编译。</li><li>Features 可以在 <code>Cargo.toml</code> 中定义，并在代码中使用 <code>#[cfg(feature = "name")]</code> 进行条件编译.</li><li>避免在 public 结构体中使用 feature-gated 的字段，因为用户可能会不知道是否应该使用它们.</li><li>功能名称应该避免与 crate 的名称冲突， 因为他们共享命名空间.</li></ul></div></li></ul></div><div class="component-content pagebody component"><h2 id=第五章工具tooling class=pagebody-header>第五章：工具（Tooling）</h2></div><p class="component-content component">本章介绍 Rust 开发中常用的一些工具，包括文档生成、宏、Clippy 和测试。</p><div class="component-content component"><ul><li><strong>文档化公共接口</strong>:<div class="component-content component"><ul><li>应该为公共接口编写文档注释，以提高代码的可读性和可维护性。</li><li>避免在文档中重复代码中已有的信息，重点描述代码的目的和使用方式。</li><li>使用 <code>///</code> 来编写文档，使用 <code>//!</code> 来描述整个模块.</li><li>文档注释应当关注 Why，而不是 What 和 How, 这样能够更好的抵抗代码变化.</li></ul></div></li><li><strong>明智地使用宏</strong>:<div class="component-content component"><ul><li>宏 (macros) 是一种元编程工具，可以生成代码，从而避免代码重复。</li><li><strong>声明宏 (declarative macros)</strong> 使用 <code>macro_rules!</code> 声明，通过模式匹配来生成代码。<div class="component-content pagebody component code"><div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>macro_rules<span style=color:#f92672>!</span> inc_item {
</span></span><span style=display:flex><span>    { <span style=color:#75715e>$x</span>:<span style=color:#a6e22e>ident</span> } <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>$x</span>.contents <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></div></li><li>宏可以修改或使用其参数，所以可能会产生意想不到的副作用。</li><li>宏扩展后的代码可以包含控制流操作。</li><li>使用 <code>format_args!</code> 宏可以构建格式化的字符串。</li><li><strong>过程宏 (procedural macros)</strong> 使用函数来处理 TokenStream，分为函数式过程宏、属性过程宏和派生过程宏.</li><li><code>syn</code> crate 可以帮助解析过程宏的输入。</li><li>尽可能的使用声明宏而不是函数式的过程宏, 因为前者更容易编写</li><li>应该优先选择泛型，然后是宏来避免重复.</li><li>使用宏保持相关信息同步.</li><li>宏定义中的<code>$( ... )+</code>语法可以为宏的每一个参数生成多行代码.</li></ul></div></li><li><strong>听取 Clippy 的建议</strong>:<div class="component-content component"><ul><li><strong>Clippy</strong> 是一个 Rust 代码的静态分析工具，可以提供代码质量、性能和可读性方面的建议。</li><li>Clippy 可以指出代码中不必要的操作，潜在的错误，以及可以改进的地方。</li><li>Clippy 也可以用来查找重复依赖和使用通配符导入.</li><li>应该把 Clippy 当作一个有用的助手而不是一个需要对抗的敌人.</li></ul></div></li><li><strong>编写超越单元测试的测试</strong>:<div class="component-content component"><ul><li>应该编写多种类型的测试，包括单元测试、集成测试、行为测试和模糊测试等，以确保代码的质量和健壮性。</li><li>单元测试使用 <code>#[test]</code> 属性标记，并使用 <code>assert_eq!</code> 等宏进行断言。</li><li>可以使用 <code>#[should_panic]</code> 属性来测试会 panic 的代码.</li><li>还可以使用 <code>cargo-fuzz</code> 来进行模糊测试， 以及 <code>criterion</code> crate 进行基准测试.</li><li><code>cargo-expand</code> 可以用来查看宏展开后的代码.</li></ul></div></li><li><strong>充分利用工具生态系统</strong>:<div class="component-content component"><ul><li>Rust 的工具生态系统非常丰富，包括代码格式化工具（<code>rustfmt</code>）、代码分析工具（Clippy）、测试工具和文档生成工具等.</li><li><code>bindgen</code> 可以用来为 C 库自动生成 Rust FFI 绑定.</li></ul></div></li></ul></div><div class="component-content pagebody component"><h2 id=第六章超越标准-rustbeyond-standard-rust class=pagebody-header>第六章：超越标准 Rust（Beyond Standard Rust）</h2></div><p class="component-content component">本章讨论了超越标准 Rust 的一些主题，包括 <code>no_std</code> 环境、FFI 和 Rust 与 C 的互操作性。</p><div class="component-content component"><ul><li><strong>考虑使库代码与 <code>no_std</code> 兼容</strong>:<div class="component-content component"><ul><li><code>no_std</code> 属性表示代码不依赖于标准库，可以在没有操作系统支持的环境下运行。</li><li><code>no_std</code> 环境需要使用 <code>extern crate alloc;</code> 来引入分配器，并手动处理内存分配。</li><li><code>no_std</code> 环境下可以使用 <code>alloc</code> crate 中的类型，如 <code>Box&lt;T></code>、<code>Vec&lt;T></code> 和 <code>String</code>。</li><li><code>try_reserve</code> 方法可以用来进行失败的内存分配.</li></ul></div></li><li><strong>控制跨越 FFI 边界的内容</strong>:<div class="component-content component"><ul><li><strong>FFI (Foreign Function Interface)</strong> 用于调用其他语言的代码，如 C 代码。</li><li>在 FFI 边界，应该小心处理内存管理，避免内存泄漏或不安全的访问。</li><li>可以使用封装结构体 (wrapper struct) 来管理 FFI 资源.</li><li>C 语言的原始指针需要进行空检查.</li><li>可以使用 <code>repr(C)</code> 属性来确保结构体在 C 中的内存布局与 Rust 中的相同.</li></ul></div></li><li><strong>优先选择 bindgen 而不是手动 FFI 映射</strong>:<div class="component-content component"><ul><li><strong>bindgen</strong> 是一个用于自动生成 Rust FFI 绑定的工具，可以简化 C 代码与 Rust 代码的交互。</li><li>bindgen 可以生成类似于手工编写的 FFI 声明代码.</li><li>bindgen 可以处理 C 结构体、函数和枚举，避免手动编写 FFI 绑定的繁琐工作.</li><li>bindgen 也能处理 C++ 代码中的一些结构 .</li></ul></div></li><li><strong>其他主题</strong>:<div class="component-content component"><ul><li>本章还提到了 bare-metal Rust 和 crates.io 生态系统，鼓励读者探索更多 Rust 的可能性.</li></ul></div></li></ul></div><p class="component-content component"><strong>总结</strong></p><p class="component-content component">《Effective Rust》这本书深入探讨了 Rust 编程语言中的各种最佳实践和重要概念。通过阅读本书，可以学习如何有效地利用 Rust 的类型系统、内存安全机制、并发模型以及丰富的工具生态系统，编写高质量的 Rust 代码。 这本书为 Rust 程序员提供了非常实用的建议，帮助他们编写更加清晰、安全、高效的代码。</p></div><div id=comments class=utterances><script src=https://utteranc.es/client.js repo=smallnest/booslip.rpcx.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></article></section></main><script>var script=document.createElement("script");script.src="https://booslip.rpcx.io/js/initPost.js",document.head.appendChild(script)</script><div class=footer-main><div class="content-body footer-wraper"><div class=footer-box><div class=foot-nav><div class=foot-nav-items><div class=item><div class=logo></div><div class=email>Email: <a href=mailto:smallnest@gmail.com>smallnest@gmail.com</a></div></div><div class="item community"><div class=item-title>社交媒体</div><a href=https://github.com/smallnest target=_blank>Github</a></div><div class="item resources"><div class=item-title>友链</div><a href=https://colobu.com/ target=_blank>鸟窝</a></div></div></div><div class=bottom><div class="item copyright">鸟窝 &copy; 2025 All Rights Reserved.</div></div></div></div></div></body></html>