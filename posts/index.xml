<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 竹简书摘</title><link>https://booslip.rpcx.io/posts/</link><description>Recent content in Posts on 竹简书摘</description><generator>Hugo</generator><language>zh-CN</language><copyright>鸟窝</copyright><lastBuildDate>Tue, 21 Jan 2025 18:07:50 +0800</lastBuildDate><atom:link href="https://booslip.rpcx.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Build Your Own Database From Scratch in Go 2nd</title><link>https://booslip.rpcx.io/posts/build-your-own-database-from-scratch-in-go-2nd/</link><pubDate>Tue, 21 Jan 2025 18:07:50 +0800</pubDate><guid>https://booslip.rpcx.io/posts/build-your-own-database-from-scratch-in-go-2nd/</guid><description>&lt;div class="component-content pagebody component">
 &lt;h2 id="第-00-章导论" class="pagebody-header">
 &lt;strong>第 00 章：导论&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>本章强调通过&lt;strong>实践&lt;/strong>来掌握数据库的基本原理，而不是陷入复杂的术语。&lt;/li>
&lt;li>核心学习内容包括：
&lt;ul>
&lt;li>&lt;strong>原子性和持久性&lt;/strong>：确保数据更新要么全部成功，要么全部失败，并且更新后的数据能够可靠地保存。&lt;/li>
&lt;li>基于 &lt;strong>B 树的键值存储&lt;/strong>：使用 B 树作为磁盘数据结构的基础。&lt;/li>
&lt;li>&lt;strong>关系型数据库构建于键值存储之上&lt;/strong>：理解表和索引如何映射到低级别的 B 树。&lt;/li>
&lt;li>&lt;strong>并发事务控制&lt;/strong>：管理多个并发事务。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>通过约 3000 行代码逐步构建一个数据库。&lt;/li>
&lt;li>数据库的核心原理并不复杂，每个人都可以尝试构建。&lt;/li>
&lt;li>本章提到了 SQLite 在智能手机上的广泛使用，并强调了数据库在崩溃时保护数据的重要性。&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第-01-章从文件到数据库" class="pagebody-header">
 &lt;strong>第 01 章：从文件到数据库&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>本章讨论了直接使用文件存储数据时面临的问题，例如在更新过程中崩溃导致的数据损坏。&lt;/li>
&lt;li>&lt;strong>原子重命名&lt;/strong>：通过将新文件重命名为旧文件的路径来实现原子替换，避免了在原位置更新数据。
&lt;ul>
&lt;li>这种方法确保了在更新中断时，可以从旧文件恢复，并且并发读取不会读取到一半写入的数据。&lt;/li>
&lt;li>重命名操作在文件系统中是原子的，成本与数据大小无关。&lt;/li>
&lt;li>重命名对于并发读取是原子的，但对于断电不是原子的，需要额外的 &lt;code>fsync&lt;/code> 操作。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>使用校验和进行原子日志更新&lt;/strong>：通过在每个日志条目中添加校验和，可以检测到日志条目的损坏，并确保日志更新的原子性。&lt;/li>
&lt;li>总结了数据库面临的挑战：
&lt;ul>
&lt;li>避免在原位置更新。&lt;/li>
&lt;li>使用仅追加日志进行增量更新。&lt;/li>
&lt;li>使用 &lt;code>fsync&lt;/code> 来保证数据持久化。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>提出了需要解决的问题：
&lt;ul>
&lt;li>如何索引数据结构并更新它们。&lt;/li>
&lt;li>如何重用仅追加文件中的空间。&lt;/li>
&lt;li>如何将日志与索引数据结构结合。&lt;/li>
&lt;li>如何处理并发。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第-02-章索引数据结构" class="pagebody-header">
 &lt;strong>第 02 章：索引数据结构&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>介绍了三种主要的 SQL 查询类型：
&lt;ul>
&lt;li>&lt;strong>扫描整个数据集&lt;/strong>（不使用索引）。&lt;/li>
&lt;li>&lt;strong>点查询&lt;/strong>（通过特定键查询索引）。&lt;/li>
&lt;li>&lt;strong>范围查询&lt;/strong>（通过范围查询索引，索引是排序的）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>LSM 树（Log-Structured Merge-Tree）&lt;/strong>：
&lt;ul>
&lt;li>通过缓冲更新来减少写入放大，避免每次都重写整个数据集。&lt;/li>
&lt;li>多层结构，每一层都包含排序的数据。&lt;/li>
&lt;li>级别呈指数增长，通过合并大小相似的级别来减少写入放大。&lt;/li>
&lt;li>查询时需要合并来自每一层的结果。&lt;/li>
&lt;li>使用 Bloom 过滤器优化点查询，减少搜索的级别。&lt;/li>
&lt;li>删除的键用 tombstone 标记，并在合并过程中回收空间。&lt;/li>
&lt;li>SSTable（Sorted String Table）、MemTable 和日志是 LSM 树的实现细节。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第-03-章b-树和崩溃恢复" class="pagebody-header">
 &lt;strong>第 03 章：B 树和崩溃恢复&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>B 树&lt;/strong>：
&lt;ul>
&lt;li>是一种高度平衡的 n 叉树，所有叶子节点的高度相同。&lt;/li>
&lt;li>每个节点可以有 2、3 或 4 个子节点的 2-3-4 树是 B 树的一个例子。&lt;/li>
&lt;li>可以通过排序数组来理解 B 树。&lt;/li>
&lt;li>只有叶子节点包含值，内部节点包含键，指示子树的键范围。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>维护 B+ 树的三个不变量&lt;/strong>：
&lt;ul>
&lt;li>所有叶子节点的高度相同。&lt;/li>
&lt;li>节点大小受限于一个常量。&lt;/li>
&lt;li>节点不为空。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>通过拆分节点来增长 B 树&lt;/strong>：当插入导致节点超出大小限制时，将节点拆分为更小的节点，并可能导致父节点也需要拆分，最终导致树的高度增加。&lt;/li>
&lt;li>&lt;strong>通过合并节点来缩小 B 树&lt;/strong>：删除可能导致空节点，此时需要将空节点与其兄弟节点合并，合并操作也可能传播到根节点，导致树的高度降低。&lt;/li>
&lt;li>&lt;strong>Copy-on-write B 树&lt;/strong>：
&lt;ul>
&lt;li>为了安全地更新 B 树，先复制节点，并在副本上进行修改，更新父节点指向新节点，复制操作传播到根节点，形成新的树根。&lt;/li>
&lt;li>原树保持不变，可以从旧的根访问。&lt;/li>
&lt;li>这种方法被称为 copy-on-write 数据结构，也称为不可变或持久性。&lt;/li>
&lt;li>解决了如何找到树根的问题，并使用空闲列表来复用旧版本的节点。&lt;/li>
&lt;li>优点包括免费获得快照隔离，以及轻松的崩溃恢复。&lt;/li>
&lt;li>适用于多读单写并发模型。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>In-place 更新的双写技术&lt;/strong>：
&lt;ul>
&lt;li>通过保存更新节点的副本，&lt;code>fsync&lt;/code> 保存的副本，进行原位置更新，并再次 &lt;code>fsync&lt;/code> 更新，实现崩溃恢复。&lt;/li>
&lt;li>在崩溃后，使用保存的副本来恢复数据结构。&lt;/li>
&lt;li>双写使更新具有幂等性，允许 DB 重试更新。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>崩溃恢复的原则&lt;/strong>：确保在任何时候都有足够的信息来恢复到旧状态或新状态。&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第-04-章b-树节点和插入" class="pagebody-header">
 &lt;strong>第 04 章：B+ 树节点和插入&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>B+ 树节点的设计&lt;/strong>：所有 B+ 树节点大小相同，以便使用空闲列表。
&lt;ul>
&lt;li>节点包含固定大小的头部，包括节点类型和键的数量。&lt;/li>
&lt;li>内部节点包含指向子节点的指针列表。&lt;/li>
&lt;li>节点包含键值对列表和指向键值对的偏移列表，用于二分查找。&lt;/li>
&lt;li>简化了实现，仅关注基本原理。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>数据结构与 IO 解耦&lt;/strong>：使用回调来抽象空间分配和释放，在数据结构和 DB 的其余部分之间建立边界。&lt;/li>
&lt;li>&lt;strong>节点格式&lt;/strong>：
&lt;ul>
&lt;li>头部：节点类型 (2B) 和键的数量 (2B)。&lt;/li>
&lt;li>子节点指针：&lt;code>nkeys * 8B&lt;/code>。&lt;/li>
&lt;li>键值对偏移量：&lt;code>nkeys * 2B&lt;/code>。&lt;/li>
&lt;li>键值对：&lt;code>klen (2B) | vlen (2B) | key | val&lt;/code>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>节点更新&lt;/strong>：在叶子节点插入键值对时，使用 &lt;code>nodeLookupLE&lt;/code> 找到插入位置，然后将所有内容复制到包含新键的新节点中。&lt;/li>
&lt;li>&lt;strong>节点拆分&lt;/strong>：
&lt;ul>
&lt;li>当节点过大时，将其拆分为 2 或 3 个节点。&lt;/li>
&lt;li>&lt;code>nodeSplit2&lt;/code> 将节点拆分为两个。&lt;/li>
&lt;li>&lt;code>nodeSplit3&lt;/code> 将节点拆分为最多三个。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>B+ 树插入&lt;/strong>：从根节点开始进行键查找，直到到达叶子节点，然后执行插入操作，可能会导致节点拆分。
&lt;ul>
&lt;li>&lt;code>treeInsert&lt;/code> 函数递归地插入键值对。&lt;/li>
&lt;li>&lt;code>nodeInsert&lt;/code> 函数处理内部节点的插入。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第-05-章b-树删除和测试" class="pagebody-header">
 &lt;strong>第 05 章：B+ 树删除和测试&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>高层接口&lt;/strong>：
&lt;ul>
&lt;li>&lt;code>Insert&lt;/code> 函数用于插入新键或更新现有键。&lt;/li>
&lt;li>&lt;code>Delete&lt;/code> 函数用于删除键，并返回键是否存在。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>维护根节点&lt;/strong>：
&lt;ul>
&lt;li>如果树为空，则创建根节点。&lt;/li>
&lt;li>如果根节点拆分，则添加新的根节点。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>哨兵值&lt;/strong>：在创建第一个根时插入一个空键，以消除边缘情况。&lt;/li>
&lt;li>&lt;strong>合并条件&lt;/strong>：删除可能导致空节点，此时可以将空节点与兄弟节点合并。
&lt;ul>
&lt;li>&lt;code>shouldMerge&lt;/code> 函数判断是否应该与兄弟节点合并。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>测试 B+ 树&lt;/strong>：
&lt;ul>
&lt;li>使用内存模拟页面的方式来测试 B+ 树。&lt;/li>
&lt;li>&lt;code>C&lt;/code> 结构体包含一个 &lt;code>BTree&lt;/code>，一个引用数据 &lt;code>ref&lt;/code> 和一个内存页面的映射 &lt;code>pages&lt;/code>。&lt;/li>
&lt;li>使用 &lt;code>C.pages&lt;/code> 来验证指针并读取页面。&lt;/li>
&lt;li>验证结构是否有效（键是否排序，节点大小是否在限制内）和数据是否与引用匹配。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第-06-章仅追加键值存储" class="pagebody-header">
 &lt;strong>第 06 章：仅追加键值存储&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>基于文件的键值存储&lt;/strong>：
&lt;ul>
&lt;li>使用 copy-on-write B+ 树，并使用文件作为持久化存储。&lt;/li>
&lt;li>文件是仅追加的，空间重用将在下一章节讨论。&lt;/li>
&lt;li>忽略并发，假设在一个进程内进行顺序访问。&lt;/li>
&lt;li>实现了处理磁盘页面的三个 B+ 树回调。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>两阶段更新&lt;/strong>：
&lt;ul>
&lt;li>先写入新节点，&lt;code>fsync&lt;/code> 来保证顺序。&lt;/li>
&lt;li>然后原子地更新根指针，再次 &lt;code>fsync&lt;/code> 来使一切持久化。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>使用日志的持久性&lt;/strong>：
&lt;ul>
&lt;li>双写方案也需要两个 &lt;code>fsync&lt;/code> 阶段。&lt;/li>
&lt;li>双写类似于日志，只需要一个 &lt;code>fsync&lt;/code> 进行更新。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>内存数据的并发&lt;/strong>：
&lt;ul>
&lt;li>可以使用互斥锁或原子 CPU 指令实现内存数据的原子性。&lt;/li>
&lt;li>内存数据的可见性需要内存屏障，类似于 &lt;code>fsync&lt;/code>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>文件布局&lt;/strong>：
&lt;ul>
&lt;li>数据库是一个文件，分为多个页面。&lt;/li>
&lt;li>第一页是元页面，包含指向最新根节点的指针和辅助数据。&lt;/li>
&lt;li>新节点以日志形式追加，文件的页面数量存储在元页面中。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>目录上的 &lt;code>fsync&lt;/code>&lt;/strong>：在创建新文件后，需要在父目录上执行 &lt;code>fsync&lt;/code>。&lt;/li>
&lt;li>&lt;strong>&lt;code>mmap&lt;/code>、页面缓存和 IO&lt;/strong>：&lt;code>mmap&lt;/code> 允许像内存缓冲区一样读写文件，磁盘 IO 是隐式和自动的。&lt;/li>
&lt;li>&lt;strong>管理磁盘页面&lt;/strong>：使用 &lt;code>mmap&lt;/code> 实现页面管理回调。&lt;/li>
&lt;li>&lt;strong>元页面&lt;/strong>：元页面包含魔术字节、根指针和页面使用数量，并使用 &lt;code>saveMeta&lt;/code> 和 &lt;code>loadMeta&lt;/code> 函数来保存和加载。
&lt;ul>
&lt;li>使用 &lt;code>pwrite&lt;/code> 原子地更新元页面。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>错误处理&lt;/strong>：
&lt;ul>
&lt;li>IO 错误后，可以回滚到旧的树根。&lt;/li>
&lt;li>需要处理临时写入错误。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第-07-章空闲列表回收和重用" class="pagebody-header">
 &lt;strong>第 07 章：空闲列表：回收和重用&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>内存管理技术&lt;/strong>：讨论了手动和自动内存管理，以及如何重用未使用的对象。&lt;/li>
&lt;li>&lt;strong>空闲列表&lt;/strong>：存储未使用的页面列表，以便重用。&lt;/li>
&lt;li>&lt;strong>嵌入式链表&lt;/strong>：最简单的方案是在对象内部嵌入链表指针，但与 copy-on-write 冲突。&lt;/li>
&lt;li>&lt;strong>空闲列表磁盘布局&lt;/strong>：每个节点都包含指向下一个节点的指针，项目追加到尾节点，并从头节点消费。&lt;/li>
&lt;li>&lt;strong>更新空闲列表节点&lt;/strong>：列表节点的更新是在原位置进行的，但在页面内部是追加的，不需要额外的崩溃恢复。&lt;/li>
&lt;li>&lt;strong>空闲列表接口&lt;/strong>：&lt;code>FreeList&lt;/code> 结构体包含页面管理回调和元数据。
&lt;ul>
&lt;li>&lt;code>PopHead&lt;/code> 函数从列表头部获取一个项目。&lt;/li>
&lt;li>&lt;code>PushTail&lt;/code> 函数将项目添加到尾部。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>空闲列表数据结构&lt;/strong>：
&lt;ul>
&lt;li>使用 &lt;code>headSeq&lt;/code> 和 &lt;code>tailSeq&lt;/code> 作为单调递增的索引。&lt;/li>
&lt;li>&lt;code>SetMaxSeq&lt;/code> 函数设置 &lt;code>maxSeq&lt;/code>，以防止消耗新添加的项目。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>从空闲列表消费&lt;/strong>：&lt;code>flPop&lt;/code> 函数从头部删除一个项目，并移动到下一个节点。&lt;/li>
&lt;li>&lt;strong>推送到空闲列表&lt;/strong>：&lt;code>PushTail&lt;/code> 函数将项目追加到尾部节点，如果尾部节点满了，则添加新的空尾部节点。&lt;/li>
&lt;li>&lt;strong>带空闲列表的 KV&lt;/strong>：
&lt;ul>
&lt;li>页面管理现在可以使用空闲列表。&lt;/li>
&lt;li>&lt;code>pageAlloc&lt;/code> 函数优先使用空闲列表，再追加页面。&lt;/li>
&lt;li>&lt;code>pageWrite&lt;/code> 函数返回一个可写的页面副本。&lt;/li>
&lt;li>&lt;code>pageRead&lt;/code> 函数优先从待更新映射中读取，再从文件中读取.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>更新元页面&lt;/strong>：元页面现在包括空闲列表指针，和树根一起原子更新。&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第-08-章键值存储上的表" class="pagebody-header">
 &lt;strong>第 08 章：键值存储上的表&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>将行编码为 KV&lt;/strong>：
&lt;ul>
&lt;li>在关系型数据库中，数据被建模为二维表，由行和列组成。&lt;/li>
&lt;li>定义了 &lt;code>Record&lt;/code> 结构体来表示表行。&lt;/li>
&lt;li>定义了 &lt;code>TableDef&lt;/code> 结构体来表示表模式。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>内部表&lt;/strong>：
&lt;ul>
&lt;li>使用预定义的内部表来存储表模式。&lt;/li>
&lt;li>&lt;code>TDEF_TABLE&lt;/code> 表存储表定义。&lt;/li>
&lt;li>&lt;code>TDEF_META&lt;/code> 表存储自动递增的计数器。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>获取、更新、插入、删除、创建&lt;/strong>：
&lt;ul>
&lt;li>提供了读取和写入单行的接口。&lt;/li>
&lt;li>&lt;code>DB&lt;/code> 结构体是 &lt;code>KV&lt;/code> 的包装器。&lt;/li>
&lt;li>使用 &lt;code>decodeValues&lt;/code> 函数将值解码为列。&lt;/li>
&lt;li>使用 &lt;code>checkRecord&lt;/code> 函数重新排序记录并检查缺少的列。&lt;/li>
&lt;li>使用 &lt;code>encodeKey&lt;/code> 函数对 KV 的键进行编码。&lt;/li>
&lt;li>使用 &lt;code>getTableDef&lt;/code> 函数获取表模式。&lt;/li>
&lt;li>&lt;code>dbGet&lt;/code> 函数从内部表读取表定义。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>插入或更新行&lt;/strong>：
&lt;ul>
&lt;li>&lt;code>INSERT&lt;/code>、&lt;code>UPDATE&lt;/code> 和 &lt;code>UPSERT&lt;/code> 语句在处理现有行方面有所不同。&lt;/li>
&lt;li>使用 &lt;code>MODE_UPSERT&lt;/code>、&lt;code>MODE_UPDATE_ONLY&lt;/code> 和 &lt;code>MODE_INSERT_ONLY&lt;/code> 标志来区分。&lt;/li>
&lt;li>&lt;code>dbUpdate&lt;/code> 函数处理行的插入和更新。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>创建表&lt;/strong>：
&lt;ul>
&lt;li>创建表的过程包括检查重复名称，读取和更新表前缀计数器，并将模式插入到 &lt;code>@table&lt;/code>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>迭代器接口&lt;/strong>：
&lt;ul>
&lt;li>使用 &lt;code>SeekLE&lt;/code> 函数查找小于或等于输入键的最接近位置。&lt;/li>
&lt;li>使用 &lt;code>BIter&lt;/code> 结构体表示 B+ 树的位置，使用 &lt;code>Deref&lt;/code> 函数获取当前 KV 对，使用 &lt;code>Valid&lt;/code> 函数判断是否有效，使用 &lt;code>Prev&lt;/code> 和 &lt;code>Next&lt;/code> 函数向后和向前移动。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第-09-章范围查询" class="pagebody-header">
 &lt;strong>第 09 章：范围查询&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>范围查询&lt;/strong>：介绍了 &lt;code>Scan&lt;/code> 接口，用于执行范围查询。&lt;/li>
&lt;li>&lt;strong>顺序保留编码&lt;/strong>：为了支持范围查询，序列化的键必须按照它们的数据类型进行比较。
&lt;ul>
&lt;li>将无符号整数编码为大端整数。&lt;/li>
&lt;li>将有符号整数转换为无符号整数并翻转符号位。&lt;/li>
&lt;li>使用转义字符来编码字符串，并在末尾添加分隔符。&lt;/li>
&lt;li>通过逐列比较来处理多列比较。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>范围查询&lt;/strong>：&lt;code>Scanner&lt;/code> 结构体是 B+ 树迭代器的包装器。
&lt;ul>
&lt;li>&lt;code>dbScan&lt;/code> 函数选择合适的索引，然后执行查询。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>将缺失的列编码为无穷大&lt;/strong>：使用 &lt;code>&amp;quot;\xff&amp;quot;&lt;/code> 作为 &lt;code>+∞&lt;/code>，使用 &lt;code>&amp;quot;&amp;quot;&lt;/code> 作为 &lt;code>-∞&lt;/code>。
&lt;ul>
&lt;li>通过添加列类型代码作为标签，来支持前缀列上的范围查询。&lt;/li>
&lt;li>使用 &lt;code>encodeKeyPartial&lt;/code> 函数为输入范围进行编码。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第-10-章二级索引" class="pagebody-header">
 &lt;strong>第 10 章：二级索引&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>二级索引&lt;/strong>：通过在更新时删除旧的索引键并插入新的索引键来维护二级索引。&lt;/li>
&lt;li>&lt;strong>多键更新的原子性&lt;/strong>：多个键涉及的更新会丢失原子性，需要回滚到之前的状态。&lt;/li>
&lt;li>&lt;strong>事务接口&lt;/strong>：
&lt;ul>
&lt;li>添加 &lt;code>Begin&lt;/code>、&lt;code>Commit&lt;/code> 和 &lt;code>Abort&lt;/code> 接口来允许原子执行一组操作。&lt;/li>
&lt;li>使用 copy-on-write 来实现原子性，commit 和 rollback 都只是更新根指针。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>替代方案&lt;/strong>：使用日志来实现原子性，在日志 &lt;code>fsync&lt;/code> 后，DB 可以将成功返回给客户端。&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第-11-章原子事务" class="pagebody-header">
 &lt;strong>第 11 章：原子事务&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>将树操作移动到事务&lt;/strong>：将树操作与事务关联，并将它们移动到 &lt;code>KVTX&lt;/code>。&lt;/li>
&lt;li>&lt;strong>事务表操作&lt;/strong>：为基于表的接口添加包装类型 &lt;code>DBTX&lt;/code>。&lt;/li>
&lt;li>&lt;strong>可选择的优化&lt;/strong>：
&lt;ul>
&lt;li>减少多键更新时的复制.&lt;/li>
&lt;li>压缩公共前缀。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第-12-章并发控制" class="pagebody-header">
 &lt;strong>第 12 章：并发控制&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>并发级别&lt;/strong>：
&lt;ul>
&lt;li>讨论了并发客户端的事务操作，区分了只读事务和读写事务。&lt;/li>
&lt;li>介绍了读者-写者锁（RWLock）。&lt;/li>
&lt;li>介绍了读取-复制-更新（RCU）。&lt;/li>
&lt;li>介绍了乐观并发控制和悲观并发控制。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>快照隔离&lt;/strong>：使用 copy-on-write，事务操作在 B+ 树的快照上。
&lt;ul>
&lt;li>&lt;code>KVTX&lt;/code> 结构体包含一个只读快照和本地更新。&lt;/li>
&lt;li>&lt;code>Get&lt;/code> 函数首先从 &lt;code>KVTX.pending&lt;/code> 中读取，然后从 &lt;code>KVTX.snapshot&lt;/code> 中读取。&lt;/li>
&lt;li>&lt;code>CombinedIter&lt;/code> 结构体用于合并两个树的范围查询。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>空闲列表中的版本号&lt;/strong>：
&lt;ul>
&lt;li>为每个版本分配一个单调递增的版本号。&lt;/li>
&lt;li>空闲列表永远不会给出比最旧事务更新的页面。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>处理写入冲突&lt;/strong>：
&lt;ul>
&lt;li>将所有读取添加到 &lt;code>KVTX.reads&lt;/code>。&lt;/li>
&lt;li>将每个成功提交添加到 &lt;code>KV.history&lt;/code>。&lt;/li>
&lt;li>使用 &lt;code>detectConflicts&lt;/code> 函数检测冲突。&lt;/li>
&lt;li>序列化内部数据结构。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第-13-章sql-解析器" class="pagebody-header">
 &lt;strong>第 13 章：SQL 解析器&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>语法、解析器和解释器&lt;/strong>：
&lt;ul>
&lt;li>查询语言是解析为树结构用于进一步处理的字符串。&lt;/li>
&lt;li>示例：SELECT 语句和表达式的树表示。&lt;/li>
&lt;li>通过访问树节点来评估表达式.&lt;/li>
&lt;li>介绍了 &lt;code>INDEX BY&lt;/code> 和 &lt;code>FILTER&lt;/code> 子句。&lt;/li>
&lt;li>使用 &lt;code>QLNode&lt;/code> 结构体表示表达式树节点.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>递归下降&lt;/strong>：
&lt;ul>
&lt;li>每个语句都被划分为更小的部分，包括表达式节点 &lt;code>QLNode&lt;/code>.&lt;/li>
&lt;li>&lt;code>QLSelect&lt;/code>、&lt;code>QLUpdate&lt;/code> 和 &lt;code>QLDelete&lt;/code> 结构体表示不同类型的语句。&lt;/li>
&lt;li>顶级解析器函数 &lt;code>pStmt&lt;/code> 确定语句的类型，然后将其分派给具体的函数。&lt;/li>
&lt;li>&lt;code>pKeyword&lt;/code> 函数匹配和消耗输入中的关键字。&lt;/li>
&lt;li>将输入分成越来越小的部分，直到结束为一个操作符、名称或文字值。&lt;/li>
&lt;li>使用递归将中缀操作符转换为二叉树。&lt;/li>
&lt;li>&lt;code>pExprOr&lt;/code> 是解析表达式的最高级函数，调用 &lt;code>pExprAnd&lt;/code> 等低优先级函数。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第-14-章查询语言" class="pagebody-header">
 &lt;strong>第 14 章：查询语言&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>表达式评估&lt;/strong>：使用 &lt;code>QLEvalContex&lt;/code> 结构体评估表达式。
&lt;ul>
&lt;li>&lt;code>qlEval&lt;/code> 函数评估表达式树。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>范围查询&lt;/strong>：
&lt;ul>
&lt;li>&lt;code>QLScan&lt;/code> 结构体表示一个范围查询。&lt;/li>
&lt;li>&lt;code>qlScanInit&lt;/code> 函数初始化扫描器，将 &lt;code>QLNode&lt;/code> 转换为 &lt;code>Record&lt;/code> 和 &lt;code>CMP_??&lt;/code>。&lt;/li>
&lt;li>根据 &lt;code>Key1&lt;/code> 和 &lt;code>Key2&lt;/code> 的类型来设置比较操作符。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>重新审视无穷大编码&lt;/strong>：使用空元组来处理仅使用前缀的查询。
&lt;ul>
&lt;li>使用 &lt;code>covered&lt;/code> 函数来判断索引是否覆盖。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>结果迭代器&lt;/strong>：
&lt;ul>
&lt;li>&lt;code>RecordIter&lt;/code> 接口定义了迭代器的通用接口。&lt;/li>
&lt;li>&lt;code>qlSelectIter&lt;/code> 结构体用于在 SELECT 中计算表达式。&lt;/li>
&lt;li>&lt;code>qlScanIter&lt;/code> 结构体处理过滤。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>结论和下一步&lt;/strong>：总结了实现的多个接口，以及下一步的计划。
&lt;ul>
&lt;li>创建一个网络协议，让 DB 在不同的进程或机器上运行。&lt;/li>
&lt;li>创建一门编程语言并编译为机器代码。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>C# 12 Pocket Reference</title><link>https://booslip.rpcx.io/posts/c%23-12-pocket-reference/</link><pubDate>Thu, 09 Jan 2025 19:05:16 +0800</pubDate><guid>https://booslip.rpcx.io/posts/c%23-12-pocket-reference/</guid><description>&lt;p>这本书旨在为 C# 12 程序员提供快速参考。以下是各章节的知识点概要：&lt;/p>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第一章c-初体验" class="pagebody-header">
 &lt;strong>第一章：C# 初体验&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;pre>&lt;code>* 介绍了第一个 C# 程序，展示了如何进行简单的乘法运算并将结果输出到屏幕。
* 解释了 C# 程序由语句组成，语句以分号结尾，并按顺序执行。
* 提到了 C# 中的不同类型的函数，如方法和运算符。
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第二章语法" class="pagebody-header">
 &lt;strong>第二章：语法&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;pre>&lt;code>* 介绍了 C# 的基本语法元素，包括标识符和关键字。
* 标识符是程序员为类、方法、变量等选择的名称，必须以字母或下划线开头。C# 标识符区分大小写。
* 关键字是 C# 语言中预定义的保留字，例如 `using`，`int` 等。
* 介绍了上下文关键字，它们可以在特定上下文中使用，而无需 `@` 前缀。
* 解释了字面值、标点符号和运算符的概念。
* 描述了 C# 中单行和多行注释的使用方法。
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第三章类型基础" class="pagebody-header">
 &lt;strong>第三章：类型基础&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;pre>&lt;code>* 介绍了 C# 中的基本类型，包括 **`int`**，**`string`** 和 **`bool`**。
* **`int`** 类型表示 32 位整数。
* **`string`** 类型表示字符序列。
* **`bool`** 类型表示布尔值 `true` 或 `false`。
* 阐述了如何创建自定义类型，并通过一个 `UnitConverter` 类来说明。
* 解释了 **`public`** 关键字的作用，它用于暴露类的成员给外部访问。
* 还讲解了 C# 中程序结构的组织，如 `using` 指令，语句和方法声明，类型和命名空间声明，以及顶级语句。
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第四章数值类型" class="pagebody-header">
 &lt;strong>第四章：数值类型&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;pre>&lt;code>* 详细介绍了 C# 中预定义的数值类型，包括有符号和无符号整数、浮点数和十进制数。
* 提到了不同数值类型的范围和大小，以及它们在 .NET 中的对应类型。
* **`int`** 和 **`long`** 是最常用的整数类型，而 **`float`** 和 **`double`** 则用于科学和图形计算，**`decimal`** 用于金融计算。
* 介绍了数值字面值的表示方式，包括十进制、十六进制和二进制，以及如何使用下划线提高可读性。
* 讲解了算术运算符，包括 `+`、`-`、`*`、`/` 和 `%`。
* 解释了增量和减量运算符 (`++` 和 `--`) 的用法。
* 讨论了整数除法和溢出问题，以及如何使用 `checked` 和 `unchecked` 运算符来处理溢出。
* 介绍了位运算符，包括 `~`、`&amp;amp;`、`|`、`^`、`&amp;lt;&amp;lt;` 和 `&amp;gt;&amp;gt;`。
* 讲解了 8 位和 16 位整数类型，以及它们与较大整数类型之间的隐式转换。
* 解释了浮点数类型的特殊值，如 `NaN`、`+∞`、`-∞` 和 `-0`，以及如何使用 `float.IsNaN` 或 `double.IsNaN` 方法来测试一个值是否为 `NaN`.
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第五章布尔类型和运算符" class="pagebody-header">
 &lt;strong>第五章：布尔类型和运算符&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;pre>&lt;code>* 详细介绍了 `bool` 类型，它表示逻辑值 `true` 或 `false`。
* 解释了相等和比较运算符 (`==`、`!=`、`&amp;lt;`、`&amp;gt;`、`&amp;lt;=` 和 `&amp;gt;=`) 的用法，以及它们如何应用于值类型和引用类型。
* 讨论了条件运算符 (`&amp;amp;&amp;amp;`、`||` 和 `!`) 的使用，以及短路求值的概念。
* 介绍了三元条件运算符 (`? :`) 的用法。
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第六章字符串和字符" class="pagebody-header">
 &lt;strong>第六章：字符串和字符&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;pre>&lt;code>* 介绍了 `char` 类型，它表示一个 Unicode 字符。
* 讲解了转义序列，用于表示不能直接表示的字符。
* 详细介绍了 `string` 类型，它表示一个不可变的 Unicode 字符序列。
* 讨论了字符串字面值的表示方法，包括普通字符串、逐字字符串和原始字符串。
* 介绍了字符串的连接、插值和比较方法，以及如何使用 `StringBuilder` 类型进行高效的字符串操作。
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>讲解了原始字符串字面量的特殊规则，包括如何表示多行字符串，如何处理前导和尾随空格，以及如何进行插值。
* 介绍了字符串的比较，可以使用 &lt;code>CompareTo&lt;/code> 方法，以及如何搜索字符串内的字符和子字符串。
* 介绍了 UTF-8 字符串的使用方式。
* 解释了范围（Ranges）的概念，并提供了使用 &lt;code>..&lt;/code> 运算符和 &lt;code>^&lt;/code> 符号进行数组切片的例子。&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第七章变量和参数" class="pagebody-header">
 &lt;strong>第七章：变量和参数&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;pre>&lt;code>* 解释了变量的概念，以及变量在栈和堆中的存储。
* 讲解了如何使用 `ref` 修饰符通过引用传递参数，并举例说明。
* 介绍了可选参数和默认参数值，以及它们在编译时的处理方式。
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第八章表达式和运算符" class="pagebody-header">
 &lt;strong>第八章：表达式和运算符&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;pre>&lt;code>* 详细介绍了 C# 中的各种运算符，包括一元运算符、二元运算符和三元运算符。
* 列出了 C# 中运算符的优先级表，并解释了运算符的结合性。
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>详细介绍了 C# 中运算符的种类，包括 primary, unary, multiplicative, additive, shift, relational, equality, bitwise, conditional, null coalescing, conditional(ternary), assignment, and lambda operators.&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第九章空运算符" class="pagebody-header">
 &lt;strong>第九章：空运算符&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;pre>&lt;code>* 介绍了 C# 中用于处理 null 值的三个运算符：null 合并运算符 (`??`)、null 条件运算符 (`?.`) 和 null 合并赋值运算符 (`??=`)。
* 解释了 `??` 运算符的作用，即如果左侧操作数非 null，则返回左侧操作数，否则返回右侧操作数。
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>
&lt;p>解释了 &lt;code>?.&lt;/code> 运算符的作用，即如果左侧操作数是 null，则表达式返回 null，否则执行方法或成员访问。&lt;/p></description></item><item><title>C# 12 in a Nutshell</title><link>https://booslip.rpcx.io/posts/c%23-12-in-a-nutshell/</link><pubDate>Thu, 09 Jan 2025 18:56:37 +0800</pubDate><guid>https://booslip.rpcx.io/posts/c%23-12-in-a-nutshell/</guid><description>&lt;div class="component-content pagebody component">
 &lt;h2 id="第一章c-和-net-介绍" class="pagebody-header">
 &lt;strong>第一章：C# 和 .NET 介绍&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;pre>&lt;code>* C# 是一种灵活且广泛使用的编程语言。
* C# 12 是该语言的第九次主要更新。
* C# 提供了高级抽象和底层效率。
* 书中代码示例可以在 LINQPad 中以可编辑的交互式方式使用。
* **原始字符串字面量** 可以是多行的，并且允许使用 `$` 前缀进行插值。
* `u8` 后缀用于创建 UTF-8 编码的字符串字面量。
* `file` 访问修饰符限制类型仅在同一文件中访问。
* C# 11 引入了 checked 运算符和放松了结构体构造函数的要求。
* 可以将属性应用于 lambda 表达式的目标方法。
* 嵌套属性模式匹配的简化语法。
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第二章c-语言基础" class="pagebody-header">
 &lt;strong>第二章：C# 语言基础&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;pre>&lt;code>* 介绍了 C# 的基本语法，包括 **变量**、**类型**、**运算符**和**语句**。
* 讨论了 **数值类型**，**布尔类型**，**字符串**和**字符**。
* 涵盖了 **数组**，**变量**和**参数**。
* 解释了 **表达式和运算符**，包括 **null 运算符**。
* 描述了 **语句**和**命名空间**。
* C# 中使用 `//` 进行单行注释，使用 `/* ... */` 进行多行注释。
* `@` 前缀可以用来使用与保留关键字冲突的标识符。
* `=` 用于赋值，`==` 用于相等比较。
* `null` 表示引用不指向任何对象。
* C# 支持按位运算符，如 `~`, `&amp;amp;`, `|`, `^`, `&amp;lt;&amp;lt;`, `&amp;gt;&amp;gt;`, `&amp;gt;&amp;gt;&amp;gt;`。
* 浮点类型具有特殊值，如 `NaN`, `+∞`, `-∞`, 和 `-0`。
* `&amp;amp;&amp;amp;` 和 `||` 运算符用于测试 and 和 or 条件，`!` 运算符表示 not。
* `char` 类型表示 Unicode 字符，使用单引号。
* 转义序列用反斜杠 `\` 表示特殊字符。
* 可以使用 `\u` (或 `\x`) 转义序列通过四位十六进制代码指定 Unicode 字符。
* `string` 类型表示不可变的 Unicode 字符序列，使用双引号。
* 原始字符串字面量使用三引号 `&amp;quot;&amp;quot;&amp;quot;` 表示。
* 数组表示特定类型的固定数量的变量。
* C# 提供了 `??` (null 合并运算符)和 `??=` (null 合并赋值运算符) 来处理 null 值。
* `using` 语句用于调用实现了 `IDisposable` 接口的对象的 `Dispose` 方法。
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第三章创建-c-中的类型" class="pagebody-header">
 &lt;strong>第三章：创建 C# 中的类型&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;pre>&lt;code>* 讨论了类，结构体，接口，委托和泛型。
* 实例构造函数可以使用 `public`, `internal`, `private`, 和 `protected` 访问修饰符。
* 可以使用对象初始化器来实例化对象。
* 泛型类型和方法可以有多个参数。
* 泛型类型和方法名称可以重载，只要类型参数的数量不同即可。
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第四章高级-c" class="pagebody-header">
 &lt;strong>第四章：高级 C#&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;pre>&lt;code>* 深入探讨了 **委托**，**事件**，**lambda表达式**和**异常处理**。
* 解释了 **使用声明** 和 **throw 表达式**。
* 涵盖了 **try 语句**和**异常**。
* 讨论了 **可空值类型** 和 **null 运算符**。
* C# 9 开始可以使用 `and`, `or`, 和 `not` 关键字组合模式。
* `var` 模式允许重用变量。
* 运算符可以重载。
* `true` 和 `false` 运算符可以重载，例如 `SqlBoolean` 结构体。
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第五章net-概述" class="pagebody-header">
 &lt;strong>第五章：.NET 概述&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;pre>&lt;code>* 介绍了 .NET 框架和 CLR 的概念。
* 讨论了 **运行时目标和 TFM** (目标框架标识符)。
* 概述了 **.NET 的各种功能**，如 **文本处理**，**网络**，**并发**。
* 讨论了应用程序层，包括 **瘦客户端**和**富客户端**。
* 涵盖了 **Windows 桌面** UI API，如 WPF 和 Windows Forms。
* 介绍了 **Roslyn 编译器**。
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第六章net-基础" class="pagebody-header">
 &lt;strong>第六章：.NET 基础&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;pre>&lt;code>* 详细介绍了 **字符串** 和 **文本处理**，包括 **字符串的构造**，**插值字符串**，**文本编码**和 **Unicode**。
* 讨论了 **日期和时间** 的表示，包括 `DateTime` 和 `DateTimeOffset` 结构体。
* 描述了 **标准格式字符串** 和 **解析标志**。
* 解释了 **数学运算**，如 **舍入**，**最大值/最小值**，**平方根**，**对数**和**三角函数**。
* 讨论了 **随机数生成**。
* 涵盖了 **相等性协议** 和 **比较协议**，包括 `==` 和 `!=` 运算符， `Equals` 方法和 `IComparable` 接口。
* 介绍了 **实用工具类**，如 `Console`，`Environment` 和 `Process`。
* 讨论了 **集合** 的相关知识，如 `SortedSet&amp;lt;T&amp;gt;`。
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第七章linq" class="pagebody-header">
 &lt;strong>第七章：LINQ&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;pre>&lt;code>* 介绍了 LINQ (语言集成查询) 的架构和基本概念。
* **LINQ 的基本数据单元是序列和元素**。
* **查询运算符的转换构成了 “装饰”**。
* `Where` 方法构建一个装饰器包装器序列。
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第八章linq-运算符" class="pagebody-header">
 &lt;strong>第八章：LINQ 运算符&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;pre>&lt;code>* 深入探讨了 LINQ 的各种运算符，例如 **选择**，**过滤**，**排序**和**分组**。
* 介绍了 **元素运算符**，例如 `MinBy`，`MaxBy` 和 `DefaultIfEmpty`。
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第九章linq-to-xml" class="pagebody-header">
 &lt;strong>第九章：LINQ to XML&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;pre>&lt;code>* 介绍了 **LINQ to XML** 的 API。
* 讨论了 **XNode**, **XElement**, **XDocument** 和 **XAttribute** 等 XML 类型的类和概念。
* 解释了如何使用 `XDeclaration` 来设置 XML 文档的编码和其他属性。
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第十章其他-xml-和-json-技术" class="pagebody-header">
 &lt;strong>第十章：其他 XML 和 JSON 技术&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;pre>&lt;code>* 介绍了低级的 `XmlReader`/`XmlWriter` 类。
* 提及了使用 JSON (JavaScript 对象表示法) 的类型，它是 XML 的流行替代品。
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第十一章动态编程" class="pagebody-header">
 &lt;strong>第十一章：动态编程&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;pre>&lt;code>* 涵盖了代码生成的相关知识
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第十二章垃圾回收" class="pagebody-header">
 &lt;strong>第十二章：垃圾回收&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;pre>&lt;code>* 讨论了垃圾回收和 `IDisposable` 接口。
* 介绍了 **终结器** 的概念，并讨论了 **复活** 的问题。
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第十三章诊断" class="pagebody-header">
 &lt;strong>第十三章：诊断&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;pre>&lt;code> * 讨论了预处理器指令，例如 `#if`, `#else`, 和 `#endif`。
 * 介绍了如何使用 **Windows 事件日志**。
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第十四章并发和异步" class="pagebody-header">
 &lt;strong>第十四章：并发和异步&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;pre>&lt;code>* 讨论了 **线程** 的概念，以及如何使用 **多线程**。
* 介绍了 **异步模式**，例如 **EAP** (基于事件的异步模式) 和 **BackgroundWorker**。
* 涵盖了 **取消** 和 **超时**。
* `TrySetResult`，`TrySetException` 和 `TrySetCanceled` 方法用于发出任务完成信号。
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第十五章流和-io" class="pagebody-header">
 &lt;strong>第十五章：流和 I/O&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;pre>&lt;code>* 介绍了流的架构，包括 **后备存储**，**装饰器** 和 **适配器**。
* 描述了各种类型的 **流**，例如 `FileStream`，`MemoryStream` 和 `BufferedStream`。
* 讨论了 **命名管道** 和 **匿名管道**。
* 介绍了 **文本适配器**，如 `StreamReader` 和 `StreamWriter`。
* 解释了 **文本编码**，包括 ASCII 和 UTF-8。
* 描述了 **二进制适配器**，如 `BinaryReader` 和 `BinaryWriter`。
* 介绍了 **压缩流**，如 `DeflateStream` 和 `BrotliStream`。
* 讨论了 **文件和目录操作**，包括 `File`, `Directory` 和 `Path` 类。
* 介绍了 **操作系统的安全性** 和用户帐户控制 (UAC)。
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第十六章网络" class="pagebody-header">
 &lt;strong>第十六章：网络&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;pre>&lt;code>* 讨论了网络架构，包括 **应用层**和 **传输层**。
* 介绍了 **URI** (统一资源标识符)。
* 描述了如何使用 `HttpClient` 发送 HTTP 请求。
* 解释了如何使用 `HttpListener` 构建 HTTP 服务器。
* 涵盖了如何使用 `SmtpClient` 发送电子邮件。
* 介绍了如何使用 TCP 进行通信，包括 `TcpClient`，`TcpListener` 和 `Socket` 类。
* 讨论了如何使用 TCP 接收 POP3 邮件。
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第十七章程序集" class="pagebody-header">
 &lt;strong>第十七章：程序集&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>讨论了 &lt;strong>程序集&lt;/strong> 的相关概念，如 .exe 文件，程序集清单，以及如何使用 .NET 程序集&lt;/li>
&lt;li>&lt;strong>第十八章：本地化&lt;/strong>
&lt;ul>
&lt;li>讨论了 &lt;strong>本地化&lt;/strong> 的相关概念，并介绍了如何使用 .NET 实现&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第十九章动态编程" class="pagebody-header">
 &lt;strong>第十九章：动态编程&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;pre>&lt;code>* 讨论了动态程序集和类型生成。
* 介绍了如何使用反射来动态访问类型和方法。
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第二十章密码学" class="pagebody-header">
 &lt;strong>第二十章：密码学&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;pre>&lt;code>* 介绍了 **Windows 数据保护 API (DPAPI)**。
* 讨论了 **哈希** 算法，如 SHA1 和 SHA256，并介绍了 **哈希密码** 的方法。
* 介绍了 **对称加密** 算法，如 Rijndael 和 AES。
* 涵盖了 **公钥加密** 和 **签名**，包括 RSA 算法。
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第二十一章高级线程" class="pagebody-header">
 &lt;strong>第二十一章：高级线程&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;pre>&lt;code>* 讨论了 **独占锁定** 构造，如 `lock` 语句，`Mutex` 和 `SpinLock`。
* 介绍了 **非独占锁定** 构造，如 `Semaphore` 和 `ReaderWriterLockSlim`。
* 涵盖了 **事件等待句柄**，如 `AutoResetEvent` 和 `ManualResetEvent`。
* 讨论了 **Barrier 类**，用于实现线程执行屏障。
* 介绍了 **定时器**，包括 `System.Threading.Timer` 和 `PeriodicTimer`。
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第二十二章任务" class="pagebody-header">
 &lt;strong>第二十二章：任务&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;pre>&lt;code> * 介绍了 **任务** 的相关知识，包括 `Task` 类 和 `TaskCreationOptions`。
 * 介绍了任务的延续，包括 `ContinueWith` 方法和各种 `NotOn*` 标志
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第二十三章spant-和-memoryt" class="pagebody-header">
 &lt;strong>第二十三章：Span&lt;!-- raw HTML omitted --> 和 Memory&lt;!-- raw HTML omitted -->&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;pre>&lt;code>* 介绍了 `Span&amp;lt;T&amp;gt;` 和 `Memory&amp;lt;T&amp;gt;` 的概念，以及它们与数组的不同。
* 讨论了如何使用 `Span&amp;lt;T&amp;gt;` 进行 **切片** 和 **性能优化**。
* 介绍了 `Utf8Formatter` 和 `Utf8Parser` 类，用于格式化和解析 UTF-8 数据。
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第二十四章不安全代码" class="pagebody-header">
 &lt;strong>第二十四章：不安全代码&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;pre>&lt;code>* 介绍了如何使用 **指针** 和 **不安全代码** 来提高性能
* 介绍了如何使用 **P/Invoke** 调用外部方法
&lt;/code>&lt;/pre></description></item><item><title>Head First Software Architecture</title><link>https://booslip.rpcx.io/posts/head-first-software-architecture/</link><pubDate>Thu, 09 Jan 2025 18:38:26 +0800</pubDate><guid>https://booslip.rpcx.io/posts/head-first-software-architecture/</guid><description>&lt;p>好的，我将根据提供的资料，按照章节总结知识点，并用中文回复，力求做到信、雅、达。&lt;/p>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第一章软件架构概述" class="pagebody-header">
 &lt;strong>第一章：软件架构概述&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>软件架构学习的挑战&lt;/strong>: 大脑会倾向于认为软件架构不重要，而将注意力放在其他事情上。但可以通过技巧让大脑意识到软件架构的重要性。&lt;/li>
&lt;li>&lt;strong>软件架构的核心&lt;/strong>: &lt;strong>架构特性（Architectural Characteristics）&lt;/strong> 是任何系统的基本构建模块。没有它们，就无法进行架构决策，选择架构风格，甚至无法创建逻辑架构。&lt;/li>
&lt;li>&lt;strong>软件架构的本质&lt;/strong>: 软件架构没有最佳实践，需要仔细分析每种情况并做出决策。&lt;/li>
&lt;li>&lt;strong>类比&lt;/strong>: 可以通过房屋或花园的类比来理解软件架构。&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第二章架构特性" class="pagebody-header">
 &lt;strong>第二章：架构特性&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>架构特性的定义&lt;/strong>: 架构特性是架构的基石，决定了系统需要支持什么。它们也被称为非功能性需求、系统质量属性或 &amp;ldquo;-ilities&amp;rdquo;。&lt;/li>
&lt;li>&lt;strong>架构特性的重要性&lt;/strong>: 它们有助于做出架构决策和分析重要的权衡。&lt;/li>
&lt;li>&lt;strong>常见的架构特性&lt;/strong>: 例如可伸缩性（scalability）、可靠性（reliability）和可测试性（testability）等。&lt;/li>
&lt;li>&lt;strong>显式与隐式特性&lt;/strong>: 显式特性在需求中明确指出，而隐式特性则影响架构决策，但未明确列出，如安全性。&lt;/li>
&lt;li>&lt;strong>复合特性&lt;/strong>: 多个特性组合成新的特性，如敏捷性（agility），它包括可测试性、可部署性和模块化等。&lt;/li>
&lt;li>&lt;strong>优先级&lt;/strong>: 需要根据上下文确定架构特性的优先级，并且优化一个特性可能会牺牲另一个特性。&lt;/li>
&lt;li>&lt;strong>没有标准列表&lt;/strong>: 架构特性的列表并非固定不变，会随着软件开发生态的变化而变化。&lt;/li>
&lt;li>&lt;strong>架构特性与逻辑组件&lt;/strong>: 架构特性和逻辑组件共同决定了架构风格。&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第三章权衡与决策" class="pagebody-header">
 &lt;strong>第三章：权衡与决策&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>软件架构的第一定律&lt;/strong>：&lt;strong>一切皆权衡&lt;/strong>。每个决策都包含权衡，没有无代价的决策。&lt;/li>
&lt;li>&lt;strong>战略与战术决策&lt;/strong>: 战略决策更具架构性，需要更多思考和规划，通常是长期的。&lt;/li>
&lt;li>&lt;strong>架构与设计的区别&lt;/strong>：架构决策具有显著的权衡，更具战略性，而设计决策则更偏向实现细节。&lt;/li>
&lt;li>&lt;strong>权衡分析&lt;/strong>：包括找出特定方法的好处和坏处，以获得完整的信息。&lt;/li>
&lt;li>&lt;strong>ADR (Architecture Decision Record)&lt;/strong>: 用于记录架构决策，包括标题、状态、上下文、决策和后果。
&lt;ul>
&lt;li>&lt;strong>ADR 的状态&lt;/strong>: 包括 RFC（征求意见）、Proposed（提议中）、Accepted（已接受）和 Superseded（已取代）。&lt;/li>
&lt;li>&lt;strong>ADR 的内容&lt;/strong>: 包括上下文（决策的环境和约束）、决策（具体要做出的选择）和后果（决策带来的影响）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>异步与同步通信的权衡&lt;/strong>: 异步通信可以提高响应速度和可用性，而同步通信则更易于管理事务和错误。&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第四章逻辑组件" class="pagebody-header">
 &lt;strong>第四章：逻辑组件&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>逻辑组件的定义&lt;/strong>: 逻辑组件是系统的构建模块，执行特定的功能。&lt;/li>
&lt;li>&lt;strong>逻辑组件的表示&lt;/strong>: 通常通过目录或命名空间来表示。&lt;/li>
&lt;li>&lt;strong>逻辑组件的特性&lt;/strong>: 每个逻辑组件都应该在系统中具有明确的角色和责任。&lt;/li>
&lt;li>&lt;strong>识别逻辑组件的方法&lt;/strong>：
&lt;ul>
&lt;li>&lt;strong>工作流方法&lt;/strong>: 根据工作流程的步骤来识别组件。&lt;/li>
&lt;li>&lt;strong>参与者/动作方法&lt;/strong>: 根据系统中参与者的动作来识别组件。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>避免实体陷阱&lt;/strong>: 命名组件时避免使用 &amp;ldquo;manager&amp;rdquo; 或 &amp;ldquo;supervisor&amp;rdquo; 等词语。&lt;/li>
&lt;li>&lt;strong>组件耦合&lt;/strong>:
&lt;ul>
&lt;li>&lt;strong>传入耦合 (Afferent Coupling, CA)&lt;/strong>: 依赖于当前组件的其他组件的数量。&lt;/li>
&lt;li>&lt;strong>传出耦合 (Efferent Coupling, CE)&lt;/strong>: 当前组件依赖的其他组件的数量。&lt;/li>
&lt;li>&lt;strong>总耦合 (Total Coupling, CT)&lt;/strong>: 传入耦合和传出耦合的总和。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>耦合的重要性&lt;/strong>: 松耦合可以降低组件之间的依赖性，但也会带来权衡。&lt;/li>
&lt;li>&lt;strong>逻辑组件的组织&lt;/strong>: 逻辑组件通常与源代码目录结构对应。&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第五章架构风格" class="pagebody-header">
 &lt;strong>第五章：架构风格&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>架构风格的分类&lt;/strong>: 可以根据代码的划分方式（技术关注点或领域关注点）以及部署方式（单体或分布式）进行分类。&lt;/li>
&lt;li>&lt;strong>单体架构&lt;/strong>: 将所有逻辑组件部署为一个单元。&lt;/li>
&lt;li>&lt;strong>分布式架构&lt;/strong>: 将逻辑组件分散到多个单元中。&lt;/li>
&lt;li>&lt;strong>架构风格的选择&lt;/strong>: 需要考虑多种因素，包括问题的复杂性和时间紧迫性。&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第六章分层架构" class="pagebody-header">
 &lt;strong>第六章：分层架构&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>分层架构的特点&lt;/strong>: 按照技术关注点将系统划分为不同的层，例如表示层、业务规则层和持久层。&lt;/li>
&lt;li>&lt;strong>层与组件的关系&lt;/strong>: 领域组件通常会跨越多个物理层。&lt;/li>
&lt;li>&lt;strong>分层架构的优缺点&lt;/strong>: 简单易懂，但可能难以适应领域变化。&lt;/li>
&lt;li>&lt;strong>适用场景&lt;/strong>: 适合简单且不需要频繁更改的系统。&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第七章模块化单体架构" class="pagebody-header">
 &lt;strong>第七章：模块化单体架构&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>模块化单体架构的特点&lt;/strong>: 在单体架构的基础上，按照业务领域对系统进行划分，形成多个模块。&lt;/li>
&lt;li>&lt;strong>模块化的优势&lt;/strong>: 提高可维护性、可测试性和可部署性，降低变更风险。&lt;/li>
&lt;li>&lt;strong>模块间的通信&lt;/strong>: 通过模块的 API 进行间接通信。&lt;/li>
&lt;li>&lt;strong>模块化与分层&lt;/strong>: 模块化单体架构可以包含分层架构，并且每个模块可以有自己的层。&lt;/li>
&lt;li>&lt;strong>数据模式&lt;/strong>: 每个模块都有自己的数据模式.&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第八章微内核架构" class="pagebody-header">
 &lt;strong>第八章：微内核架构&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>微内核架构的特点&lt;/strong>: 将系统分为一个核心部分（core）和多个插件（plugin）。&lt;/li>
&lt;li>&lt;strong>核心的功能&lt;/strong>: 核心提供最基本的功能，插件负责扩展和定制功能。&lt;/li>
&lt;li>&lt;strong>插件的类型&lt;/strong>: 可以是单体或分布式的。&lt;/li>
&lt;li>&lt;strong>微内核的“微内核性”&lt;/strong>: 取决于核心在没有插件的情况下有多大的功能以及核心的易变性。&lt;/li>
&lt;li>&lt;strong>适用场景&lt;/strong>: 适用于需要高度定制和扩展的系统，例如 IDE 和电子回收系统。&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第九章架构实践" class="pagebody-header">
 &lt;strong>第九章：架构实践&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>综合运用&lt;/strong>: 本章通过 TripEZ 旅行应用程序，综合运用了之前章节的知识，包括架构特性、逻辑组件和架构风格，来构建一个完整的架构。&lt;/li>
&lt;li>&lt;strong>架构决策过程&lt;/strong>: 包括确定架构特性、构建逻辑架构、做出架构决策和选择架构风格。&lt;/li>
&lt;li>&lt;strong>没有正确答案&lt;/strong>: 软件架构没有绝对的正确答案，重点在于分析权衡并为决策提供合理依据。&lt;/li>
&lt;li>&lt;strong>多种可能的解决方案&lt;/strong>: 对于同一个问题，可以有多种可行的架构解决方案。&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第十章微服务架构" class="pagebody-header">
 &lt;strong>第十章：微服务架构&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>微服务架构的特点&lt;/strong>: 将应用程序分解为一组小的、独立部署的服务。&lt;/li>
&lt;li>&lt;strong>服务粒度&lt;/strong>: 微服务不宜过大或过小，需要找到合适的粒度。&lt;/li>
&lt;li>&lt;strong>数据所有权&lt;/strong>: 每个微服务拥有自己的数据。&lt;/li>
&lt;li>&lt;strong>共享功能&lt;/strong>: 可以使用共享服务或共享库来实现。&lt;/li>
&lt;li>&lt;strong>工作流管理&lt;/strong>: 可以通过编排（Orchestration）或协作（Choreography）来管理。
&lt;ul>
&lt;li>&lt;strong>编排&lt;/strong>: 由一个中心服务来协调其他微服务的调用。&lt;/li>
&lt;li>&lt;strong>协作&lt;/strong>: 微服务之间通过事件进行通信，无需中央协调者。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第十一章事件驱动架构" class="pagebody-header">
 &lt;strong>第十一章：事件驱动架构&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>事件驱动架构的特点&lt;/strong>: 通过事件进行异步通信，将处理分解为独立的服务。&lt;/li>
&lt;li>&lt;strong>事件的定义&lt;/strong>: 已发生的事情，通常用过去式表示。&lt;/li>
&lt;li>&lt;strong>消息与事件&lt;/strong>: 消息是命令，而事件是通知。&lt;/li>
&lt;li>&lt;strong>异步通信&lt;/strong>: 服务发送事件后无需等待响应，提高了系统的响应速度和可用性。&lt;/li>
&lt;li>&lt;strong>同步通信&lt;/strong>: 发送服务必须等待接收服务响应。&lt;/li>
&lt;li>&lt;strong>数据耦合&lt;/strong>: 在事件驱动架构中，数据可能会形成耦合点。&lt;/li>
&lt;li>&lt;strong>数据拓扑&lt;/strong>: 数据库可以是单体也可以是服务专有的。&lt;/li>
&lt;li>&lt;strong>事件驱动架构的优缺点&lt;/strong>: 具有高弹性、高可用性，但也更复杂。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>附录：其他&lt;/strong>&lt;/p></description></item><item><title>Network Programming With Go</title><link>https://booslip.rpcx.io/posts/network-programming-with-go/</link><pubDate>Thu, 09 Jan 2025 18:27:45 +0800</pubDate><guid>https://booslip.rpcx.io/posts/network-programming-with-go/</guid><description>&lt;div class="component-content pagebody component">
 &lt;h2 id="第一部分网络架构" class="pagebody-header">
 &lt;strong>第一部分：网络架构&lt;/strong>
 &lt;/h2>
&lt;/div>
&lt;div class="component-content pagebody component">
 &lt;h3 id="---第一章网络基础" class="pagebody-header">
 * &lt;strong>第一章：网络基础&lt;/strong>
 &lt;/h3>
&lt;/div>&lt;pre>&lt;code>* 网络拓扑结构：
 * 点对点连接
 * 菊花链
 * 总线型拓扑 (常见于无线网络)
 * 环形拓扑 (数据单向流动，速度受限于最慢节点)
 * 星型拓扑
 * 网状拓扑
 * 混合拓扑 (例如星型-环形、星型-总线)
* **OSI 参考模型**的分层结构
* **TCP/IP 模型**的分层结构：应用层、传输层、网络层（互联网层）、链路层
* 数据封装
* 单播、组播和广播：
 * **单播**：一对一通信
 * **组播**：将消息发送到一组节点，类似于订阅列表
 * **广播**：将消息发送到网络上的所有节点（IPv4）
 * **任播**：将消息发送到监听同一地址的最近节点 (IPv6)
* Go 标准库和生态系统适合编写安全可靠的网络应用
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h3 id="---第二章ip寻址" class="pagebody-header">
 * &lt;strong>第二章：IP寻址&lt;/strong>
 &lt;/h3>
&lt;/div>&lt;pre>&lt;code>* IPv4 地址的结构：主机 ID 和网络 ID
* IPv4 地址的子网划分
* IPv4 的私有地址范围
* IPv6 地址的结构：
 * 全球路由前缀 (GRP)
 * 子网 ID
 * 接口 ID
 * 链路本地地址
* IPv6 的任播地址
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第二部分套接字级编程" class="pagebody-header">
 &lt;strong>第二部分：套接字级编程&lt;/strong>
 &lt;/h2>
&lt;/div>
&lt;div class="component-content pagebody component">
 &lt;h3 id="---第三章tcp协议" class="pagebody-header">
 * &lt;strong>第三章：TCP协议&lt;/strong>
 &lt;/h3>
&lt;/div>&lt;pre>&lt;code>* TCP 三次握手过程：SYN，SYN/ACK，ACK
* 使用 Go 的 `net` 包创建 TCP 服务器和客户端
* 监听 (net.Listen) 和接受连接 (net.Accept)
* **绑定 (binding)**：操作系统独占分配端口
* 客户端拨号连接 (net.Dial)
* 优雅地关闭连接
* 使用 `net.Error` 类型来检查临时错误
* 使用 `net.OpError` 获取更多错误信息
* 使用 `context` 包进行超时和取消操作
* **处理临时错误和超时**
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h3 id="---第四章发送tcp数据" class="pagebody-header">
 * &lt;strong>第四章：发送TCP数据&lt;/strong>
 &lt;/h3>
&lt;/div>&lt;pre>&lt;code>* `net.Conn` 接口实现了 `io.ReadWriteCloser` 接口
* 从固定大小的缓冲区读取数据
* 使用 `bufio.Scanner` 按分隔符读取数据
* **TLV (Type-Length-Value) 编码**：一种动态分配缓冲区大小的方法
* 处理读取和写入数据时的错误
* **使用 `io.Copy` 在连接之间代理数据**
* 使用 `io.TeeReader` 和 `io.MultiWriter` 监控网络连接
* `TCPConn` 对象：控制 Keepalive 消息、处理关闭时的挂起数据、覆盖默认的发送和接收缓冲区
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h3 id="---第五章不可靠的udp通信" class="pagebody-header">
 * &lt;strong>第五章：不可靠的UDP通信&lt;/strong>
 &lt;/h3>
&lt;/div>&lt;pre>&lt;code>* UDP 协议的特点：无连接，不可靠
* UDP 数据包的结构：源端口、目标端口、数据包长度、校验和、有效负载
* 使用 `net.ListenPacket` 创建 UDP 连接
* 使用`ReadFrom` 和 `WriteTo` 发送和接收UDP数据包
* **一个 UDP 连接对象可以接收来自多个发送者的数据包**
* `net.Conn` 用于管理 UDP 通信时，只从 `net.Dial` 指定的地址读取数据
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h3 id="---第六章确保udp可靠性" class="pagebody-header">
 * &lt;strong>第六章：确保UDP可靠性&lt;/strong>
 &lt;/h3>
&lt;/div>&lt;pre>&lt;code>* TFTP (Trivial File Transfer Protocol) 协议用于可靠的文件传输
* TFTP 数据包类型：读取请求、数据包、确认包、错误包
* **使用`encoding.BinaryMarshaler` 和 `encoding.BinaryUnmarshaler` 进行二进制数据的序列化和反序列化**
* 数据包重传和超时
* 避免分片
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h3 id="---第七章unix-域套接字" class="pagebody-header">
 * &lt;strong>第七章：Unix 域套接字&lt;/strong>
 &lt;/h3>
&lt;/div>&lt;pre>&lt;code>* Unix 域套接字的三种类型：`unix` (流式)、`unixgram` (数据报式)、`unixpacket` (会话式)
* 控制 Unix 域套接字的读写权限
* 使用 `net.Listen` 创建 `unix` 套接字服务器
* 使用 `net.ListenPacket` 创建 `unixgram` 套接字服务器
* 使用 `net.Dial` 创建 `unixpacket` 套接字客户端
* 使用 `os.Chmod` 设置套接字文件权限
* 使用 `net.AcceptUnix` 获取 `net.UnixConn` 对象
* 基于用户和组 ID 验证客户端
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第三部分应用级编程" class="pagebody-header">
 &lt;strong>第三部分：应用级编程&lt;/strong>
 &lt;/h2>
&lt;/div>
&lt;div class="component-content pagebody component">
 &lt;h3 id="---第八章http客户端" class="pagebody-header">
 * &lt;strong>第八章：HTTP客户端&lt;/strong>
 &lt;/h3>
&lt;/div>&lt;pre>&lt;code>* HTTP 协议：客户端发送 URL，服务器返回资源
* **HTTP 请求**：方法（GET, POST等）、URL、头部、主体 
* **HTTP 响应**：状态码、头部、主体 
* 使用 `net/http` 包创建 HTTP 客户端 
* 设置请求头
* 使用 `multipart/form-data` 上传文件
* `http.NewRequestWithContext` 函数
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h3 id="---第九章构建http服务" class="pagebody-header">
 * &lt;strong>第九章：构建HTTP服务&lt;/strong>
 &lt;/h3>
&lt;/div>&lt;pre>&lt;code>* Go HTTP 服务器的组成部分：多路复用器、中间件、处理器
* `http.ServeMux`：请求多路复用器
* **中间件**：在处理器之前或之后执行的函数，用于身份验证、日志记录等
* `http.Handler` 接口
* `http.HandlerFunc` 类型，简化处理器的定义 
* `http.ResponseWriter`：用于写响应
* `http.Request`：请求对象
* 处理客户端输入时需要进行转义
* 提供静态文件服务 
* 使用 `http.TimeoutHandler` 设置超时
* `Methods`处理器
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>&lt;code>html/template&lt;/code> 包用于HTML转义&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h3 id="---第十章caddy一个现代的web服务器" class="pagebody-header">
 * &lt;strong>第十章：Caddy：一个现代的Web服务器&lt;/strong>
 &lt;/h3>
&lt;/div>&lt;pre>&lt;code>* Caddy 的特性：自动 HTTPS、配置简单
* Caddy 的配置方法：JSON 文件
* **Caddy 的配置适配器**：将 TOML 等格式转换为 Caddy 的原生 JSON 格式
* **Caddy 的中间件**：实现 `caddyhttp.MiddlewareHandler` 接口
* 实现自定义中间件
* 使用 Caddy 作为反向代理
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h3 id="---第十一章tls" class="pagebody-header">
 * &lt;strong>第十一章：TLS&lt;/strong>
 &lt;/h3>
&lt;/div>&lt;pre>&lt;code>* TLS (Transport Layer Security) 协议：用于加密网络通信
* 使用 `crypto/tls` 包创建 TLS 连接
* **TLS 配置**：证书、密钥、协议版本、密码套件
* 客户端身份验证：**双向 TLS**
* 使用 `crypto/x509` 包加载和解析证书
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h3 id="---第十二章命令行工具" class="pagebody-header">
 * &lt;strong>第十二章：命令行工具&lt;/strong>
 &lt;/h3>
&lt;/div>&lt;pre>&lt;code>* 使用 `flag` 包解析命令行参数
* 使用 `os` 包读取和写入文件
* **Protocol Buffer** (protobuf)：用于序列化结构化数据
* **gRPC**：使用 protobuf 的远程过程调用框架
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h3 id="---第十三章可观察性" class="pagebody-header">
 * &lt;strong>第十三章：可观察性&lt;/strong>
 &lt;/h3>
&lt;/div>&lt;pre>&lt;code>* **日志记录**：使用 `log` 包
* 使用 `io.MultiWriter` 将日志写入多个目标
* **结构化日志**：使用 `go.uber.org/zap` 包
 * Zap 的编码器配置和使用
 * Zap 的日志轮换
* **度量**：使用 `github.com/go-kit/kit/metrics` 包
* 使用中间件进行广泛的事件日志记录
* 使用 `net/http` 的 `ConnState` 字段来监控连接状态
&lt;/code>&lt;/pre>

&lt;div class="component-content pagebody component">
 &lt;h3 id="---第十四章云" class="pagebody-header">
 * &lt;strong>第十四章：云&lt;/strong>
 &lt;/h3>
&lt;/div>&lt;pre>&lt;code>* 在云上部署 Go 应用
* **AWS Lambda**：无服务器计算平台
* 使用 `github.com/aws/aws-lambda-go/lambda` 包
* 从 RSS feed 获取数据
&lt;/code>&lt;/pre></description></item><item><title>.NET in Action 第二版</title><link>https://booslip.rpcx.io/posts/dotnet-in-action-2rd/</link><pubDate>Thu, 09 Jan 2025 18:14:18 +0800</pubDate><guid>https://booslip.rpcx.io/posts/dotnet-in-action-2rd/</guid><description>&lt;p>这本书涵盖了 .NET 开发的各个方面，从基础语法、数据处理、Web 开发到测试、安全、性能和部署。通过学习这本书，可以全面掌握 .NET 开发技能，构建高质量的应用程序。&lt;/p></description></item><item><title>GRPC Microservices in Go</title><link>https://booslip.rpcx.io/posts/grpc-microservices-in-go/</link><pubDate>Thu, 09 Jan 2025 18:05:12 +0800</pubDate><guid>https://booslip.rpcx.io/posts/grpc-microservices-in-go/</guid><description>&lt;div class="component-content pagebody component">
 &lt;h2 id="第一章go-grpc-微服务简介" class="pagebody-header">
 &lt;strong>第一章：Go gRPC 微服务简介&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>gRPC 的跨平台和多语言兼容性&lt;/strong>：gRPC 工具和库与多种平台和语言兼容，包括 Go、Java、Python、Ruby、JavaScript 和 C# 等。Protobuf 二进制线格式和代码生成功能使开发者能够构建高性能的跨平台应用程序。&lt;/li>
&lt;li>&lt;strong>gRPC 的优势&lt;/strong>：gRPC 越来越受欢迎，因为它能够快速生成客户端存根，为不同语言的服务提供 SDK。开发者只需定义业务对象和方法，gRPC 就可以生成特定语言的实现，使得服务器端和客户端可以使用不同的开发语言进行通信。&lt;/li>
&lt;li>&lt;strong>容错能力&lt;/strong>：容错是指系统在发生故障时仍能继续运行的能力。&lt;strong>幂等操作是实现容错环境的关键&lt;/strong>，因为它可以确保即使多次调用同一操作，资源的状态也不会发生改变。此外，容错还包括限流、熔断和故障注入等主题，这些将在第六章详细介绍。&lt;/li>
&lt;li>&lt;strong>多语言开发环境&lt;/strong>：gRPC 非常适合多语言开发环境，因为可以使用 Python 客户端访问用 Java 编写的 Payment 服务，客户端存根生成非常方便。&lt;/li>
&lt;li>&lt;strong>微服务验证机制&lt;/strong>：当服务定义发生更改时，客户端的测试会失败，这是一种用于验证微服务的有效机制。&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第二章grpc-与微服务" class="pagebody-header">
 &lt;strong>第二章：gRPC 与微服务&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>微服务架构的优势&lt;/strong>：单体架构在产品开发的初期阶段很有帮助，但在评估产品的可扩展性、开发和部署问题后，以及熟悉业务能力和服务上下文后，切换到微服务架构是一种最佳实践。&lt;/li>
&lt;li>&lt;strong>扩展立方体（Scale Cube）&lt;/strong>：扩展立方体是一个三维可扩展模型，包括 X 轴扩展（运行多个相同应用副本）、Y 轴扩展（根据功能分解服务）和 Z 轴扩展（根据请求属性路由请求）。&lt;/li>
&lt;li>&lt;strong>异步通信&lt;/strong>：发布/订阅（Pub/Sub）或命令通道机制是异步通信的示例，而请求/响应风格（如 gRPC）是同步通信的示例。&lt;/li>
&lt;li>&lt;strong>Saga 模式&lt;/strong>：基于编排（Choreography）和协调器（Orchestrator）的 Saga 模式提供了分布式环境中的数据一致性。&lt;/li>
&lt;li>&lt;strong>gRPC 的应用&lt;/strong>：gRPC 是一种现代、轻量级的通信协议，也是一个高性能的 RPC 框架，它通过协议缓冲区高效地连接微服务环境中的服务，并内置支持负载均衡、跟踪、健康检查和身份验证。&lt;/li>
&lt;li>&lt;strong>.proto 文件&lt;/strong>：使用 Protocol Buffers 定义消息和服务函数，并通过协议缓冲区编译器（protoc）生成服务器和客户端存根。&lt;/li>
&lt;li>&lt;strong>gRPC 的工作流程&lt;/strong>：定义 .proto 文件，生成客户端和服务器存根，实现服务器端和客户端的业务逻辑，最后运行服务和客户端。&lt;/li>
&lt;li>&lt;strong>流式处理&lt;/strong>：gRPC 支持客户端和服务器端的流式处理，允许客户端连续发送请求，服务器可以返回一个对象流。&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第三章开始使用-grpc-和-golang" class="pagebody-header">
 &lt;strong>第三章：开始使用 gRPC 和 Golang&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>Protocol Buffers&lt;/strong>：Protocol Buffers 允许序列化结构化数据以便通过网络传输，并定义服务函数以生成特定语言的源代码。&lt;/li>
&lt;li>&lt;strong>.proto 文件&lt;/strong>：.proto 文件是配置文件的形式，包含消息和服务函数的定义，也包含协议的版本信息（例如 proto3）。&lt;/li>
&lt;li>&lt;strong>消息类型定义&lt;/strong>：消息字段可以是单数（最多一个）、重复（多个值，包括零）或者保留的。字段类型可以是标量类型（如字符串和整数）、枚举或其他嵌入消息类型。&lt;/li>
&lt;li>&lt;strong>消息编码&lt;/strong>：协议缓冲区将消息转换为二进制格式进行传输，包括元数据部分和数据部分。&lt;/li>
&lt;li>&lt;strong>生成存根&lt;/strong>：protoc 工具可以接受多种参数来生成特定语言的源代码。&lt;/li>
&lt;li>&lt;strong>维护 .proto 文件&lt;/strong>：维护 .proto 文件需要考虑版本控制和向后/向前兼容性，通常会将 .proto 文件保存在单独的仓库中。&lt;/li>
&lt;li>&lt;strong>在 CI/CD 管道中添加存根生成过程&lt;/strong>：使用 GitHub Actions 可以自动化存根的生成过程。&lt;/li>
&lt;li>&lt;strong>Go 代码生成&lt;/strong>：使用 protoc 生成 Go 源代码，包括 go_package 选项和源代码相对路径。&lt;/li>
&lt;li>&lt;strong>消息和服务的定义&lt;/strong>: 了解如何在 .proto 文件中定义消息（message）类型，包括字段规则、字段类型以及保留字段。同时，也包含了服务（service）的定义，以及如何使用 rpc 调用定义服务函数。&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第四章微服务项目设置" class="pagebody-header">
 &lt;strong>第四章：微服务项目设置&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>六边形架构&lt;/strong>：六边形架构通过端口允许外部参与者使用、实现和编排业务逻辑。&lt;/li>
&lt;li>&lt;strong>项目文件夹&lt;/strong>：一个典型的 Go 项目包含以下文件夹：application（包含业务逻辑），cmd（包含入口点），config（包含配置），internal/adapters（包含适配器），internal/ports（包含端口），以及 domain （包含核心业务实体）。&lt;/li>
&lt;li>&lt;strong>应用核心的实现&lt;/strong>：应用核心是业务逻辑的组合，包括领域模型和 API，外层依赖于内层，这使得先实现应用核心，再实现外层依赖变得更容易。&lt;/li>
&lt;li>&lt;strong>端口和适配器&lt;/strong>：端口是定义应用核心与外部世界交互的接口，适配器是端口的具体实现。&lt;/li>
&lt;li>&lt;strong>依赖注入&lt;/strong>：通过依赖注入来组合端口和适配器，然后运行应用。&lt;/li>
&lt;li>&lt;strong>配置管理&lt;/strong>：使用环境变量来分离生产和非生产环境，并读取数据库连接 URL 和应用端口。&lt;/li>
&lt;li>&lt;strong>使用 grpcurl 测试 gRPC 端点&lt;/strong>：使用 grpcurl 工具可以发送请求并测试 gRPC 服务。&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第五章服务间通信" class="pagebody-header">
 &lt;strong>第五章：服务间通信&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>gRPC 存根&lt;/strong>：gRPC 存根用于在服务之间进行通信，它是由 .proto 文件生成的 Go 源代码。&lt;/li>
&lt;li>&lt;strong>依赖模块和实现端口和适配器&lt;/strong>：解释了如何在 Order 服务中依赖 Payment 服务，并实现相应的端口和适配器。&lt;/li>
&lt;li>&lt;strong>gRPC 客户端配置&lt;/strong>：使用 &lt;code>grpc.WithTransportCredentials(insecure.NewCredentials())&lt;/code> 来禁用 TLS 握手，使用 &lt;code>payment.NewPaymentClient(conn)&lt;/code> 来初始化 payment 存根实例。&lt;/li>
&lt;li>&lt;strong>错误处理&lt;/strong>：gRPC 使用预定义的状态码来表示不同的错误情况，并提供了一种结构化的方式来处理错误。&lt;/li>
&lt;li>&lt;strong>错误详情&lt;/strong>：通过 &lt;code>errdetails.BadRequest_FieldViolation&lt;/code> 和 &lt;code>errdetails.BadRequest&lt;/code> 可以传递详细的错误信息，包括字段和描述。&lt;/li>
&lt;li>&lt;strong>状态码&lt;/strong>：详细列出了 gRPC 中常用的状态码，例如 OK，CANCELLED, INVALID_ARGUMENT, ALREADY_EXISTS, PERMISSION_DENIED, RESOURCE_EXHAUSTED 等，这些状态码用于在服务间传递错误信息。&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第六章弹性通信" class="pagebody-header">
 &lt;strong>第六章：弹性通信&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>弹性模式&lt;/strong>：弹性模式是用于处理分布式系统中网络故障的模式，包括超时、重试和熔断器。&lt;/li>
&lt;li>&lt;strong>超时模式&lt;/strong>：使用 &lt;code>context.WithTimeout&lt;/code> 或 &lt;code>context.WithDeadline&lt;/code> 来设置请求超时，防止长时间等待。&lt;/li>
&lt;li>&lt;strong>重试模式&lt;/strong>：使用 &lt;code>grpc_retry&lt;/code> 中间件来自动重试失败的请求，并使用 &lt;code>WithCodes&lt;/code>、&lt;code>WithMax&lt;/code> 和 &lt;code>WithBackoff&lt;/code> 等配置来控制重试行为。&lt;/li>
&lt;li>&lt;strong>熔断器模式&lt;/strong>：熔断器模式可以防止级联故障，并在服务恢复后自动重置。使用 &lt;code>gobreaker&lt;/code> 包来实现熔断器，通过 &lt;code>MaxRequests&lt;/code>、&lt;code>ReadyToTrip&lt;/code> 和 &lt;code>OnStateChange&lt;/code> 等配置来控制熔断器的行为。&lt;/li>
&lt;li>&lt;strong>gRPC 错误模型&lt;/strong>：gRPC 使用 &lt;code>status&lt;/code> 包来处理错误，包括 Code、Status 和 Message 三个主要字段，以及 &lt;code>ErrorDetails&lt;/code> 部分来包含详细的错误列表。&lt;/li>
&lt;li>&lt;strong>TLS 配置&lt;/strong>：使用 TLS 配置来保护服务间的通信，包括证书生成和 gRPC TLS 凭证的使用。&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第七章测试微服务" class="pagebody-header">
 &lt;strong>第七章：测试微服务&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>测试金字塔&lt;/strong>：测试金字塔将软件测试分为单元测试、集成测试和端到端测试三个类别，单元测试占比最大，端到端测试占比最小。&lt;/li>
&lt;li>&lt;strong>单元测试&lt;/strong>：单元测试用于验证软件的特定单元，例如类或函数。测试工作流程包括设置、调用 SUT（被测系统）、验证和拆卸。&lt;/li>
&lt;li>&lt;strong>系统测试（SUT）&lt;/strong>：SUT 可以是类或整个应用程序，测试套件用于验证 SUT 的行为。&lt;/li>
&lt;li>&lt;strong>Mock&lt;/strong>：使用 Mock 来模拟依赖项，从而快速验证系统行为。使用 testify/mock 或 mockery 来生成 Mock。&lt;/li>
&lt;li>&lt;strong>集成测试&lt;/strong>：使用 Testcontainers 来初始化数据库等外部依赖项，并使用 Go 的测试框架来验证集成。&lt;/li>
&lt;li>&lt;strong>端到端测试&lt;/strong>：使用 Docker Compose 来定义和运行应用程序堆栈，并通过测试来验证整个流程。&lt;/li>
&lt;li>&lt;strong>测试覆盖率&lt;/strong>: 使用 &lt;code>go test -cover&lt;/code> 命令来查看测试覆盖率，并使用 &lt;code>-coverprofile&lt;/code> 来生成覆盖率报告。&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第八章部署" class="pagebody-header">
 &lt;strong>第八章：部署&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>Kubernetes&lt;/strong>：Kubernetes 是一个用于自动化部署、扩展和管理容器化应用程序的开源平台。&lt;/li>
&lt;li>&lt;strong>Kubernetes 的核心组件&lt;/strong>：包括 API 服务器、调度器、控制器管理器、etcd 和 kubelet 等。&lt;/li>
&lt;li>&lt;strong>Kubernetes 部署&lt;/strong>：通过 Deployment 资源来管理 Pod 的部署和更新。&lt;/li>
&lt;li>&lt;strong>Service&lt;/strong>：使用 Service 资源来暴露 Pod 作为内部或公共端点。&lt;/li>
&lt;li>&lt;strong>部署策略&lt;/strong>：包括 RollingUpdate、Blue-Green 和 Canary 等部署策略。&lt;/li>
&lt;li>&lt;strong>证书管理&lt;/strong>：介绍如何在 Kubernetes 环境中进行证书管理，包括 ClusterIssuer 和 Certificate 的使用。&lt;/li>
&lt;li>&lt;strong>使用 kubectl 进行部署&lt;/strong>: 详细介绍了如何使用 kubectl 命令来部署 Kubernetes 资源，包括 Deployment 和 Service。&lt;/li>
&lt;li>&lt;strong>GitOps&lt;/strong>：使用 ArgoCD 和 FluxCD 等工具来自动化部署过程。&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第九章可观测性" class="pagebody-header">
 &lt;strong>第九章：可观测性&lt;/strong>
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>可观测性&lt;/strong>：可观测性是跟踪和分析分布式系统中问题的根本原因的关键，它通过跟踪、指标和日志来帮助我们了解系统状态。&lt;/li>
&lt;li>&lt;strong>跟踪（Traces）&lt;/strong>：跟踪是记录跨多个服务的请求旅程，包括操作和跨度（spans）。&lt;/li>
&lt;li>&lt;strong>指标（Metrics）&lt;/strong>：指标是用于量化系统性能的度量，例如延迟、请求数和错误率。&lt;/li>
&lt;li>&lt;strong>服务级别目标 (SLO)&lt;/strong>：定义了服务应达到的目标，例如正常运行时间或响应延迟。&lt;/li>
&lt;li>&lt;strong>日志（Logs）&lt;/strong>：日志是应用程序产生的消息，可以帮助我们理解发生了什么 。&lt;/li>
&lt;li>&lt;strong>OpenTelemetry&lt;/strong>：OpenTelemetry 是一组 API、SDK 和工具，用于收集和发送跟踪、指标和日志数据。&lt;/li>
&lt;li>&lt;strong>Jaeger&lt;/strong>：Jaeger 是一个用于分布式跟踪的开源系统。&lt;/li>
&lt;li>&lt;strong>Prometheus&lt;/strong>：Prometheus 是一个用于收集和存储指标的开源系统。&lt;/li>
&lt;li>&lt;strong>Fluent Bit&lt;/strong>：Fluent Bit 是一个轻量级的日志收集器，用于将日志转发到 Elasticsearch。&lt;/li>
&lt;li>&lt;strong>Elasticsearch&lt;/strong>：Elasticsearch 是一个用于存储和搜索日志的开源系统 。&lt;/li>
&lt;li>&lt;strong>Kibana&lt;/strong>：Kibana 是一个用于可视化日志的开源工具 。&lt;/li>
&lt;li>&lt;strong>整合可观察性工具&lt;/strong>: 详细介绍了如何将 OpenTelemetry、Jaeger、Prometheus、Fluent Bit、Elasticsearch 和 Kibana 集成在一起，以建立一个完整的可观察性堆栈。&lt;/li>
&lt;/ul></description></item><item><title>Tidy First</title><link>https://booslip.rpcx.io/posts/tidy-first/</link><pubDate>Wed, 01 Jan 2025 23:33:11 +0800</pubDate><guid>https://booslip.rpcx.io/posts/tidy-first/</guid><description>&lt;p>这本书的作者是谁？肯特·贝克 (Kent Beck) 。肯特·贝克 (Kent Beck) 是谁？
他是最早研究软件开发的模式和重构的人之一，软件工程领域泰斗，敏捷开发的开创者之一，更是极限编程和测试驱动开发的创始人，同时还是JUnit 的作者，&lt;/p></description></item><item><title>The Rules of Programming</title><link>https://booslip.rpcx.io/posts/the-rules-of-programming/</link><pubDate>Wed, 01 Jan 2025 22:58:50 +0800</pubDate><guid>https://booslip.rpcx.io/posts/the-rules-of-programming/</guid><description>&lt;p>这份规则摘自克里斯·齐默曼的《编程规则：如何编写更好的代码》一书。书中作者结合其在微软和Sucker Punch游戏公司的编程团队管理经验，总结出一系列编程原则，旨在帮助程序员编写更简洁、易于测试和维护的代码。这些原则涵盖了代码简洁性、算法选择、测试策略、团队协作、代码审查以及代码重构等多个方面，并通过具体的代码示例和案例分析进行阐述。 书中还讨论了如何处理代码复杂性，以及如何平衡渐进式改进和彻底重构之间的关系。&lt;/p></description></item><item><title>Code Like a Pro in Rust</title><link>https://booslip.rpcx.io/posts/code-like-a-pro-in-rust/</link><pubDate>Wed, 01 Jan 2025 10:47:55 +0800</pubDate><guid>https://booslip.rpcx.io/posts/code-like-a-pro-in-rust/</guid><description>&lt;p>本书对 Rust 初学者合适，没有介绍高深的Rust概念。&lt;/p>
&lt;p>好的，这是一份按照章节对《Code Like a Pro in Rust》这本书的总结和摘要，着重于关键概念和信息，以中文呈现：&lt;/p></description></item><item><title>Write Powerful Rust Macros</title><link>https://booslip.rpcx.io/posts/write-powerful-rust-macros/</link><pubDate>Wed, 01 Jan 2025 10:30:41 +0800</pubDate><guid>https://booslip.rpcx.io/posts/write-powerful-rust-macros/</guid><description>&lt;p>这本书《Write Powerful Rust Macros》旨在教导读者如何使用 Rust 的宏进行元编程。本书从元编程的基础概念讲起，逐步深入到各种宏的类型和实际应用，并通过大量的示例和练习，帮助读者掌握编写强大 Rust 宏的技能。&lt;/p></description></item><item><title>Learn Concurrent Programming With Go</title><link>https://booslip.rpcx.io/posts/learn-concurrent-programming-with-go/</link><pubDate>Wed, 01 Jan 2025 10:09:38 +0800</pubDate><guid>https://booslip.rpcx.io/posts/learn-concurrent-programming-with-go/</guid><description>&lt;ul>
&lt;li>
&lt;p>&lt;strong>第一章：步入并发编程&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>并发（Concurrency）&lt;/strong> 是一种程序代码的属性，它将指令分组为独立的任务，并规划任务之间的边界和同步点。并发存在于我们日常生活和工作中，例如多人同时在线购物或汽车行驶。&lt;/li>
&lt;li>&lt;strong>并行（Parallelism）&lt;/strong> 是程序执行的属性，它指同时执行多个任务。并行是并发的子集，只有并发程序才能并行执行。&lt;/li>
&lt;li>&lt;strong>Go 语言&lt;/strong> 在设计时就考虑了高性能的并发，因此是学习并发编程的理想选择。Go 使用 &lt;strong>goroutine&lt;/strong> 作为基本的并发执行单元，它是一种轻量级的用户级线程，由 Go 的运行时管理。&lt;/li>
&lt;li>Go 提供了两种并发模型：&lt;strong>通信顺序进程（CSP）&lt;/strong> 模型和传统的 &lt;strong>内存共享&lt;/strong> 模型。CSP 模型通过消息传递进行通信，而内存共享模型使用互斥锁和条件变量等原语进行同步。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>第二章：处理线程&lt;/strong>&lt;/p></description></item><item><title>Learn Rust in a Month of Lunches</title><link>https://booslip.rpcx.io/posts/learn-rust-in-a-month-of-lunches/</link><pubDate>Wed, 01 Jan 2025 09:34:21 +0800</pubDate><guid>https://booslip.rpcx.io/posts/learn-rust-in-a-month-of-lunches/</guid><description>&lt;ul>
&lt;li>
&lt;p>&lt;strong>第一章：Rust 基础入门&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>核心概念：&lt;/strong> 本章主要介绍了 Rust 的基本语法和概念，包括变量声明、代码块、打印输出、类型转换和字符串。&lt;/li>
&lt;li>&lt;strong>变量与代码块：&lt;/strong>
&lt;ul>
&lt;li>使用 &lt;code>let&lt;/code> 关键字声明变量，代码块用 &lt;code>{}&lt;/code> 表示。变量的作用域（lifetime）限制在代码块内部。&lt;/li>
&lt;li>&lt;strong>Shadowing&lt;/strong> (遮蔽) 是指用新的 &lt;code>let&lt;/code> 绑定同名变量，使之前的变量失效。&lt;/li>
&lt;li>变量的类型通常由 Rust 自动推断，但可以使用 &lt;code>as&lt;/code> 关键字进行显式类型转换。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>打印输出:&lt;/strong>
&lt;ul>
&lt;li>&lt;code>println!&lt;/code> 宏用于打印输出，&lt;code>{}&lt;/code> 用来捕获变量的值。&lt;code>{:?}&lt;/code> 用于调试输出，&lt;code>{:#?}&lt;/code> 用于更美观的调试输出，可以分行显示结构体等复杂类型的内容。&lt;/li>
&lt;li>&lt;code>print!&lt;/code> 宏与 &lt;code>println!&lt;/code> 类似，但不添加换行符。&lt;/li>
&lt;li>可以使用 &lt;code>r#&amp;quot;&amp;quot;#&lt;/code> 来创建原始字符串，避免转义字符的麻烦。&lt;/li>
&lt;li>在字符串前加 &lt;code>b&lt;/code> 可以打印字符串的字节表示。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>字符串类型：&lt;/strong> &lt;code>&amp;amp;str&lt;/code> 是一种字符串切片类型，后续章节会详细介绍。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>第二章：内存、变量与所有权&lt;/strong>&lt;/p></description></item><item><title>System Programming Essentials With Go</title><link>https://booslip.rpcx.io/posts/system-programming-essentials-with-go/</link><pubDate>Sun, 29 Dec 2024 17:24:00 +0800</pubDate><guid>https://booslip.rpcx.io/posts/system-programming-essentials-with-go/</guid><description>&lt;p>本书主要介绍了使用Go语言进行系统级编程的知识。书中涵盖了并发编程、内存管理、性能分析、系统调用、网络编程、以及与硬件交互等多个方面。此外，还包含了命令行工具的开发、日志记录、监控和追踪等内容，并以一个分布式缓存的项目作为案例，展示了如何将所学知识应用于实践。最后，书中还讨论了高效编码技巧和一些常见问题的避免方法。&lt;/p></description></item><item><title>Go Recipes for Developers</title><link>https://booslip.rpcx.io/posts/go-recipes-for-developers/</link><pubDate>Sun, 29 Dec 2024 17:12:00 +0800</pubDate><guid>https://booslip.rpcx.io/posts/go-recipes-for-developers/</guid><description>&lt;p>本书涵盖了Go语言编程的多个方面，包括项目组织、日期时间处理、数组切片和映射的使用、JSON处理、进程管理、网络编程、流式输入输出、数据库交互、日志记录、测试和性能分析等。书中以“食谱”的形式，为开发者提供了大量实用代码示例和最佳实践，帮助解决实际编程问题。作者Burak Serdar拥有超过30年的软件工程经验，审稿人Dylan Meeus也具备丰富的编程经验，确保了书中内容的权威性和实用性。&lt;/p></description></item><item><title>Patterns of Distributed Systems</title><link>https://booslip.rpcx.io/posts/patterns-of-distributed-systems/</link><pubDate>Sun, 29 Dec 2024 16:48:43 +0800</pubDate><guid>https://booslip.rpcx.io/posts/patterns-of-distributed-systems/</guid><description>&lt;div class="component-content pagebody component">
 &lt;h2 id="第一部分导论与概述" class="pagebody-header">
 第一部分：导论与概述
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>&lt;strong>导论&lt;/strong>：本书的核心概念是将复杂的分布式系统抽象成可复用的模式。通过命名组件、描述行为和交互方式，构建了一个分布式系统的模式语言，使系统可以被视为可组合的“乐高积木”。 这有助于避免在讨论分布式系统时因术语歧义而产生的误解。&lt;/li>
&lt;li>&lt;strong>概述&lt;/strong>：分布式系统的基本构建块包括数据分区和复制。本书首先关注数据复制，然后介绍分区。一个简单的示例数据记录被复制到多个节点，展示了分布式系统中数据一致性的挑战。例如，如果一个节点在更新数据过程中崩溃，会导致数据不一致。 使用&lt;strong>领导者（Leader）模式&lt;/strong>可以解决这个问题，由一个领导者节点处理所有更新请求。 当领导者失效时，需要通过&lt;strong>心跳（Heartbeat）机制&lt;/strong>来检测，并选举新的领导者。 &lt;strong>高水位标记（High-Water Mark）&lt;/strong> 用于确保所有节点在领导者切换后保持数据一致性。&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第二部分数据复制模式" class="pagebody-header">
 第二部分：数据复制模式
 &lt;/h2>
&lt;/div>&lt;ul>
&lt;li>
&lt;p>&lt;strong>写前日志（Write-Ahead Log, WAL）&lt;/strong>：&lt;/p></description></item><item><title>Idiomatic Rust</title><link>https://booslip.rpcx.io/posts/idiomatic-rust/</link><pubDate>Sat, 28 Dec 2024 19:09:04 +0800</pubDate><guid>https://booslip.rpcx.io/posts/idiomatic-rust/</guid><description>&lt;p>本书是作者Brenden Matthews继《Code Like a Pro in Rust》之后的又一本Rust编程指南，本书重点关注Rust的惯用代码模式、习惯和约定。本书的灵感来源于经典的《设计模式：可复用面向对象软件的要素》，但并不直接翻译原书的模式，而是专注于Rust特有的模式和实践。本书的目标是帮助读者像Rustacean（Rust的资深开发者）一样编写代码，而不仅仅是了解Rust的语法。&lt;/p></description></item><item><title>Async Rust</title><link>https://booslip.rpcx.io/posts/async-rust/</link><pubDate>Sat, 28 Dec 2024 18:58:34 +0800</pubDate><guid>https://booslip.rpcx.io/posts/async-rust/</guid><description>&lt;p>好的，我将按照您的要求，对每个章节的内容进行总结，并尽可能地包含关键代码，使其内容详实且易于理解。&lt;/p>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第一章异步简介" class="pagebody-header">
 第一章：异步简介
 &lt;/h2>
&lt;/div>&lt;p>本章主要介绍了异步编程的概念以及在Rust中的应用。&lt;/p></description></item><item><title>Effective Rust</title><link>https://booslip.rpcx.io/posts/effective-rust/</link><pubDate>Sat, 28 Dec 2024 18:42:32 +0800</pubDate><guid>https://booslip.rpcx.io/posts/effective-rust/</guid><description>&lt;div class="component-content pagebody component">
 &lt;h2 id="第一章类型types" class="pagebody-header">
 第一章：类型（Types）
 &lt;/h2>
&lt;/div>&lt;p>本章主要讨论 Rust 的类型系统及其在表达数据结构和行为方面的应用。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>使用类型系统表达数据结构&lt;/strong>：
&lt;ul>
&lt;li>强调 Rust 的类型系统能够帮助开发者清晰地表达数据结构，提高代码的可读性和可维护性。&lt;/li>
&lt;li>介绍了 &lt;strong>元组结构体 (tuple structs)&lt;/strong>，其字段通过数字索引访问，例如 &lt;code>m.0&lt;/code>。&lt;/li>
&lt;li>深入探讨了 &lt;strong>枚举 (enums)&lt;/strong>，它是 Rust 类型系统的核心。枚举可以定义一组互斥的值，并可以附带数值。
&lt;div class="component-content pagebody component code">
 
 
 
 &lt;div class="">&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">HttpResultCode&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Ok &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">200&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NotFound &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">404&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Teapot &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">418&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
 
&lt;/div>&lt;/li>
&lt;li>使用枚举可以增强代码的可读性和类型安全性，避免使用布尔值参数时可能出现的混淆。例如，使用 &lt;code>Sides::Both&lt;/code> 和 &lt;code>Output::BlackAndWhite&lt;/code> 比使用 &lt;code>true&lt;/code> 和 &lt;code>false&lt;/code> 更清晰易懂。&lt;/li>
&lt;li>&lt;strong>match 表达式&lt;/strong> 用于处理枚举的不同变体，Rust 编译器会强制检查所有变体是否都被覆盖，从而避免遗漏情况。&lt;/li>
&lt;li>如果枚举仅仅是一个 C 风格的数值列表，可以使用 &lt;code>non_exhaustive&lt;/code> 属性来避免添加新变体时的破坏性变更。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>使用类型系统表达通用行为&lt;/strong>：
&lt;ul>
&lt;li>函数 (functions) 可以通过 &lt;code>fn&lt;/code> 关键字定义，并可以指定返回值类型。函数也可以仅用于副作用，没有返回值。
&lt;div class="component-content pagebody component code">
 
 
 
 &lt;div class="">&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">div&lt;/span>(x: &lt;span style="color:#66d9ef">f64&lt;/span>, y: &lt;span style="color:#66d9ef">f64&lt;/span>) -&amp;gt; &lt;span style="color:#66d9ef">f64&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> y &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0.0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">f64&lt;/span>::&lt;span style="color:#66d9ef">NAN&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x &lt;span style="color:#f92672">/&lt;/span> y
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">show&lt;/span>(x: &lt;span style="color:#66d9ef">f64&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println!(&lt;span style="color:#e6db74">&amp;#34;x = &lt;/span>&lt;span style="color:#e6db74">{x}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
 
&lt;/div>&lt;/li>
&lt;li>&lt;strong>方法 (methods)&lt;/strong> 与特定的数据结构关联，通过 &lt;code>self&lt;/code> 引用该数据结构。方法可以修改、读取或消耗数据结构. 方法可以被添加到 &lt;code>enum&lt;/code> 类型和 &lt;code>struct&lt;/code> 类型。
&lt;div class="component-content pagebody component code">
 
 
 
 &lt;div class="">&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">Shape&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Rectangle { width: &lt;span style="color:#66d9ef">f64&lt;/span>, height: &lt;span style="color:#66d9ef">f64&lt;/span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Circle { radius: &lt;span style="color:#66d9ef">f64&lt;/span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">impl&lt;/span> Shape {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">pub&lt;/span> &lt;span style="color:#66d9ef">fn&lt;/span> &lt;span style="color:#a6e22e">area&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>self) -&amp;gt; &lt;span style="color:#66d9ef">f64&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">match&lt;/span> self {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Shape::Rectangle { width, height } &lt;span style="color:#f92672">=&amp;gt;&lt;/span> width &lt;span style="color:#f92672">*&lt;/span> height,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Shape::Circle { radius } &lt;span style="color:#f92672">=&amp;gt;&lt;/span> std::&lt;span style="color:#66d9ef">f64&lt;/span>::consts::&lt;span style="color:#66d9ef">PI&lt;/span> &lt;span style="color:#f92672">*&lt;/span> radius &lt;span style="color:#f92672">*&lt;/span> radius,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
 
&lt;/div>&lt;/li>
&lt;li>&lt;strong>函数指针 (function pointers)&lt;/strong> 可以作为参数传递，允许代码在运行时改变行为。函数指针类型实现了 &lt;code>Copy&lt;/code> 和 &lt;code>Eq&lt;/code> 等 trait. 函数的名称需要显式转换为 &lt;code>fn&lt;/code> 类型.&lt;/li>
&lt;li>&lt;strong>闭包 (closures)&lt;/strong> 是一种匿名函数，可以捕获其所在环境中的变量。闭包通过 &lt;code>FnOnce&lt;/code>、&lt;code>FnMut&lt;/code> 和 &lt;code>Fn&lt;/code> 等 trait 来表达不同的捕获行为. 使用 &lt;strong>最通用的 &lt;code>Fn*&lt;/code> trait&lt;/strong> 可以为调用者提供最大的灵活性.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>优先使用 &lt;code>Option&lt;/code> 和 &lt;code>Result&lt;/code> 的转换方法&lt;/strong>：
&lt;ul>
&lt;li>&lt;code>Option&amp;lt;T&amp;gt;&lt;/code> 用于表示可能存在或不存在的值，而 &lt;code>Result&amp;lt;T, E&amp;gt;&lt;/code> 用于表示可能成功或失败的操作。&lt;/li>
&lt;li>标准库为 &lt;code>Option&lt;/code> 和 &lt;code>Result&lt;/code> 提供了多种转换方法，以避免显式使用 &lt;code>match&lt;/code> 表达式，从而使代码更简洁。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>优先使用惯用的错误类型&lt;/strong>：
&lt;ul>
&lt;li>当函数可能产生多种不同类型的错误时，可以使用枚举 (enum) 来统一表示。&lt;/li>
&lt;li>&lt;code>From&lt;/code> trait 可以实现不同错误类型之间的自动转换，配合 &lt;code>?&lt;/code> 操作符，可以简化错误处理.&lt;/li>
&lt;li>可以使用 &lt;code>thiserror&lt;/code> crate 来简化错误类型定义。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>理解类型转换&lt;/strong>：
&lt;ul>
&lt;li>Rust 中的类型转换通过 &lt;code>From&lt;/code> 和 &lt;code>Into&lt;/code> trait 实现。如果类型 &lt;code>U&lt;/code> 实现了 &lt;code>From&amp;lt;T&amp;gt;&lt;/code>，那么类型 &lt;code>T&lt;/code> 会自动实现 &lt;code>Into&amp;lt;U&amp;gt;&lt;/code>。&lt;/li>
&lt;li>&lt;strong>Coercion (强制转换)&lt;/strong> 是一种自动类型转换机制，可以发生在某些情况下，例如：数组到切片、具体类型到 trait 对象、较长的生命周期到较短的生命周期。用户定义的类型可以通过实现 &lt;code>Deref&lt;/code> 和 &lt;code>DerefMut&lt;/code> trait 来影响 coercion 行为。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>拥抱 newtype 模式&lt;/strong>：
&lt;ul>
&lt;li>&lt;strong>newtype 模式&lt;/strong> 是指创建一个包含单个字段的元组结构体，可以为现有类型赋予新的语义，并解决一些类型安全问题。&lt;/li>
&lt;li>例如，可以使用 newtype 模式来避免单位转换错误。&lt;/li>
&lt;li>newtype 模式也可以用于绕过孤儿规则 (orphan rule)，为外部类型实现外部 trait。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>使用 Builder 模式处理复杂类型&lt;/strong>：
&lt;ul>
&lt;li>&lt;strong>Builder 模式&lt;/strong> 可以简化复杂类型的构造过程，允许用户链式调用 setter 方法来设置字段值。&lt;/li>
&lt;li>builder 可以用于创建多个实例，并且可以克隆模板。&lt;/li>
&lt;li>可以使用宏 (macros) 或现有的 crate（如 &lt;code>derive_builder&lt;/code>）来减少 builder 模式的样板代码。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>熟悉引用和指针类型&lt;/strong>：
&lt;ul>
&lt;li>&lt;strong>引用 (references)&lt;/strong> 是一种不拥有数据的指针，分为可变引用 (&lt;code>&amp;amp;mut T&lt;/code>) 和不可变引用 (&lt;code>&amp;amp;T&lt;/code>)。&lt;/li>
&lt;li>&lt;strong>切片 (slices)&lt;/strong> 可以引用数组的一部分。&lt;/li>
&lt;li>&lt;strong>Vec&lt;!-- raw HTML omitted -->&lt;/strong> 是一种动态数组，可以增长和缩小。&lt;/li>
&lt;li>&lt;strong>Trait 对象&lt;/strong> 是指向实现了特定 trait 的具体类型的指针，通过虚表 (vtable) 实现动态分发。&lt;/li>
&lt;li>&lt;code>Deref&lt;/code> 和 &lt;code>DerefMut&lt;/code> trait 用于智能指针类型，允许像普通引用一样访问它们指向的数据。&lt;/li>
&lt;li>&lt;code>AsRef&lt;/code> 和 &lt;code>AsMut&lt;/code> trait 用于类型之间的引用转换。&lt;/li>
&lt;li>&lt;code>Borrow&lt;/code> 和 &lt;code>BorrowMut&lt;/code> trait 用于处理引用和被移动的值。&lt;/li>
&lt;li>&lt;code>Cow&lt;/code> 类型可以持有拥有的数据或借用的数据的引用。&lt;/li>
&lt;li>&lt;code>Rc&amp;lt;T&amp;gt;&lt;/code> 用于在单线程环境中共享所有权。&lt;code>Weak&amp;lt;T&amp;gt;&lt;/code> 是 &lt;code>Rc&amp;lt;T&amp;gt;&lt;/code> 的弱引用。&lt;/li>
&lt;li>&lt;code>Arc&amp;lt;T&amp;gt;&lt;/code> 是 &lt;code>Rc&amp;lt;T&amp;gt;&lt;/code> 的线程安全版本，使用原子计数器。&lt;/li>
&lt;li>&lt;code>Mutex&amp;lt;T&amp;gt;&lt;/code> 用于在多线程环境中保护可变数据。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>考虑使用迭代器转换而不是显式循环&lt;/strong>：
&lt;ul>
&lt;li>&lt;strong>迭代器 (iterators)&lt;/strong> 提供了一种处理集合的便捷方式，避免显式循环。&lt;/li>
&lt;li>迭代器转换方法可以链式调用，实现复杂的数据处理操作。例如 &lt;code>filter&lt;/code>, &lt;code>take&lt;/code>, &lt;code>map&lt;/code>, &lt;code>sum&lt;/code>.&lt;/li>
&lt;li>&lt;code>iter()&lt;/code> 方法用于创建不可变迭代器，&lt;code>iter_mut()&lt;/code> 方法用于创建可变迭代器.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>

&lt;div class="component-content pagebody component">
 &lt;h2 id="第二章trait" class="pagebody-header">
 第二章：Trait
 &lt;/h2>
&lt;/div>&lt;p>本章主要介绍 Rust 中的 trait 以及一些常用的标准 trait。&lt;/p></description></item><item><title>Rust Atomics and Locks</title><link>https://booslip.rpcx.io/posts/rust-atomics-and-locks/</link><pubDate>Sat, 28 Dec 2024 12:43:47 +0800</pubDate><guid>https://booslip.rpcx.io/posts/rust-atomics-and-locks/</guid><description>&lt;p>&lt;strong>前言&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>本书作者 Mara Bos 在 Rust 标准库团队工作，并有多年并发实时系统开发经验。&lt;/li>
&lt;li>本书的重点是 Rust 中 &lt;strong>底层的并发&lt;/strong> 实现，而不是高级的抽象。&lt;/li>
&lt;li>本书适合那些对并发编程的底层机制感兴趣的读者，例如原子操作、锁、内存排序等.&lt;/li>
&lt;li>本书通过从零开始构建各种并发原语，来深入理解其工作原理.&lt;/li>
&lt;li>本书的写作灵感来源于 Rust 社区关于并发的讨论，作者希望通过实践来深入理解软件安全特性.&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>目录&lt;/strong>&lt;/p></description></item><item><title>Command Line Rust</title><link>https://booslip.rpcx.io/posts/command-line-rust/</link><pubDate>Sat, 28 Dec 2024 10:14:48 +0800</pubDate><guid>https://booslip.rpcx.io/posts/command-line-rust/</guid><description>&lt;p>书中配套代码：&lt;a href="https://github.com/kyclark/command-line-rust">kyclark/command-line-rust&lt;/a>&lt;/p>

&lt;div class="component-content pagebody component">
 &lt;h2 id="前言" class="pagebody-header">
 前言
 &lt;/h2>
&lt;/div>&lt;p>本书作者在前言中分享了他学习编程的经验，强调了&lt;strong>实践的重要性&lt;/strong>。作者认为，仅仅阅读参考书籍是不足以掌握一门编程语言的，需要通过实际编写程序来应用所学知识。作者还提到，&lt;strong>学习如何学习一门语言&lt;/strong>是程序员最重要的技能。Rust 语言在语法上与 C 语言类似，例如 for 循环、分号结尾的语句和用花括号表示的代码块。Rust 通过 &lt;strong>borrow checker&lt;/strong> 来保证内存安全，同时不会牺牲性能。Rust 程序可以编译成原生二进制代码，其运行速度通常可以与 C 或 C++ 编写的程序相媲美。Rust 从函数式语言如 Haskell 中借鉴了一些概念，例如，变量默认是&lt;strong>不可变的&lt;/strong>，函数是&lt;strong>一等公民&lt;/strong>，可以使用&lt;strong>枚举和 sum 类型&lt;/strong>表示函数可以返回 &lt;code>Ok&lt;/code> 或 &lt;code>Err&lt;/code>。书中还提供了代码示例下载链接和技术问题反馈邮箱。作者感谢了 Rust 社区的贡献，以及家人和朋友的支持。&lt;/p></description></item></channel></rss>