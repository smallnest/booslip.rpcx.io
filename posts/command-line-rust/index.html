<!doctype html><html class="js no-touch progressive-image no-reduced-motion progressive" lang=zh-hans><head><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=icon href=/img/favicon.ico><meta name=keyword content><meta property="og:url" content="https://booslip.rpcx.io/posts/command-line-rust/"><meta property="og:site_name" content="竹简书摘"><meta property="og:title" content="Command Line Rust"><meta property="og:description" content="使用Rust开发命令行程序"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-28T10:14:48+08:00"><meta property="article:modified_time" content="2024-12-28T10:14:48+08:00"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Cli"><title>Command Line Rust</title>
<link rel=canonical href=/posts/command-line-rust/><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/custom.css><link rel=stylesheet href=/css/search.css><link href="https://fonts.googleapis.com/css?family=Bree+Serif" rel=stylesheet><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?c80136b2ed102610dcafb84941e8df30",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head></head><body class=page-article><header><nav class=nav><div class=nav-wrapper><div class=nav-content-wrapper><div class=nav-content><a href=/ class=nav-title>竹简书摘</a><div class=nav-menu><div class=nav-item-wrapper><a href=/posts class=nav-item-content>书摘</a></div><div class=nav-item-wrapper><a href=/index.xml class=nav-item-content target=_blank>RSS</a></div></div></div></div></div></nav><script>function toggleSearchModal(){const t=`
    <div class="modal-body">
      <div id="autocomplete" onclick="event.stopPropagation();"></div>
    </div>
    `,e=document.querySelector("#modal-wrapper");if(e)document.body.removeAttribute("style"),document.body.removeChild(e);else{const e=document.createElement("div");document.body.setAttribute("style","overflow: hidden;"),e.setAttribute("id","modal-wrapper"),e.setAttribute("onclick","toggleSearchModal()"),e.innerHTML=t;const n=document.createElement("script");n.setAttribute("src","https://booslip.rpcx.io/js/algolia.js"),e.appendChild(n),document.body.append(e)}}</script></header><main id=main class=main><section><article class=article><div class=article-header><div class="category component"><div class=component-content><div class=category-eyebrow><span class="category-eyebrow__category category_original">rust
</span><span class=category-eyebrow__date>2024年12月28日</span></div></div></div><div class="pagetitle component"><div class=component-content><h1 class=hero-headline>Command Line Rust</h1></div></div><div class="component article-subhead"><div class=component-content>使用Rust开发命令行程序</div></div><div class="tagssheet component"><div class=component-content><a href=/tags/rust class=tag>rust
</a><a href=/tags/cli class=tag>cli</a></div></div></div><div class="book-card component"><div class=book-cover><img data-src=/covers/command-line-rust.jpg alt=书籍封面></div><div class=book-info><h1 class=book-title>Command Line Rust</h1><div class=book-meta><span>作者：Ken Youens-Clark</span>
<span>出版日期：2021-09-30</span>
<span>出版社：O'Reilly Media, Inc.</span></div><div class=book-description>本书是一本基于项目的Rust命令行工具编写入门教程。它指导读者使用Rust编写多个Unix命令行工具的克隆版本，例如head、cal和grep等，从而学习Rust语言的核心概念和Unix命令行编程的技巧。书中涵盖了处理命令行参数、读取和写入文件、解析文本、使用正则表达式等方面的内容，并通过单元测试和集成测试来确保程序的正确性。 此外，书中还介绍了Rust的一些高级特性，例如错误处理、生命周期管理和并发编程。 通过完成这些项目，读者可以快速掌握Rust语言并提升实际编程能力。</div></div></div><div class=pagebody><p class="component-content component">书中配套代码：<a href=https://github.com/kyclark/command-line-rust>kyclark/command-line-rust</a></p><div class="component-content pagebody component"><h2 id=前言 class=pagebody-header>前言</h2></div><p class="component-content component">本书作者在前言中分享了他学习编程的经验，强调了<strong>实践的重要性</strong>。作者认为，仅仅阅读参考书籍是不足以掌握一门编程语言的，需要通过实际编写程序来应用所学知识。作者还提到，<strong>学习如何学习一门语言</strong>是程序员最重要的技能。Rust 语言在语法上与 C 语言类似，例如 for 循环、分号结尾的语句和用花括号表示的代码块。Rust 通过 <strong>borrow checker</strong> 来保证内存安全，同时不会牺牲性能。Rust 程序可以编译成原生二进制代码，其运行速度通常可以与 C 或 C++ 编写的程序相媲美。Rust 从函数式语言如 Haskell 中借鉴了一些概念，例如，变量默认是<strong>不可变的</strong>，函数是<strong>一等公民</strong>，可以使用<strong>枚举和 sum 类型</strong>表示函数可以返回 <code>Ok</code> 或 <code>Err</code>。书中还提供了代码示例下载链接和技术问题反馈邮箱。作者感谢了 Rust 社区的贡献，以及家人和朋友的支持。</p><div class="component-content pagebody component"><h2 id=第一章真相或后果 class=pagebody-header>第一章：真相或后果</h2></div><p class="component-content component">本章介绍了 Rust 编程的<strong>基础知识</strong>，并以经典的 <code>Hello, world!</code> 程序为例，展示了如何<strong>创建和运行</strong>一个 Rust 项目。</p><p class="component-content component">首先，介绍了如何组织 Rust 项目目录，使用 Cargo 创建和运行项目。还演示了如何编写和运行集成测试，以验证程序的正确性。例如，可以通过 <code>Command::cargo_bin("hello").unwrap()</code> 创建一个命令，并使用 <code>cmd.assert().success().stdout("Hello, world!\n")</code> 来断言命令成功执行且标准输出为 “Hello, world!\n”。如果修改 <code>src/main.rs</code> 中的输出，测试将会失败，并显示实际输出与期望输出之间的差异。</p><p class="component-content component">此外，还介绍了如何使用 <code>std::process::exit</code> 函数显式退出并返回一个代码，以及 <code>std::process::abort</code> 函数，用于以非零错误代码退出。</p><p class="component-content component">本章还解释了 <code>Result</code> 类型，它是一种可以成功或失败的方式，具有 <code>Ok</code> 和 <code>Err</code> 两种变体</p><div class="component-content pagebody component"><h2 id=第二章回声测试 class=pagebody-header>第二章：回声测试</h2></div><p class="component-content component">本章介绍了如何使用 Rust 创建一个类似于 <code>echo</code> 的程序，它可以将参数打印到标准输出。本章演示了如何使用 <code>clap</code> crate 来解析命令行参数，例如，如何创建一个名为 <code>text</code> 的位置参数，以及一个名为 <code>omit_newline</code> 的 flag 参数。 使用 <code>values_of_lossy</code> 获取参数值，并使用 <code>is_present</code> 判断 flag 是否存在。代码示例：</p><div class="component-content pagebody component code"><div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> clap::{App, Arg};
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> matches <span style=color:#f92672>=</span> App::new(<span style=color:#e6db74>&#34;echo&#34;</span>)
</span></span><span style=display:flex><span>        .arg(Arg::with_name(<span style=color:#e6db74>&#34;text&#34;</span>).multiple(<span style=color:#66d9ef>true</span>).required(<span style=color:#66d9ef>true</span>))
</span></span><span style=display:flex><span>        .arg(Arg::with_name(<span style=color:#e6db74>&#34;omit_newline&#34;</span>).short(<span style=color:#e6db74>&#34;n&#34;</span>))
</span></span><span style=display:flex><span>        .get_matches();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> text <span style=color:#f92672>=</span> matches.values_of_lossy(<span style=color:#e6db74>&#34;text&#34;</span>).unwrap();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> omit_newline <span style=color:#f92672>=</span> matches.is_present(<span style=color:#e6db74>&#34;omit_newline&#34;</span>);
</span></span><span style=display:flex><span>    print!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}{}</span><span style=color:#e6db74>&#34;</span>, text.join(<span style=color:#e6db74>&#34; &#34;</span>), <span style=color:#66d9ef>if</span> omit_newline { <span style=color:#e6db74>&#34;&#34;</span> } <span style=color:#66d9ef>else</span> { <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> });
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></div><p class="component-content component">本章还介绍了如何编写测试用例，例如使用 <code>assert_eq!</code> 来验证程序的输出是否与预期一致。书中使用了 <code>Result</code> 类型来处理测试中的错误，其中 <code>Ok</code> 表示成功，<code>Err</code> 表示错误。 使用 <code>Box</code> 指示错误将存在于堆上的指针中，<code>dyn</code> 表示对 <code>std::error::Error</code> trait 的方法调用是动态分发的。</p><div class="component-content pagebody component"><h2 id=第三章走猫步 class=pagebody-header>第三章：走猫步</h2></div><p class="component-content component">本章讲解如何使用 Rust 实现一个类似 <code>cat</code> 的程序，它可以将多个文件的内容连接到一个文件中。本章介绍了如何使用 <code>std::error::Error</code> trait 来表示错误值，并创建自定义的 <code>MyResult</code> 类型。<code>run</code> 函数接受一个 <code>Config</code> 参数，该参数包含文件列表和用于行编号的选项。本章还演示了如何使用 <code>clap</code> crate 定义命令行参数，例如使用 <code>Arg::with_name</code> 函数来定义输入文件参数和行号选项。还使用了 <code>const</code> 关键字来定义全局常量。
本章还介绍了如何使用 <code>Iterator::enumerate</code> 方法获取元素的索引和值，以及如何使用 <code>Box</code> 指向文件句柄以读取标准输入或常规文件。</p><div class="component-content pagebody component code"><div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Parser)]</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[command(author, version, about)]</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>/// Rust version of `cat`
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Args</span> {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// Input file(s)
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#75715e>#[arg(value_name = </span><span style=color:#e6db74>&#34;FILE&#34;</span><span style=color:#75715e>, default_value = </span><span style=color:#e6db74>&#34;-&#34;</span><span style=color:#75715e>)]</span>
</span></span><span style=display:flex><span>    files: Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// Number lines
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#75715e>#[arg(
</span></span></span><span style=display:flex><span><span style=color:#75715e>        short(&#39;n&#39;),
</span></span></span><span style=display:flex><span><span style=color:#75715e>        long(</span><span style=color:#e6db74>&#34;number&#34;</span><span style=color:#75715e>),
</span></span></span><span style=display:flex><span><span style=color:#75715e>        conflicts_with(</span><span style=color:#e6db74>&#34;number_nonblank_lines&#34;</span><span style=color:#75715e>)
</span></span></span><span style=display:flex><span><span style=color:#75715e>    )]</span>
</span></span><span style=display:flex><span>    number_lines: <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// Number non-blank lines
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#75715e>#[arg(short(&#39;b&#39;), long(</span><span style=color:#e6db74>&#34;number-nonblank&#34;</span><span style=color:#75715e>))]</span>
</span></span><span style=display:flex><span>    number_nonblank_lines: <span style=color:#66d9ef>bool</span>,
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></div><div class="component-content pagebody component"><h2 id=第四章头痛 class=pagebody-header>第四章：头痛</h2></div><p class="component-content component">本章介绍了如何使用 Rust 实现一个类似 <code>head</code> 的程序，它可以显示文件的前几行或前几个字节。本章首先介绍了如何编写<strong>单元测试</strong>来检查 <code>parse_positive_int</code> 函数，该函数用于将字符串解析为正整数。使用了 <code>unimplemented!</code> macro 来标记尚未实现的功能，以及 <code>panic!</code> macro 来终止程序。书中还使用了 <code>match</code> 表达式来进行模式匹配。本章还演示了如何使用 <code>App::new</code> 和 <code>Arg::with_name</code> 定义命令行参数，包括 <code>lines</code> 和 <code>bytes</code> 参数，以及如何使用 <code>conflicts_with</code> 来指定参数之间的冲突关系。代码示例：</p><div class="component-content pagebody component code"><div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Parser, Debug)]</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#[command(author, version, about)]</span>
</span></span><span style=display:flex><span><span style=color:#e6db74>/// Rust version of `head`
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Args</span> {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// Input file(s)
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#75715e>#[arg(default_value = </span><span style=color:#e6db74>&#34;-&#34;</span><span style=color:#75715e>, value_name = </span><span style=color:#e6db74>&#34;FILE&#34;</span><span style=color:#75715e>)]</span>
</span></span><span style=display:flex><span>    files: Vec<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// Number of lines
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#75715e>#[arg(
</span></span></span><span style=display:flex><span><span style=color:#75715e>        short(&#39;n&#39;),
</span></span></span><span style=display:flex><span><span style=color:#75715e>        long,
</span></span></span><span style=display:flex><span><span style=color:#75715e>        default_value = </span><span style=color:#e6db74>&#34;10&#34;</span><span style=color:#75715e>,
</span></span></span><span style=display:flex><span><span style=color:#75715e>        value_name = </span><span style=color:#e6db74>&#34;LINES&#34;</span><span style=color:#75715e>,
</span></span></span><span style=display:flex><span><span style=color:#75715e>        value_parser = clap::value_parser!(u64).range(1..)
</span></span></span><span style=display:flex><span><span style=color:#75715e>    )]</span>
</span></span><span style=display:flex><span>    lines: <span style=color:#66d9ef>u64</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// Number of bytes
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    <span style=color:#75715e>#[arg(
</span></span></span><span style=display:flex><span><span style=color:#75715e>        short(&#39;c&#39;),
</span></span></span><span style=display:flex><span><span style=color:#75715e>        long,
</span></span></span><span style=display:flex><span><span style=color:#75715e>        value_name = </span><span style=color:#e6db74>&#34;BYTES&#34;</span><span style=color:#75715e>,
</span></span></span><span style=display:flex><span><span style=color:#75715e>        conflicts_with(</span><span style=color:#e6db74>&#34;lines&#34;</span><span style=color:#75715e>),
</span></span></span><span style=display:flex><span><span style=color:#75715e>        value_parser = clap::value_parser!(u64).range(1..)
</span></span></span><span style=display:flex><span><span style=color:#75715e>    )]</span>
</span></span><span style=display:flex><span>    bytes: Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u64</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></div><p class="component-content component">书中介绍了如何使用下划线 <code>_</code> 来表示不使用的变量，如何在类型注解中使用下划线来让编译器推断类型，以及如何使用<strong>turbofish</strong> <code>::&lt;></code> 操作符来显式指定类型。本章还介绍了如何使用 <code>BufRead::read_line</code> 来读取文件行，以及如何使用 <code>take</code> 方法来限制选择的元素数量。</p><div class="component-content pagebody component"><h2 id=第五章对妈妈说的话 class=pagebody-header>第五章：对妈妈说的话</h2></div><p class="component-content component">本章介绍了如何使用 Rust 实现一个类似 <code>wc</code> 的程序，它可以统计文件或标准输入的行数、字数和字节数。本章介绍了如何使用 <code>if let</code> 表达式来处理 <code>Result</code> 类型，以及如何使用 <code>std::process::exit</code> 来终止程序并返回错误代码。定义了 <code>Config</code> 结构体来表示命令行参数。还演示了如何使用 <code>App::new</code> 和 <code>Arg::with_name</code> 定义命令行参数，包括 <code>files</code>，<code>words</code>，<code>bytes</code>，<code>chars</code> 和 <code>lines</code> 参数，以及如何使用 <code>multiple</code> 和 <code>default_value</code> 来指定参数的属性。
本章还介绍了如何使用 <code>Iterator::all</code> 方法来检查所有值是否都为 false，以及如何使用<strong>闭包</strong>来作为参数传递给其他函数。代码示例：</p><div class="component-content pagebody component code"><div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>if</span> [lines, words, bytes, chars].iter().all(<span style=color:#f92672>|</span>v<span style=color:#f92672>|</span> <span style=color:#f92672>!</span>v) {
</span></span><span style=display:flex><span>    lines <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    words <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>    bytes <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></div><p class="component-content component">本章还介绍了如何使用 <code>BufRead</code> trait 来读取文件，以及如何使用 <code>impl BufRead</code> 来指定函数参数的 trait bound。还介绍了如何使用 <code>std::io::Cursor</code> 来创建用于测试的虚拟文件句柄。</p><div class="component-content pagebody component"><h2 id=第六章独一无二 class=pagebody-header>第六章：独一无二</h2></div><p class="component-content component">本章介绍了如何使用 Rust 实现一个类似 <code>uniq</code> 的程序，它可以查找文件或标准输入中的唯一行。 本章讨论了如何<strong>写入文件或标准输出</strong>，如何使用<strong>闭包捕获变量</strong>，以及如何应用<strong>DRY</strong>（不要重复自己）原则。本章还介绍了如何使用 <code>Write</code> trait 和 <code>write!</code> 和 <code>writeln!</code> macros，以及如何使用临时文件。 使用 <code>match</code> 表达式来处理输入文件是标准输入还是文件。 本章还使用了 <code>loop</code> 表达式来进行循环读取。
本章还介绍了<strong>闭包和函数的区别</strong>，以及如何使用闭包来<strong>捕获变量</strong>。还介绍了如何使用 <code>Box&lt;dyn Write></code> 来表示可写入类型，并根据命令行参数来决定是写入文件还是标准输出。代码示例：</p><div class="component-content pagebody component code"><div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> print <span style=color:#f92672>=</span> <span style=color:#f92672>|</span>num: <span style=color:#66d9ef>u64</span>, text: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span><span style=color:#f92672>|</span> -&gt; Result<span style=color:#f92672>&lt;</span>()<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> num <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> args.count {
</span></span><span style=display:flex><span>                write!(out_file, <span style=color:#e6db74>&#34;{num:&gt;4} {text}&#34;</span>)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                write!(out_file, <span style=color:#e6db74>&#34;{text}&#34;</span>)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>        Ok(())
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> line <span style=color:#f92672>=</span> String::new();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> previous <span style=color:#f92672>=</span> String::new();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> count: <span style=color:#66d9ef>u64</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>loop</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> bytes <span style=color:#f92672>=</span> file.read_line(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> line)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> bytes <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> line.trim_end() <span style=color:#f92672>!=</span> previous.trim_end() {
</span></span><span style=display:flex><span>            print(count, <span style=color:#f92672>&amp;</span>previous)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>            previous <span style=color:#f92672>=</span> line.clone();
</span></span><span style=display:flex><span>            count <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        line.clear();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    print(count, <span style=color:#f92672>&amp;</span>previous)<span style=color:#f92672>?</span>;</span></span></code></pre></div></div></div><div class="component-content pagebody component"><h2 id=第七章见者有份 class=pagebody-header>第七章：见者有份</h2></div><p class="component-content component">本章介绍了如何使用 Rust 实现一个类似 <code>find</code> 的程序，它可以递归搜索目录并查找符合特定条件的文件。本章介绍了如何使用 <code>enum</code> 类型来表示不同的条目类型，例如目录、文件和链接。 还定义了 <code>Config</code> 结构体来表示命令行参数，包括搜索路径，名称模式和条目类型。本章还介绍了如何在<strong>文件 glob 和正则表达式中使用点号 (.) 和星号 (*) 的不同含义</strong>。本章使用了 <code>Regex::new</code> 函数来创建正则表达式，并介绍了**<code>^</code> 和 <code>$</code>** 的作用，分别用于匹配字符串的开头和结尾。
本章还介绍了如何使用 <code>WalkDir</code> 来递归搜索目录结构，并使用 <code>DirEntry</code> 值来查找文件，目录和链接。 还演示了如何使用链式调用，如 <code>any</code>，<code>filter</code>，<code>map</code> 和 <code>filter_map</code> 来处理迭代器。 代码示例：</p><div class="component-content pagebody component code"><div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#66d9ef>for</span> path <span style=color:#66d9ef>in</span> <span style=color:#f92672>&amp;</span>args.paths {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> entries <span style=color:#f92672>=</span> WalkDir::new(path)
</span></span><span style=display:flex><span>            .into_iter()
</span></span><span style=display:flex><span>            .filter_map(<span style=color:#f92672>|</span>e<span style=color:#f92672>|</span> <span style=color:#66d9ef>match</span> e {
</span></span><span style=display:flex><span>                Err(e) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    eprintln!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{e}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>                    None
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                Ok(entry) <span style=color:#f92672>=&gt;</span> Some(entry),
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            .filter(type_filter)
</span></span><span style=display:flex><span>            .filter(name_filter)
</span></span><span style=display:flex><span>            .map(<span style=color:#f92672>|</span>entry<span style=color:#f92672>|</span> entry.path().display().to_string())
</span></span><span style=display:flex><span>            .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, entries.join(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>));
</span></span><span style=display:flex><span>    }</span></span></code></pre></div></div></div><div class="component-content pagebody component"><h2 id=第八章削发 class=pagebody-header>第八章：削发</h2></div><p class="component-content component">本章介绍了如何使用 Rust 实现一个类似 <code>cut</code> 的程序，它可以从文件或标准输入中提取文本。 本章介绍了如何使用单元测试来验证 <code>parse_pos</code> 函数，该函数用于解析文本位置，并支持逗号分隔的列表以及范围。定义了多个测试用例来涵盖不同的情况，包括错误和正确的情况，还使用了 <code>assert!</code> 和 <code>assert_eq!</code> 来验证测试结果。 本章还介绍了如何使用正则表达式来匹配数字和范围，并使用 <code>collect</code> 方法来将结果收集到向量中。
本章介绍了如何使用 <code>Arg::conflicts_with_all</code> 来指定参数之间的冲突关系，例如 <code>fields</code>, <code>bytes</code> 和 <code>chars</code> 参数。还使用了 <code>Vec::first</code> 方法来选择向量的第一个元素。 本章还提供了如何实现 <code>extract_chars</code> 和 <code>extract_bytes</code> 函数的示例，用于提取字符串中的字符和字节。还介绍了如何使用 <code>csv</code> crate 来解析和创建分隔文本。</p><div class="component-content pagebody component code"><div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>    <span style=color:#66d9ef>for</span> filename <span style=color:#66d9ef>in</span> <span style=color:#f92672>&amp;</span>args.files {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> open(filename) {
</span></span><span style=display:flex><span>            Err(err) <span style=color:#f92672>=&gt;</span> eprintln!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{filename}</span><span style=color:#e6db74>: </span><span style=color:#e6db74>{err}</span><span style=color:#e6db74>&#34;</span>),
</span></span><span style=display:flex><span>            Ok(file) <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>match</span> <span style=color:#f92672>&amp;</span>extract {
</span></span><span style=display:flex><span>                Extract::Fields(field_pos) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> reader <span style=color:#f92672>=</span> ReaderBuilder::new()
</span></span><span style=display:flex><span>                        .delimiter(delimiter)
</span></span><span style=display:flex><span>                        .has_headers(<span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>                        .from_reader(file);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> wtr <span style=color:#f92672>=</span> WriterBuilder::new()
</span></span><span style=display:flex><span>                        .delimiter(delimiter)
</span></span><span style=display:flex><span>                        .from_writer(io::stdout());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> record <span style=color:#66d9ef>in</span> reader.records() {
</span></span><span style=display:flex><span>                        wtr.write_record(extract_fields(
</span></span><span style=display:flex><span>                            <span style=color:#f92672>&amp;</span>record<span style=color:#f92672>?</span>, field_pos,
</span></span><span style=display:flex><span>                        ))<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                Extract::Bytes(byte_pos) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> line <span style=color:#66d9ef>in</span> file.lines() {
</span></span><span style=display:flex><span>                        println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, extract_bytes(<span style=color:#f92672>&amp;</span>line<span style=color:#f92672>?</span>, byte_pos));
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                Extract::Chars(char_pos) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> line <span style=color:#66d9ef>in</span> file.lines() {
</span></span><span style=display:flex><span>                        println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, extract_chars(<span style=color:#f92672>&amp;</span>line<span style=color:#f92672>?</span>, char_pos));
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            },
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }</span></span></code></pre></div></div></div><div class="component-content pagebody component"><h2 id=第九章抓手 class=pagebody-header>第九章：抓手</h2></div><p class="component-content component">本章介绍了如何使用 Rust 实现一个类似 <code>grep</code> 的程序，它可以查找匹配给定正则表达式的输入行。本章介绍了如何使用 <code>RegexBuilder</code> 来创建正则表达式，并使用 <code>case_insensitive</code> 方法来进行<strong>大小写不敏感</strong>的匹配。还演示了如何使用 <code>Result::map_err</code> 来创建错误消息，并介绍了 <strong><code>grep</code> 的正则表达式语法</strong>， 包括基本正则表达式和扩展正则表达式。还介绍了如何使用 <code>WalkDir</code> 来递归查找文件，与第七章类似。
本章还介绍了如何使用**<code>BitXor</code>** 按位异或运算符来替换更复杂的<strong>逻辑 AND 和 OR</strong> 组合。代码示例：</p><div class="component-content pagebody component code"><div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>if</span> (pattern.is_match(<span style=color:#f92672>&amp;</span>line) <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>invert_match) <span style=color:#f92672>||</span> (<span style=color:#f92672>!</span>pattern.is_match(<span style=color:#f92672>&amp;</span>line) <span style=color:#f92672>&amp;&amp;</span> invert_match) {
</span></span><span style=display:flex><span>    matches.push(line.clone());
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// 等价于
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> pattern.is_match(<span style=color:#f92672>&amp;</span>line) <span style=color:#f92672>^</span> <span style=color:#f92672>!</span>invert_match {
</span></span><span style=display:flex><span>    matches.push(line.clone());
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></div><div class="component-content pagebody component"><h2 id=第十章天下为公 class=pagebody-header>第十章：天下为公</h2></div><p class="component-content component">本章介绍了如何使用 Rust 实现一个类似 <code>comm</code> 的程序，它可以读取两个文件并报告两个文件中<strong>共有和独有的行</strong>。 本章介绍了 <code>Config</code> 结构体，其中包含两个输入文件名，以及控制输出列和比较敏感度的布尔值。还演示了如何使用 <code>App::new</code> 和 <code>Arg::with_name</code> 定义命令行参数，并使用 <code>required</code> 来指定参数是必需的。 代码示例：</p><div class="component-content pagebody component code"><div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_args</span>() -&gt; <span style=color:#a6e22e>MyResult</span><span style=color:#f92672>&lt;</span>Config<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> matches <span style=color:#f92672>=</span> App::new(<span style=color:#e6db74>&#34;commr&#34;</span>)
</span></span><span style=display:flex><span>        .arg(Arg::with_name(<span style=color:#e6db74>&#34;file1&#34;</span>).required(<span style=color:#66d9ef>true</span>))
</span></span><span style=display:flex><span>        .arg(Arg::with_name(<span style=color:#e6db74>&#34;file2&#34;</span>).required(<span style=color:#66d9ef>true</span>))
</span></span><span style=display:flex><span>        .arg(Arg::with_name(<span style=color:#e6db74>&#34;suppress_col1&#34;</span>).short(<span style=color:#e6db74>&#34;1&#34;</span>))
</span></span><span style=display:flex><span>        .arg(Arg::with_name(<span style=color:#e6db74>&#34;suppress_col2&#34;</span>).short(<span style=color:#e6db74>&#34;2&#34;</span>))
</span></span><span style=display:flex><span>        .arg(Arg::with_name(<span style=color:#e6db74>&#34;suppress_col3&#34;</span>).short(<span style=color:#e6db74>&#34;3&#34;</span>))
</span></span><span style=display:flex><span>        .arg(Arg::with_name(<span style=color:#e6db74>&#34;insensitive&#34;</span>).short(<span style=color:#e6db74>&#34;i&#34;</span>))
</span></span><span style=display:flex><span>        .arg(Arg::with_name(<span style=color:#e6db74>&#34;delimiter&#34;</span>).short(<span style=color:#e6db74>&#34;d&#34;</span>).default_value(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>&#34;</span>))
</span></span><span style=display:flex><span>        .get_matches();
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}</span></span></code></pre></div></div></div><p class="component-content component">本章还使用了 <code>if !config.suppress_col1</code> ，即双重否定在理解上更困难，建议使用更积极的命名方法，例如 <code>do_something</code>。</p><div class="component-content pagebody component"><h2 id=第十一章尾随其后 class=pagebody-header>第十一章：尾随其后</h2></div><p class="component-content component">本章介绍了如何使用 Rust 实现一个类似 <code>tail</code> 的程序，它可以显示文件的最后几行或最后几个字节。本章介绍了如何使用 <code>enum</code> 类型来表示不同的取值，例如 <code>PlusZero</code> 和 <code>TakeNum</code>，以及如何使用 <code>i64</code> 类型来存储正数和负数。 本章使用了正则表达式来匹配数字和正负号，并使用了 <code>map_or</code> 方法来获取捕获组的值，以及 <code>format!</code> 方法来格式化字符串。 代码示例：</p><div class="component-content pagebody component code"><div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>run</span>(args: <span style=color:#a6e22e>Args</span>) -&gt; Result<span style=color:#f92672>&lt;</span>()<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> lines <span style=color:#f92672>=</span> parse_num(args.lines)
</span></span><span style=display:flex><span>        .map_err(<span style=color:#f92672>|</span>e<span style=color:#f92672>|</span> anyhow!(<span style=color:#e6db74>&#34;illegal line count -- {e}&#34;</span>))<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> bytes <span style=color:#f92672>=</span> args
</span></span><span style=display:flex><span>        .bytes
</span></span><span style=display:flex><span>        .map(parse_num)
</span></span><span style=display:flex><span>        .transpose()
</span></span><span style=display:flex><span>        .map_err(<span style=color:#f92672>|</span>e<span style=color:#f92672>|</span> anyhow!(<span style=color:#e6db74>&#34;illegal byte count -- {e}&#34;</span>))<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> num_files <span style=color:#f92672>=</span> args.files.len();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (file_num, filename) <span style=color:#66d9ef>in</span> args.files.iter().enumerate() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>match</span> File::open(filename) {
</span></span><span style=display:flex><span>            Err(err) <span style=color:#f92672>=&gt;</span> eprintln!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{filename}</span><span style=color:#e6db74>: </span><span style=color:#e6db74>{err}</span><span style=color:#e6db74>&#34;</span>),
</span></span><span style=display:flex><span>            Ok(file) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>args.quiet <span style=color:#f92672>&amp;&amp;</span> num_files <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>                    println!(
</span></span><span style=display:flex><span>                        <span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>==&gt; </span><span style=color:#e6db74>{filename}</span><span style=color:#e6db74> &lt;==&#34;</span>,
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> file_num <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> { <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> } <span style=color:#66d9ef>else</span> { <span style=color:#e6db74>&#34;&#34;</span> },
</span></span><span style=display:flex><span>                    );
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> (total_lines, total_bytes) <span style=color:#f92672>=</span> count_lines_bytes(filename)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>let</span> file <span style=color:#f92672>=</span> BufReader::new(file);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(num_bytes) <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>bytes {
</span></span><span style=display:flex><span>                    print_bytes(file, num_bytes, total_bytes)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    print_lines(file, <span style=color:#f92672>&amp;</span>lines, total_lines)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Ok(())
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></div><p class="component-content component">本章还介绍了如何使用 <code>i64::wrapping_neg</code> 来计算负数，并介绍了泛型函数和 trait bounds 的用法，例如 <code>Read + Seek</code>。 还使用了 <code>OnceCell</code> 来创建一个静态正则表达式。</p><div class="component-content pagebody component"><h2 id=第十二章天选之子 class=pagebody-header>第十二章：天选之子</h2></div><p class="component-content component">本章介绍了如何使用 Rust 实现一个类似 <code>fortune</code> 的程序，它可以从文本数据库中随机选择引语或琐事。本章介绍了如何使用 <code>strfile</code> 程序来创建索引文件，以及如何使用 <code>head</code> 命令来查看文件的结构。 本章介绍了如何使用 <code>RegexBuilder</code> 创建正则表达式，并定义了 <code>Config</code> 结构体，包括资源列表，模式和随机种子。 还介绍了如何使用 <code>map</code> 和 <code>transpose</code> 方法来处理 <code>Option</code> 和 <code>Result</code> 类型，以及如何使用 <code>unwrap</code> 方法来获取 <code>Option</code> 或 <code>Result</code> 的值。<br>本章还介绍了如何使用 <code>SliceRandom</code> trait 来随机选择元素，并使用了 <code>SeedableRng</code> trait 来创建可重现的随机数生成器。代码示例：</p><div class="component-content pagebody component code"><div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> rand::prelude::SliceRandom;
</span></span><span style=display:flex><span><span style=color:#66d9ef>use</span> rand::{rngs::StdRng, SeedableRng};
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>pick_fortune</span>(fortunes: <span style=color:#66d9ef>&amp;</span>[Fortune], seed: Option<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u64</span><span style=color:#f92672>&gt;</span>) -&gt; Option<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> rng <span style=color:#f92672>=</span> <span style=color:#66d9ef>match</span> seed {
</span></span><span style=display:flex><span>         Some(seed) <span style=color:#f92672>=&gt;</span> StdRng::seed_from_u64(seed),
</span></span><span style=display:flex><span>         _ <span style=color:#f92672>=&gt;</span> StdRng::from_entropy(),
</span></span><span style=display:flex><span>     };
</span></span><span style=display:flex><span>     fortunes.choose(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> rng).map(<span style=color:#f92672>|</span>f<span style=color:#f92672>|</span> f.text.clone())
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></div><div class="component-content pagebody component"><h2 id=第十三章岁月如歌 class=pagebody-header>第十三章：岁月如歌</h2></div><p class="component-content component">本章介绍了如何使用 Rust 实现一个类似 <code>cal</code> 的程序，它可以显示日历。 本章使用了 <code>chrono</code> crate 来处理日期和时间，包括 <code>NaiveDate</code> 类型。 本章还介绍了如何使用 <code>App::conflicts_with_all</code> 来指定参数之间的冲突关系，例如 <code>month</code> 和 <code>year</code> 参数，以及 <code>show_current_year</code> 参数。 本章还使用了闭包来判断某天是否是今天，以及如何使用 <code>Style::reverse</code> 来高亮显示今天的日期。还使用了 <code>format!</code> 宏来格式化输出。</p><div class="component-content pagebody component code"><div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>run</span>(args: <span style=color:#a6e22e>Args</span>) -&gt; Result<span style=color:#f92672>&lt;</span>()<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> today <span style=color:#f92672>=</span> Local::now().date_naive();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> month <span style=color:#f92672>=</span> args.month.map(parse_month).transpose()<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> year <span style=color:#f92672>=</span> args.year;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> args.show_current_year {
</span></span><span style=display:flex><span>        month <span style=color:#f92672>=</span> None;
</span></span><span style=display:flex><span>        year <span style=color:#f92672>=</span> Some(today.year());
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> month.is_none() <span style=color:#f92672>&amp;&amp;</span> year.is_none() {
</span></span><span style=display:flex><span>        month <span style=color:#f92672>=</span> Some(today.month());
</span></span><span style=display:flex><span>        year <span style=color:#f92672>=</span> Some(today.year());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> year <span style=color:#f92672>=</span> year.unwrap_or(today.year());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> month {
</span></span><span style=display:flex><span>        Some(month) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> lines <span style=color:#f92672>=</span> format_month(year, month, <span style=color:#66d9ef>true</span>, today);
</span></span><span style=display:flex><span>            println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, lines.join(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        None <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{year:&gt;32}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>let</span> months: Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1</span><span style=color:#f92672>..=</span><span style=color:#ae81ff>12</span>)
</span></span><span style=display:flex><span>                .map(<span style=color:#f92672>|</span>month<span style=color:#f92672>|</span> format_month(year, month, <span style=color:#66d9ef>false</span>, today))
</span></span><span style=display:flex><span>                .collect();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (i, chunk) <span style=color:#66d9ef>in</span> months.chunks(<span style=color:#ae81ff>3</span>).enumerate() {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> [m1, m2, m3] <span style=color:#f92672>=</span> chunk {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> lines <span style=color:#66d9ef>in</span> izip!(m1, m2, m3) {
</span></span><span style=display:flex><span>                        println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}{}{}</span><span style=color:#e6db74>&#34;</span>, lines.<span style=color:#ae81ff>0</span>, lines.<span style=color:#ae81ff>1</span>, lines.<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>3</span> {
</span></span><span style=display:flex><span>                        println!();
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Ok(())
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></div><div class="component-content pagebody component"><h2 id=第十四章条分缕析 class=pagebody-header>第十四章：条分缕析</h2></div><p class="component-content component">本章介绍了如何使用 Rust 实现一个类似 <code>ls</code> 的程序，它可以显示文件和目录的信息。本章介绍了如何使用 <code>enum</code> 类型来表示用户、组和其他所有者，以及如何使用<strong>位掩码</strong>来检查文件权限。还介绍了如何使用 <code>metadata::mode</code> 来获取文件的权限，并介绍了八进制表示法。 本章还介绍了如何使用 <code>Owner</code> 枚举来表示所有者，并使用 <code>impl</code> 块定义了 <code>masks</code> 方法来获取权限掩码。 代码示例：</p><div class="component-content pagebody component code"><div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>run</span>(args: <span style=color:#a6e22e>Args</span>) -&gt; Result<span style=color:#f92672>&lt;</span>()<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> paths <span style=color:#f92672>=</span> find_files(<span style=color:#f92672>&amp;</span>args.paths, args.show_hidden)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> args.long {
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, format_output(<span style=color:#f92672>&amp;</span>paths)<span style=color:#f92672>?</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> path <span style=color:#66d9ef>in</span> paths {
</span></span><span style=display:flex><span>            println!(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, path.display());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    Ok(())
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></div><p class="component-content component">本章介绍了如何使用<strong>三斜杠</strong> <code>///</code> 来创建<strong>文档注释</strong>，以及如何使用 <code>cargo doc</code> 来生成代码文档。还介绍了如何使用 <code>tabular::Table</code> crate 来创建表格输出。</p><p class="component-content component"><strong>尾声</strong></p><p class="component-content component">作者在尾声中鼓励读者继续学习和实践，并尝试使用不同的编程语言来编写和重写这些程序。作者还希望读者通过编写优秀的软件来让世界变得更美好。</p></div><div id=comments class=utterances><script src=https://utteranc.es/client.js repo=smallnest/booslip.rpcx.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></article></section></main><script>var script=document.createElement("script");script.src="https://booslip.rpcx.io/js/initPost.js",document.head.appendChild(script)</script><div class=footer-main><div class="content-body footer-wraper"><div class=footer-box><div class=foot-nav><div class=foot-nav-items><div class=item><div class=logo></div><div class=email>Email: <a href=mailto:smallnest@gmail.com>smallnest@gmail.com</a></div></div><div class="item community"><div class=item-title>社交媒体</div><a href=https://github.com/smallnest target=_blank>Github</a></div><div class="item resources"><div class=item-title>友链</div><a href=https://colobu.com/ target=_blank>鸟窝</a></div></div></div><div class=bottom><div class="item copyright">鸟窝 &copy; 2025 All Rights Reserved.</div></div></div></div></div></body></html>