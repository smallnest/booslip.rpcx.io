<!doctype html><html class="js no-touch progressive-image no-reduced-motion progressive" lang=zh-hans><head><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=icon href=/img/favicon.ico><meta name=keyword content><meta property="og:url" content="https://booslip.rpcx.io/posts/learn-concurrent-programming-with-go/"><meta property="og:site_name" content="竹简书摘"><meta property="og:title" content="Learn Concurrent Programming With Go"><meta property="og:description" content="学习 Go 并发编程"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-01T10:09:38+08:00"><meta property="article:modified_time" content="2025-01-01T10:09:38+08:00"><title>Learn Concurrent Programming With Go</title>
<link rel=canonical href=/posts/learn-concurrent-programming-with-go/><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/custom.css><link rel=stylesheet href=/css/search.css><link href="https://fonts.googleapis.com/css?family=Bree+Serif" rel=stylesheet><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?c80136b2ed102610dcafb84941e8df30",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head></head><body class=page-article><header><nav class=nav><div class=nav-wrapper><div class=nav-content-wrapper><div class=nav-content><a href=/ class=nav-title>竹简书摘</a><div class=nav-menu><div class=nav-item-wrapper><a href=/posts class=nav-item-content>书摘</a></div><div class=nav-item-wrapper><a href=/index.xml class=nav-item-content target=_blank>RSS</a></div></div></div></div></div></nav><script>function toggleSearchModal(){const t=`
    <div class="modal-body">
      <div id="autocomplete" onclick="event.stopPropagation();"></div>
    </div>
    `,e=document.querySelector("#modal-wrapper");if(e)document.body.removeAttribute("style"),document.body.removeChild(e);else{const e=document.createElement("div");document.body.setAttribute("style","overflow: hidden;"),e.setAttribute("id","modal-wrapper"),e.setAttribute("onclick","toggleSearchModal()"),e.innerHTML=t;const n=document.createElement("script");n.setAttribute("src","https://booslip.rpcx.io/js/algolia.js"),e.appendChild(n),document.body.append(e)}}</script></header><main id=main class=main><section><article class=article><div class=article-header><div class="category component"><div class=component-content><div class=category-eyebrow><span class="category-eyebrow__category category_original"></span><span class=category-eyebrow__date>2025年1月1日</span></div></div></div><div class="pagetitle component"><div class=component-content><h1 class=hero-headline>Learn Concurrent Programming With Go</h1></div></div><div class="component article-subhead"><div class=component-content>学习 Go 并发编程</div></div><div class="tagssheet component"><div class=component-content><a href=/tags/ class=tag></a></div></div></div><div class="book-card component"><div class=book-cover><img data-src=/covers/Learn-Concurrent-Programming-with-Go.png alt=书籍封面></div><div class=book-info><h1 class=book-title>Learn Concurrent Programming With Go</h1><div class=book-meta><span>作者：James Cutajar</span>
<span>出版日期：2024-01-19</span>
<span>出版社：Manning</span></div><div class=book-description>书中详细介绍了Go语言的并发编程，涵盖了并发编程的基础知识、常见的并发模式（如管道和工作池）、线程间的通信方式（内存共享和消息传递）、以及如何避免死锁和竞争条件等内容。 书中使用了大量的代码示例和图表，帮助读者理解并掌握Go语言中的并发编程技巧，并提升软件性能和响应速度。</div></div></div><div class=pagebody><div class="component-content component"><ul><li><p class="component-content component"><strong>第一章：步入并发编程</strong></p><div class="component-content component"><ul><li><strong>并发（Concurrency）</strong> 是一种程序代码的属性，它将指令分组为独立的任务，并规划任务之间的边界和同步点。并发存在于我们日常生活和工作中，例如多人同时在线购物或汽车行驶。</li><li><strong>并行（Parallelism）</strong> 是程序执行的属性，它指同时执行多个任务。并行是并发的子集，只有并发程序才能并行执行。</li><li><strong>Go 语言</strong> 在设计时就考虑了高性能的并发，因此是学习并发编程的理想选择。Go 使用 <strong>goroutine</strong> 作为基本的并发执行单元，它是一种轻量级的用户级线程，由 Go 的运行时管理。</li><li>Go 提供了两种并发模型：<strong>通信顺序进程（CSP）</strong> 模型和传统的 <strong>内存共享</strong> 模型。CSP 模型通过消息传递进行通信，而内存共享模型使用互斥锁和条件变量等原语进行同步。</li></ul></div></li><li><p class="component-content component"><strong>第二章：处理线程</strong></p><div class="component-content component"><ul><li><strong>操作系统</strong> 将作业的状态分为多个阶段，包括等待执行、正在执行、等待 I/O 等。</li><li><strong>绿色线程</strong> （green threads） 是用户级线程的一种实现，但 Go 的 goroutine 可以充分利用多核 CPU。</li><li><strong>并发</strong> 是关于如何同时做多件事的计划，而 <strong>并行</strong> 是关于同时执行多件事。</li><li>即使只有一个处理器，通过频繁的 <strong>上下文切换</strong> ，也可以实现伪并行执行。</li></ul></div></li><li><p class="component-content component"><strong>第三章：使用内存共享进行线程通信</strong></p><div class="component-content component"><ul><li><strong>竞态条件</strong> （race condition） 指多个 goroutine 并发访问共享资源时，由于执行顺序不确定而导致结果错误。</li><li><strong>原子操作</strong> （atomic operation） 是不可中断的操作，可以避免竞态条件。</li><li>为了避免竞态条件，需要进行 <strong>同步</strong> 和 <strong>通信</strong> 。Go 提供了多种同步工具，例如互斥锁（mutex）和条件变量。</li><li>Go 的竞态检测器可以帮助我们找到代码中的竞态条件。</li></ul></div></li><li><p class="component-content component"><strong>第四章：使用互斥锁进行同步</strong></p><div class="component-content component"><ul><li><strong>互斥锁（Mutex）</strong> 是一种并发控制机制，它只允许一个执行单元（例如 goroutine）进入 <strong>临界区</strong>。</li><li>Go 的 <code>sync</code> 包提供了 <code>Mutex</code> 类型，它提供了 <code>Lock()</code> 和 <code>Unlock()</code> 操作来保护临界区。</li><li>当多个 goroutine 同时尝试锁定互斥锁时，只有一个 goroutine 会成功获得锁，其他 goroutine 将被挂起，直到锁被释放。</li><li><code>TryLock()</code> 操作尝试获取锁，如果锁不可用，则立即返回 <code>false</code> ，而不会阻塞。</li><li><strong>读写锁（RWMutex）</strong> 允许多个 goroutine 同时读取共享资源，但只允许一个 goroutine 写入共享资源。</li><li><strong>读优先</strong> 的读写锁可能会导致 <strong>写饥饿</strong> ，即写 goroutine 无法获得锁。</li></ul></div></li><li><p class="component-content component"><strong>第五章：条件变量和信号量</strong></p><div class="component-content component"><ul><li><strong>条件变量（Condition Variable）</strong> 提供了在互斥锁基础上额外的功能，允许 goroutine 等待特定条件发生。</li><li><code>Wait()</code> 操作会原子地释放互斥锁并挂起 goroutine 的执行。<code>Signal()</code> 或 <code>Broadcast()</code> 操作会唤醒等待在条件变量上的 goroutine。</li><li>如果调用 <code>Signal()</code> 或 <code>Broadcast()</code> 时没有 goroutine 在等待，则信号会被丢失。</li><li>可以使用条件变量实现 <strong>写优先</strong> 的读写锁，避免写饥饿。</li><li><strong>信号量（Semaphore）</strong> 用于控制允许同时执行临界区的 goroutine 的数量。信号量可以记录信号，即使没有 goroutine 在等待。</li><li><strong>二元信号量</strong> 是一种只允许一个许可证的信号量，类似于互斥锁。</li></ul></div></li><li><p class="component-content component"><strong>第六章：使用 WaitGroup 和 Barrier 进行同步</strong></p><div class="component-content component"><ul><li><strong>WaitGroup</strong> 用于等待一组任务完成。<div class="component-content component"><ul><li><code>Add(delta int)</code> 增加 WaitGroup 的计数器。</li><li><code>Done()</code> 减少 WaitGroup 的计数器。</li><li><code>Wait()</code> 阻塞直到计数器变为 0。</li></ul></div></li><li>可以使用信号量或条件变量来实现 WaitGroup。</li><li><strong>Barrier</strong> 用于同步多个 goroutine 到达一个共同点。所有 goroutine 必须都到达 barrier 才能继续执行.</li><li>可以使用条件变量来实现 Barrier.</li></ul></div></li><li><p class="component-content component"><strong>第七章：使用消息传递进行通信</strong></p><div class="component-content component"><ul><li><strong>通道（Channel）</strong> 是 goroutine 之间通信的管道，它可以是 <strong>无缓冲</strong> 的或 <strong>有缓冲</strong> 的。</li><li>使用 <code>make(chan T)</code> 创建无缓冲通道，使用 <code>make(chan T, capacity)</code> 创建有缓冲通道。</li><li><code>&lt;-</code> 操作符用于发送和接收消息，发送时通道在左边，接收时通道在右边。</li><li>无缓冲通道的发送和接收操作是同步的，发送方会阻塞直到接收方接收消息。</li><li>有缓冲通道可以在缓冲区未满时允许发送方继续发送消息。</li><li>通道可以指定发送或接收方向，例如 <code>chan&lt;- int</code> 表示只能发送的通道，<code>&lt;-chan int</code> 表示只能接收的通道。</li><li>可以使用 <code>close(channel)</code> 关闭通道，关闭后不能再向通道发送消息。</li><li>从已关闭的通道接收消息会得到通道类型的零值，例如 <code>int</code> 类型的通道返回 0.</li><li>可以使用 <code>for range</code> 循环从通道接收消息，直到通道关闭.</li><li>通道内部类似于固定大小的队列数据结构，需要使用互斥锁保护共享数据结构.</li><li>可以使用信号量来阻塞发送方或接收方，当缓冲区满时阻塞发送方，当缓冲区空时阻塞接收方.</li></ul></div></li><li><p class="component-content component"><strong>第八章：选择通道</strong></p><div class="component-content component"><ul><li><code>select</code> 语句允许一个 goroutine 从多个通道读取消息。</li><li>当多个 <code>case</code> 都准备好时，<code>select</code> 语句会随机选择一个 <code>case</code> 执行。</li><li>可以使用 <code>select</code> 语句进行 <strong>非阻塞</strong> 通道操作，当通道没有消息时，执行 <code>default</code> case。</li><li>可以将 <code>default</code> case 用于并发计算，并使用一个通道来发出停止信号.</li><li>可以将通道的 <strong>nil</strong> 值用作禁用 <code>select</code> 语句中的 <code>case</code>，从而实现动态地添加和删除通信源。</li><li>可以使用 <code>select</code> 语句将多个通道的数据合并到一个流中，这种模式称为 <strong>扇入 (fan-in)</strong>.</li><li><strong>消息传递</strong> 比 <strong>内存共享</strong> 更容易理解，代码更简洁。</li><li><strong>松耦合</strong> 的系统更容易测试和维护。</li><li>在某些情况下，内存共享可能比消息传递性能更好.</li></ul></div></li><li><p class="component-content component"><strong>第九章：使用通道的常见模式</strong></p><div class="component-content component"><ul><li><strong>哨兵值</strong> (Sentinel Value) 或 <strong>毒丸消息</strong> (Poison Pill Message) 是用于通知执行终止的预定义值.</li><li>扇出（fan-out）模式用于将一个计算的输出分发给多个并发的 goroutine.</li><li>可以使用 <code>select</code> 语句和动态通道来实现更复杂的扇入模式，动态地合并多个数据源.</li><li><code>CreateAll()</code> 和 <code>CloseAll()</code> 函数是使用动态通道时常用的辅助函数.</li></ul></div></li><li><p class="component-content component"><strong>第十章：并发模式</strong></p><div class="component-content component"><ul><li>可以使用通道在循环的每次迭代中进行并发计算.</li><li>可以使用通道和 <code>select</code> 语句实现非阻塞的工作池，避免因工作池满而阻塞客户端.</li><li>可以使用通道和映射函数实现可重用的 <strong>管道模式</strong>.</li></ul></div></li><li><p class="component-content component"><strong>第十一章：避免死锁</strong></p><div class="component-content component"><ul><li><strong>死锁</strong> 是指两个或多个 goroutine 互相等待对方释放资源而无法继续执行的情况。</li><li><strong>资源分配图</strong> （Resource Allocation Graph） 可以用于表示系统中资源的分配和请求情况.</li><li>死锁发生需要同时满足以下四个条件：互斥、等待条件、不可抢占、循环等待.</li><li>可以使用死锁检测来发现死锁，或使用死锁预防技术来避免死锁.</li><li><strong>银行家算法</strong> 可用于避免死锁，它通过动态地检查资源分配请求来确保系统处于安全状态.</li><li>可以使用 <strong>仲裁器</strong> (Arbitrator) 来避免循环等待导致的死锁，仲裁器用于控制资源的分配.</li><li>可以使用 <code>select</code> 语句来避免通道之间的循环等待导致的死锁.</li></ul></div></li><li><p class="component-content component"><strong>第十二章：原子操作，自旋锁和 Futex</strong></p><div class="component-content component"><ul><li><strong>原子变量</strong> 提供了对基本数据类型进行原子操作的能力，例如读取，写入，增加和比较.</li><li>可以使用原子变量实现计数器和互斥锁等同步机制.</li><li><strong>CompareAndSwap</strong> 函数可以原子地比较变量值并进行交换.</li><li><strong>自旋锁</strong> （spin lock） 是一种完全在用户空间实现的互斥锁，它使用循环等待来获取锁.</li><li><strong>Futex</strong> 是一种操作系统调用，允许进程在等待锁释放时减少 CPU 消耗.</li><li>可以使用 Futex 来优化互斥锁的实现，仅当有等待锁的执行单元时才调用 <code>futex_wakeup()</code>.</li><li>Go 的 <code>sync.mutex</code> 结合了原子操作，自旋锁和 Futex 等多种技术来提高性能.</li><li><code>sync.mutex</code> 有 <strong>普通模式</strong> 和 <strong>饥饿模式</strong> 两种操作模式，根据情况选择合适的模式.</li></ul></div></li></ul></div></div><div id=comments class=utterances><script src=https://utteranc.es/client.js repo=smallnest/booslip.rpcx.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></article></section></main><script>var script=document.createElement("script");script.src="https://booslip.rpcx.io/js/initPost.js",document.head.appendChild(script)</script><div class=footer-main><div class="content-body footer-wraper"><div class=footer-box><div class=foot-nav><div class=foot-nav-items><div class=item><div class=logo></div><div class=email>Email: <a href=mailto:smallnest@gmail.com>smallnest@gmail.com</a></div></div><div class="item community"><div class=item-title>社交媒体</div><a href=https://github.com/smallnest target=_blank>Github</a></div><div class="item resources"><div class=item-title>友链</div><a href=https://colobu.com/ target=_blank>鸟窝</a></div></div></div><div class=bottom><div class="item copyright">鸟窝 &copy; 2025 All Rights Reserved.</div></div></div></div></div></body></html>