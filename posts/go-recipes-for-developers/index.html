<!doctype html><html class="js no-touch progressive-image no-reduced-motion progressive" lang=zh-hans><head><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=icon href=/img/favicon.ico><meta name=keyword content><meta property="og:url" content="https://booslip.rpcx.io/posts/go-recipes-for-developers/"><meta property="og:site_name" content="竹简书摘"><meta property="og:title" content="Go Recipes for Developers"><meta property="og:description" content="Go 开发者实用秘籍"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-29T17:12:00+08:00"><meta property="article:modified_time" content="2024-12-29T17:12:00+08:00"><meta property="article:tag" content="Go"><title>Go Recipes for Developers</title>
<link rel=canonical href=/posts/go-recipes-for-developers/><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/custom.css><link rel=stylesheet href=/css/search.css><link href="https://fonts.googleapis.com/css?family=Bree+Serif" rel=stylesheet><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?c80136b2ed102610dcafb84941e8df30",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head></head><body class=page-article><header><nav class=nav><div class=nav-wrapper><div class=nav-content-wrapper><div class=nav-content><a href=/ class=nav-title>竹简书摘</a><div class=nav-menu><div class=nav-item-wrapper><a href=/posts class=nav-item-content>书摘</a></div><div class=nav-item-wrapper><a href=/index.xml class=nav-item-content target=_blank>RSS</a></div></div></div></div></div></nav><script>function toggleSearchModal(){const t=`
    <div class="modal-body">
      <div id="autocomplete" onclick="event.stopPropagation();"></div>
    </div>
    `,e=document.querySelector("#modal-wrapper");if(e)document.body.removeAttribute("style"),document.body.removeChild(e);else{const e=document.createElement("div");document.body.setAttribute("style","overflow: hidden;"),e.setAttribute("id","modal-wrapper"),e.setAttribute("onclick","toggleSearchModal()"),e.innerHTML=t;const n=document.createElement("script");n.setAttribute("src","https://booslip.rpcx.io/js/algolia.js"),e.appendChild(n),document.body.append(e)}}</script></header><main id=main class=main><section><article class=article><div class=article-header><div class="category component"><div class=component-content><div class=category-eyebrow><span class="category-eyebrow__category category_original">go
</span><span class=category-eyebrow__date>2024年12月29日</span></div></div></div><div class="pagetitle component"><div class=component-content><h1 class=hero-headline>Go Recipes for Developers</h1></div></div><div class="component article-subhead"><div class=component-content>Go 开发者实用秘籍</div></div><div class="tagssheet component"><div class=component-content><a href=/tags/go class=tag>go</a></div></div></div><div class="book-card component"><div class=book-cover><img data-src=/covers/Go-Recipes-for-Developers.jpg alt=书籍封面></div><div class=book-info><h1 class=book-title>Go Recipes for Developers</h1><div class=book-meta><span>作者：Burak Serdar</span>
<span>出版日期：2024-12-30</span>
<span>出版社：Packt Publishing</span></div><div class=book-description>它涵盖了Go语言编程的多个方面，包括项目组织、日期时间处理、数组切片和映射的使用、JSON处理、进程管理、网络编程、流式输入输出、数据库交互、日志记录、测试和性能分析等。书中以“食谱”的形式，为开发者提供了大量实用代码示例和最佳实践，帮助解决实际编程问题。</div></div></div><div class=pagebody><p class="component-content component">本书涵盖了Go语言编程的多个方面，包括项目组织、日期时间处理、数组切片和映射的使用、JSON处理、进程管理、网络编程、流式输入输出、数据库交互、日志记录、测试和性能分析等。书中以“食谱”的形式，为开发者提供了大量实用代码示例和最佳实践，帮助解决实际编程问题。作者Burak Serdar拥有超过30年的软件工程经验，审稿人Dylan Meeus也具备丰富的编程经验，确保了书中内容的权威性和实用性。</p><div class="component-content component"><ul><li><p class="component-content component"><strong>第一章：项目组织</strong></p><div class="component-content component"><ul><li>本章主要介绍了Go语言的模块管理和项目组织结构。Go语言使用模块来管理依赖关系，并使用 <code>go。mod</code> 文件来定义模块的依赖项。</li><li>导入包时，可以使用完整的模块名称，构建系统会将其转换为本地文件系统引用。</li><li>使用 <code>_</code> 作为空白标识符导入包，表示只为包的副作用而导入，例如数据库驱动的注册。</li></ul></div></li><li><p class="component-content component"><strong>第二章：处理字符串</strong></p><div class="component-content component"><ul><li>Go语言的字符串是 <strong>不可变的 UTF-8 编码的字节序列</strong>。字符串变量是可变的，但字符串本身是不可变的。修改字符串变量需要创建字节或rune切片，操作后再转换回字符串。</li><li>Go使用 <strong>rune 类型表示码点</strong>，字符串可以被视为字节序列或rune序列。</li><li>本章介绍了创建字符串的多种方法，包括使用<strong>双引号</strong>的解释型字符串和使用<strong>反引号</strong>的原始字符串。解释型字符串需要转义特殊字符，而原始字符串可以包含换行符等。</li><li><code>fmt</code> 包提供了多种格式化字符串的方法，包括 <code>fmt。Println</code>，<code>fmt。Printf</code>，<code>fmt。Sprintf</code> 和 <code>fmt。Fprintf</code>。<code>fmt。Printf</code> 可以使用格式化参数来指定输出格式。</li><li>可以使用 <code>+</code> 或 <code>+=</code> 运算符连接字符串，但对于性能敏感的代码，应谨慎使用。<code>strings。Join</code> 可以连接字符串切片。</li><li><code>strings</code> 包提供了大小写转换功能，包括 <code>strings。ToUpper</code>，<code>strings。ToLower</code>，<code>strings。ToTitle</code> 以及针对特定语言的转换。使用 <code>strings。EqualFold</code> 可以进行不区分大小写的比较。</li><li>可以使用 <code>golang。org/x/text/transform</code> 和 <code>golang。org/x/text/unicode/norm</code> 包来<strong>处理国际化字符串和编码问题</strong>，例如移除变音符号。</li><li><strong>迭代字符串的字节和rune</strong>可以使用 <code>for</code> 循环，但需要注意，将字符串转换为字节切片或rune切片是昂贵的操作。</li><li><code>strings。Split</code> 用于分割字符串，<code>strings。Fields</code> 用于分割空格分隔的字符串。<code>bufio。Scanner</code> 可以逐行或逐词读取字符串。</li><li>可以使用 <code>strings。Trim</code> 系列函数来<strong>修剪字符串首尾的空格</strong>。</li><li><code>regexp</code> 包提供了 <strong>正则表达式</strong> 功能，用于验证、搜索、提取和替换字符串。</li><li><code>text/template</code> 包可以用于 <strong>创建模板</strong>，进行值替换和迭代。模板可以使用变量、作用域、循环和条件语句。模板可以组合复用。</li></ul></div></li><li><p class="component-content component"><strong>第三章：处理日期和时间</strong></p><div class="component-content component"><ul><li>Go语言使用 <code>time。Time</code> 类型来表示日期和时间。</li><li>可以使用 <code>time。Now()</code> 获取当前时间，以及 <code>time。Unix()</code> 和 <code>time。UnixMicro()</code> 将Unix时间戳转换为 <code>time。Time</code> 类型。</li><li>可以使用 <code>time。Location</code> 来<strong>处理时区</strong>。</li><li><code>time。Time</code> 类型提供了访问日期/时间组件的方法，如 <code>Year()</code>，<code>Month()</code>，<code>Day()</code>，<code>Hour()</code>，<code>Minute()</code>，<code>Second()</code>。</li><li>可以使用 <code>time。Timer</code> 和 <code>time。After</code> 来实现 <strong>定时操作</strong>。</li></ul></div></li><li><p class="component-content component"><strong>第四章：处理数组、切片和Map</strong></p><div class="component-content component"><ul><li>可以使用 <code>make</code> 函数创建切片，并指定长度和容量。切片可以使用 <code>append</code> 添加元素。</li><li>可以使用 <code>[:]</code> 从数组创建切片。</li><li>可以使用 <code>make(map[KeyType]ValueType)</code> 创建map。map的键类型必须是可比较的。</li><li>可以使用map来实现集合，键类型为集合元素类型，值类型为 <code>struct{}</code>。</li><li><strong>复合键</strong>可以使用可比较的结构体或数组。</li><li>可以使用 <code>sync。Map</code> 实现 <strong>线程安全的map</strong>。</li><li>可以使用 <code>sync。Once</code> 来确保某个操作只执行一次。</li></ul></div></li><li><p class="component-content component"><strong>第五章：使用类型、结构体和接口</strong></p><div class="component-content component"><ul><li>可以使用 <code>type</code> 关键字定义新的类型。</li><li>结构体可以<strong>嵌入</strong>其他结构体，实现<strong>组合</strong>。</li><li>接口定义了方法集，类型只要实现了接口定义的方法，就自动实现了该接口。可以使用 <strong>类型断言</strong> 来检查接口变量是否包含特定类型的值或是否实现了其他接口。</li><li>可以使用<strong>指针接收器</strong>或<strong>值接收器</strong>定义方法。指针接收器可以修改接收器本身，而值接收器修改的是接收器的副本。使用指针接收器可以避免数据竞争。</li><li>可以通过定义接口中的未导出方法来访问嵌入结构体中的成员。</li></ul></div></li><li><p class="component-content component"><strong>第六章：使用泛型</strong></p><div class="component-content component"><ul><li><strong>泛型函数</strong>是接受类型参数的函数模板。可以使用类型约束来限制泛型函数可以接受的类型。</li><li><strong>泛型类型</strong>是接受类型参数的类型模板。可以使用泛型类型创建类型安全的集合和有序map。</li><li>泛型函数可以用作 <strong>类型安全的访问器和适配器</strong>。</li></ul></div></li><li><p class="component-content component"><strong>第七章：并发</strong></p><div class="component-content component"><ul><li>可以使用 <code>go</code> 关键字启动 <strong>goroutine</strong>，实现并发。</li><li>可以使用 <code>sync。WaitGroup</code> 来等待多个goroutine完成。</li><li>可以使用 <strong>channel</strong> 在goroutine之间进行通信。可以使用 <code>select</code> 语句处理多个channel。</li><li>可以使用 <code>context</code> 包来 <strong>取消goroutine</strong>。</li><li>可以使用 <strong>互斥锁</strong>（<code>sync。Mutex</code>）来保护共享变量，避免数据竞争。</li></ul></div></li><li><p class="component-content component"><strong>第八章：错误和panic</strong></p><div class="component-content component"><ul><li>Go语言使用<strong>错误值</strong>来处理异常情况。</li><li>可以使用 <code>errors。New</code> 和 <code>fmt。Errorf</code> 创建错误。可以使用 <code>%w</code> 动词来包装错误，添加上下文信息。</li><li>可以使用 <code>errors。Is</code> 来 <strong>比较错误</strong>，判断错误是否是期望的类型。</li><li>可以定义 <strong>结构化错误</strong> 来提供更多上下文信息。</li><li>可以使用 <code>panic</code> 来指示不可恢复的错误，例如程序中的错误或不变量被破坏。</li><li>可以使用 <code>recover</code> 来 <strong>恢复panic</strong>。</li></ul></div></li><li><p class="component-content component"><strong>第九章：Context包</strong></p><div class="component-content component"><ul><li><code>context。Context</code> 用于传递 <strong>请求范围的数据</strong> 和 <strong>控制请求生命周期</strong>。可以使用 <code>context。WithValue</code> 来创建带有值的新的context。</li><li>可以使用 <code>context。WithCancel</code>，<code>context。WithTimeout</code> 来 <strong>取消context</strong>。</li><li>可以使用 <code>context</code> 来实现 <strong>超时控制</strong>。</li></ul></div></li><li><p class="component-content component"><strong>第十章：使用大型数据</strong></p><div class="component-content component"><ul><li>本章介绍了如何使用 <strong>工作池</strong> 和 <strong>并发管道</strong> 来处理大型数据。</li><li>工作池可以限制并发goroutine的数量，避免资源耗尽。</li><li>可以使用 <code>fan-in</code> 模式将多个channel的结果合并到一个channel中。</li><li>可以使用管道模式构建处理数据的流程，每个阶段处理一部分数据。</li><li>可以使用 channel 来 <strong>流式处理数据库查询结果</strong>。</li></ul></div></li><li><p class="component-content component"><strong>第十一章：处理JSON</strong></p><div class="component-content component"><ul><li><code>encoding/json</code> 包可以用于 <strong>编码和解码JSON数据</strong>。</li><li>可以使用 <code>json。Marshal</code> 将Go数据结构编码为JSON字节序列。</li><li>可以使用 <code>json。Unmarshal</code> 将JSON字节序列解码为Go数据结构。</li><li>可以使用结构体标签来控制JSON编码和解码的行为。</li><li>处理嵌套结构体，可以选择将其内嵌，也可以选择作为新的JSON对象。</li><li>可以实现自定义的 <code>MarshalJSON</code> 和 <code>UnmarshalJSON</code> 方法来控制编码和解码过程。</li><li>可以通过流式处理来优化JSON的读写。</li></ul></div></li><li><p class="component-content component"><strong>第十二章：执行进程</strong></p><div class="component-content component"><ul><li><code>os/exec</code> 包可以用于执行外部命令。</li><li>可以使用 <code>cmd。CombinedOutput</code> 获取命令的标准输出和标准错误。</li><li>可以使用管道将数据传递给外部命令。</li><li>可以设置子进程的环境变量。</li></ul></div></li><li><p class="component-content component"><strong>第十三章：网络编程</strong></p><div class="component-content component"><ul><li>Go 语言提供了 <code>net</code> 包用于网络编程，支持TCP和UDP协议。</li><li>TCP 是一种面向连接的可靠协议。 可以使用 <code>net。Listen</code> 和 <code>net。Dial</code> 函数进行TCP服务端和客户端编程。</li><li>可以使用 <code>io。Copy</code> 函数在网络连接之间复制数据。</li><li>可以使用 <code>encoding/binary</code> 包来 <strong>编码和解码二进制数据</strong>，注意大小端问题。</li><li>TLS (Transport Layer Security) 用于加密网络连接。</li><li>可以使用 <code>crypto/tls</code> 包来设置TLS客户端和服务器。</li><li>可以实现反向代理，进行TLS终止和负载均衡。</li><li>可以通过 <code>conn。SetDeadline</code> 和 <code>context</code> 来设置网络连接的超时。</li><li>UDP 是一种无连接的协议，可以使用 <code>net。DialUDP</code> 函数进行UDP编程。</li><li>可以使用 <code>net/http</code> 包进行HTTP客户端和服务器编程。</li><li>可以使用 <code>http。Get</code>， <code>http。Post</code> 等函数进行HTTP请求。</li><li>可以创建自定义的 <code>http。Client</code> 进行更细粒度的控制。</li><li><code>http。HandleFunc</code> 和 <code>http。Handle</code> 用于注册HTTP请求处理器。</li><li><code>http。ResponseWriter</code> 用于写入HTTP响应。</li><li>可以使用 <code>http。Request</code> 结构体来获取HTTP请求的信息。</li><li>可以使用 <code>http。Error</code> 函数返回HTTP错误响应。</li><li>可以使用 <code>http。Server</code> 结构体进行更细粒度的控制。</li><li>可以使用 <code>http。FileServer</code> 来<strong>提供静态文件服务</strong>。</li><li>处理HTTP上传的文件和表单数据可以使用<code>MultipartReader</code></li></ul></div></li><li><p class="component-content component"><strong>第十四章：流式输入/输出</strong></p><div class="component-content component"><ul><li>Go语言的 <code>io</code> 包提供了 <code>io。Reader</code> 和 <code>io。Writer</code> 接口，用于 <strong>抽象输入和输出</strong>。</li><li>可以使用 <code>bytes。NewReader</code> 和 <code>bytes。Buffer</code> 来使用字节切片作为 <code>io。Reader</code> 和 <code>io。Writer</code>。</li><li>可以使用 <code>strings。NewReader</code> 来使用字符串作为 <code>io。Reader</code>。</li><li>可以使用 <code>os。Create</code>， <code>os。Open</code>， 和 <code>os。OpenFile</code> 来<strong>创建和打开文件</strong>。</li><li><code>defer file。Close()</code> 用于确保文件被关闭。</li><li><code>io。Copy</code> 用于复制数据流。</li><li><code>file。Truncate</code> 可以用于截断或扩展文件。</li><li>使用 <code>encoding/binary</code> 来 <strong>处理二进制数据</strong>。</li><li>可以使用 <code>os。MkdirTemp</code> 和 <code>os。CreateTemp</code> 来创建临时目录和文件。</li><li>可以使用 <code>io。Pipe</code> 来创建 <strong>管道</strong>，实现goroutine之间的流式数据传输。</li><li><code>io。TeeReader</code> 可以用来<strong>拦截读取的数据</strong>，并将其写入另一个writer。</li></ul></div></li><li><p class="component-content component"><strong>第十五章：数据库</strong></p><div class="component-content component"><ul><li><code>database/sql</code> 包提供了 <strong>通用的SQL数据库接口</strong>。</li><li>可以使用 <code>sql。Open</code> 函数连接数据库。</li><li>使用空白标识符导入数据库驱动包。</li><li>可以使用 <code>db。PingContext</code> 测试数据库连接。</li><li>可以使用 <code>db。QueryContext</code> 执行查询语句。</li><li>可以使用 <code>db。ExecContext</code> 执行更新语句。</li><li>可以使用 <code>sql。Tx</code> 来 <strong>管理事务</strong>。</li><li><code>sql。IsolationLevel</code> 可以设置事务的隔离级别。</li><li>可以使用<strong>预编译语句</strong>来提高性能和安全性。</li><li>可以 <strong>动态构建SQL语句</strong>。</li></ul></div></li><li><p class="component-content component"><strong>第十六章：日志</strong></p><div class="component-content component"><ul><li>Go 语言提供了 <code>log</code> 包用于<strong>基本的日志记录</strong>。</li><li><code>log。Println</code> 和 <code>log。Printf</code> 用于输出日志。</li><li>可以自定义 <code>log。Logger</code> 的输出和格式。</li><li>可以使用 <code>log。Fatal</code> 和 <code>log。Panic</code> 来终止程序。</li><li><code>log/slog</code> 包提供了 <strong>结构化日志</strong> 功能。</li><li>可以使用 <code>slog。New</code> 创建新的日志记录器。</li><li>可以使用 <code>slog。With</code> 添加上下文信息到日志中。</li><li><code>slog。Handler</code> 定义了如何处理日志消息。</li></ul></div></li><li><p class="component-content component"><strong>第十七章：测试，基准测试和性能分析</strong></p><div class="component-content component"><ul><li><strong>测试</strong> 是保证代码质量的重要手段。</li><li><code>testing</code> 包提供了 <strong>单元测试</strong> 功能。</li><li>测试函数通常遵循 <strong>准备数据，执行函数，验证结果</strong> 的模式。</li><li>可以使用 <code>t。Error</code> 系列函数来报告测试失败。</li><li>可以使用 <code>go test</code> 命令运行测试。</li><li>测试中可以使用日志来记录变量状态。</li><li>可以使用 <code>httptest</code> 包来 <strong>测试HTTP服务器和处理函数</strong>。</li><li><strong>基准测试</strong> 用于评估代码的性能。</li><li><code>testing</code> 包提供了 <strong>基准测试</strong> 功能。</li><li>可以使用 <code>go test -bench</code> 命令运行基准测试。</li><li><strong>性能分析</strong> 可以帮助我们找到代码的性能瓶颈。</li><li>Go 提供了 <code>pprof</code> 工具用于性能分析。</li></ul></div></li></ul></div></div><div id=comments class=utterances><script src=https://utteranc.es/client.js repo=smallnest/booslip.rpcx.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></article></section></main><script>var script=document.createElement("script");script.src="https://booslip.rpcx.io/js/initPost.js",document.head.appendChild(script)</script><div class=footer-main><div class="content-body footer-wraper"><div class=footer-box><div class=foot-nav><div class=foot-nav-items><div class=item><div class=logo></div><div class=email>Email: <a href=mailto:smallnest@gmail.com>smallnest@gmail.com</a></div></div><div class="item community"><div class=item-title>社交媒体</div><a href=https://github.com/smallnest target=_blank>Github</a></div><div class="item resources"><div class=item-title>友链</div><a href=https://colobu.com/ target=_blank>鸟窝</a></div></div></div><div class=bottom><div class="item copyright">鸟窝 &copy; 2025 All Rights Reserved.</div></div></div></div></div></body></html>