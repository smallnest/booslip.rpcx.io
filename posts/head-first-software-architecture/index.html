<!doctype html><html class="js no-touch progressive-image no-reduced-motion progressive" lang=zh-hans><head><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=icon href=/img/favicon.ico><meta name=keyword content><meta property="og:url" content="https://booslip.rpcx.io/posts/head-first-software-architecture/"><meta property="og:site_name" content="竹简书摘"><meta property="og:title" content="Head First Software Architecture"><meta property="og:description" content="软件架构"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-09T18:38:26+08:00"><meta property="article:modified_time" content="2025-01-09T18:38:26+08:00"><meta property="article:tag" content="软件架构"><title>Head First Software Architecture</title>
<link rel=canonical href=/posts/head-first-software-architecture/><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/custom.css><link rel=stylesheet href=/css/search.css><link href="https://fonts.googleapis.com/css?family=Bree+Serif" rel=stylesheet><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?c80136b2ed102610dcafb84941e8df30",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head></head><body class=page-article><header><nav class=nav><div class=nav-wrapper><div class=nav-content-wrapper><div class=nav-content><a href=/ class=nav-title>竹简书摘</a><div class=nav-menu><div class=nav-item-wrapper><a href=/posts class=nav-item-content>书摘</a></div><div class=nav-item-wrapper><a href=/index.xml class=nav-item-content target=_blank>RSS</a></div></div></div></div></div></nav><script>function toggleSearchModal(){const t=`
    <div class="modal-body">
      <div id="autocomplete" onclick="event.stopPropagation();"></div>
    </div>
    `,e=document.querySelector("#modal-wrapper");if(e)document.body.removeAttribute("style"),document.body.removeChild(e);else{const e=document.createElement("div");document.body.setAttribute("style","overflow: hidden;"),e.setAttribute("id","modal-wrapper"),e.setAttribute("onclick","toggleSearchModal()"),e.innerHTML=t;const n=document.createElement("script");n.setAttribute("src","https://booslip.rpcx.io/js/algolia.js"),e.appendChild(n),document.body.append(e)}}</script></header><main id=main class=main><section><article class=article><div class=article-header><div class="category component"><div class=component-content><div class=category-eyebrow><span class="category-eyebrow__category category_original">软件架构
</span><span class=category-eyebrow__date>2025年1月9日</span></div></div></div><div class="pagetitle component"><div class=component-content><h1 class=hero-headline>Head First Software Architecture</h1></div></div><div class="component article-subhead"><div class=component-content>软件架构</div></div><div class="tagssheet component"><div class=component-content><a href=/tags/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84 class=tag>软件架构</a></div></div></div><div class="book-card component"><div class=book-cover><img data-src=/covers/Head-First-Software-Architecture.jpeg alt=书籍封面></div><div class=book-info><h1 class=book-title>Head First Software Architecture</h1><div class=book-meta><span>作者：Raju Gandhi, Mark Richards, Neal Ford</span>
<span>出版日期：2024-04-09</span>
<span>出版社：O'Reilly Media</span></div><div class=book-description>本书主要讲解软件架构的设计原则和实践。书中介绍了多种架构风格，例如分层架构、模块化单体架构、微内核架构和微服务架构，并分析了每种架构的优缺点和适用场景。 重点阐述了架构决策的重要性，以及如何通过架构决策记录（ADR）来规范和记录这些决策。 此外，书中还强调了权衡取舍在软件架构中的重要性，并提供了大量练习和案例来帮助读者理解和掌握这些概念。</div></div></div><div class=pagebody><p class="component-content component">好的，我将根据提供的资料，按照章节总结知识点，并用中文回复，力求做到信、雅、达。</p><div class="component-content pagebody component"><h2 id=第一章软件架构概述 class=pagebody-header><strong>第一章：软件架构概述</strong></h2></div><div class="component-content component"><ul><li><strong>软件架构学习的挑战</strong>: 大脑会倾向于认为软件架构不重要，而将注意力放在其他事情上。但可以通过技巧让大脑意识到软件架构的重要性。</li><li><strong>软件架构的核心</strong>: <strong>架构特性（Architectural Characteristics）</strong> 是任何系统的基本构建模块。没有它们，就无法进行架构决策，选择架构风格，甚至无法创建逻辑架构。</li><li><strong>软件架构的本质</strong>: 软件架构没有最佳实践，需要仔细分析每种情况并做出决策。</li><li><strong>类比</strong>: 可以通过房屋或花园的类比来理解软件架构。</li></ul></div><div class="component-content pagebody component"><h2 id=第二章架构特性 class=pagebody-header><strong>第二章：架构特性</strong></h2></div><div class="component-content component"><ul><li><strong>架构特性的定义</strong>: 架构特性是架构的基石，决定了系统需要支持什么。它们也被称为非功能性需求、系统质量属性或 &ldquo;-ilities&rdquo;。</li><li><strong>架构特性的重要性</strong>: 它们有助于做出架构决策和分析重要的权衡。</li><li><strong>常见的架构特性</strong>: 例如可伸缩性（scalability）、可靠性（reliability）和可测试性（testability）等。</li><li><strong>显式与隐式特性</strong>: 显式特性在需求中明确指出，而隐式特性则影响架构决策，但未明确列出，如安全性。</li><li><strong>复合特性</strong>: 多个特性组合成新的特性，如敏捷性（agility），它包括可测试性、可部署性和模块化等。</li><li><strong>优先级</strong>: 需要根据上下文确定架构特性的优先级，并且优化一个特性可能会牺牲另一个特性。</li><li><strong>没有标准列表</strong>: 架构特性的列表并非固定不变，会随着软件开发生态的变化而变化。</li><li><strong>架构特性与逻辑组件</strong>: 架构特性和逻辑组件共同决定了架构风格。</li></ul></div><div class="component-content pagebody component"><h2 id=第三章权衡与决策 class=pagebody-header><strong>第三章：权衡与决策</strong></h2></div><div class="component-content component"><ul><li><strong>软件架构的第一定律</strong>：<strong>一切皆权衡</strong>。每个决策都包含权衡，没有无代价的决策。</li><li><strong>战略与战术决策</strong>: 战略决策更具架构性，需要更多思考和规划，通常是长期的。</li><li><strong>架构与设计的区别</strong>：架构决策具有显著的权衡，更具战略性，而设计决策则更偏向实现细节。</li><li><strong>权衡分析</strong>：包括找出特定方法的好处和坏处，以获得完整的信息。</li><li><strong>ADR (Architecture Decision Record)</strong>: 用于记录架构决策，包括标题、状态、上下文、决策和后果。<div class="component-content component"><ul><li><strong>ADR 的状态</strong>: 包括 RFC（征求意见）、Proposed（提议中）、Accepted（已接受）和 Superseded（已取代）。</li><li><strong>ADR 的内容</strong>: 包括上下文（决策的环境和约束）、决策（具体要做出的选择）和后果（决策带来的影响）。</li></ul></div></li><li><strong>异步与同步通信的权衡</strong>: 异步通信可以提高响应速度和可用性，而同步通信则更易于管理事务和错误。</li></ul></div><div class="component-content pagebody component"><h2 id=第四章逻辑组件 class=pagebody-header><strong>第四章：逻辑组件</strong></h2></div><div class="component-content component"><ul><li><strong>逻辑组件的定义</strong>: 逻辑组件是系统的构建模块，执行特定的功能。</li><li><strong>逻辑组件的表示</strong>: 通常通过目录或命名空间来表示。</li><li><strong>逻辑组件的特性</strong>: 每个逻辑组件都应该在系统中具有明确的角色和责任。</li><li><strong>识别逻辑组件的方法</strong>：<div class="component-content component"><ul><li><strong>工作流方法</strong>: 根据工作流程的步骤来识别组件。</li><li><strong>参与者/动作方法</strong>: 根据系统中参与者的动作来识别组件。</li></ul></div></li><li><strong>避免实体陷阱</strong>: 命名组件时避免使用 &ldquo;manager&rdquo; 或 &ldquo;supervisor&rdquo; 等词语。</li><li><strong>组件耦合</strong>:<div class="component-content component"><ul><li><strong>传入耦合 (Afferent Coupling, CA)</strong>: 依赖于当前组件的其他组件的数量。</li><li><strong>传出耦合 (Efferent Coupling, CE)</strong>: 当前组件依赖的其他组件的数量。</li><li><strong>总耦合 (Total Coupling, CT)</strong>: 传入耦合和传出耦合的总和。</li></ul></div></li><li><strong>耦合的重要性</strong>: 松耦合可以降低组件之间的依赖性，但也会带来权衡。</li><li><strong>逻辑组件的组织</strong>: 逻辑组件通常与源代码目录结构对应。</li></ul></div><div class="component-content pagebody component"><h2 id=第五章架构风格 class=pagebody-header><strong>第五章：架构风格</strong></h2></div><div class="component-content component"><ul><li><strong>架构风格的分类</strong>: 可以根据代码的划分方式（技术关注点或领域关注点）以及部署方式（单体或分布式）进行分类。</li><li><strong>单体架构</strong>: 将所有逻辑组件部署为一个单元。</li><li><strong>分布式架构</strong>: 将逻辑组件分散到多个单元中。</li><li><strong>架构风格的选择</strong>: 需要考虑多种因素，包括问题的复杂性和时间紧迫性。</li></ul></div><div class="component-content pagebody component"><h2 id=第六章分层架构 class=pagebody-header><strong>第六章：分层架构</strong></h2></div><div class="component-content component"><ul><li><strong>分层架构的特点</strong>: 按照技术关注点将系统划分为不同的层，例如表示层、业务规则层和持久层。</li><li><strong>层与组件的关系</strong>: 领域组件通常会跨越多个物理层。</li><li><strong>分层架构的优缺点</strong>: 简单易懂，但可能难以适应领域变化。</li><li><strong>适用场景</strong>: 适合简单且不需要频繁更改的系统。</li></ul></div><div class="component-content pagebody component"><h2 id=第七章模块化单体架构 class=pagebody-header><strong>第七章：模块化单体架构</strong></h2></div><div class="component-content component"><ul><li><strong>模块化单体架构的特点</strong>: 在单体架构的基础上，按照业务领域对系统进行划分，形成多个模块。</li><li><strong>模块化的优势</strong>: 提高可维护性、可测试性和可部署性，降低变更风险。</li><li><strong>模块间的通信</strong>: 通过模块的 API 进行间接通信。</li><li><strong>模块化与分层</strong>: 模块化单体架构可以包含分层架构，并且每个模块可以有自己的层。</li><li><strong>数据模式</strong>: 每个模块都有自己的数据模式.</li></ul></div><div class="component-content pagebody component"><h2 id=第八章微内核架构 class=pagebody-header><strong>第八章：微内核架构</strong></h2></div><div class="component-content component"><ul><li><strong>微内核架构的特点</strong>: 将系统分为一个核心部分（core）和多个插件（plugin）。</li><li><strong>核心的功能</strong>: 核心提供最基本的功能，插件负责扩展和定制功能。</li><li><strong>插件的类型</strong>: 可以是单体或分布式的。</li><li><strong>微内核的“微内核性”</strong>: 取决于核心在没有插件的情况下有多大的功能以及核心的易变性。</li><li><strong>适用场景</strong>: 适用于需要高度定制和扩展的系统，例如 IDE 和电子回收系统。</li></ul></div><div class="component-content pagebody component"><h2 id=第九章架构实践 class=pagebody-header><strong>第九章：架构实践</strong></h2></div><div class="component-content component"><ul><li><strong>综合运用</strong>: 本章通过 TripEZ 旅行应用程序，综合运用了之前章节的知识，包括架构特性、逻辑组件和架构风格，来构建一个完整的架构。</li><li><strong>架构决策过程</strong>: 包括确定架构特性、构建逻辑架构、做出架构决策和选择架构风格。</li><li><strong>没有正确答案</strong>: 软件架构没有绝对的正确答案，重点在于分析权衡并为决策提供合理依据。</li><li><strong>多种可能的解决方案</strong>: 对于同一个问题，可以有多种可行的架构解决方案。</li></ul></div><div class="component-content pagebody component"><h2 id=第十章微服务架构 class=pagebody-header><strong>第十章：微服务架构</strong></h2></div><div class="component-content component"><ul><li><strong>微服务架构的特点</strong>: 将应用程序分解为一组小的、独立部署的服务。</li><li><strong>服务粒度</strong>: 微服务不宜过大或过小，需要找到合适的粒度。</li><li><strong>数据所有权</strong>: 每个微服务拥有自己的数据。</li><li><strong>共享功能</strong>: 可以使用共享服务或共享库来实现。</li><li><strong>工作流管理</strong>: 可以通过编排（Orchestration）或协作（Choreography）来管理。<div class="component-content component"><ul><li><strong>编排</strong>: 由一个中心服务来协调其他微服务的调用。</li><li><strong>协作</strong>: 微服务之间通过事件进行通信，无需中央协调者。</li></ul></div></li></ul></div><div class="component-content pagebody component"><h2 id=第十一章事件驱动架构 class=pagebody-header><strong>第十一章：事件驱动架构</strong></h2></div><div class="component-content component"><ul><li><strong>事件驱动架构的特点</strong>: 通过事件进行异步通信，将处理分解为独立的服务。</li><li><strong>事件的定义</strong>: 已发生的事情，通常用过去式表示。</li><li><strong>消息与事件</strong>: 消息是命令，而事件是通知。</li><li><strong>异步通信</strong>: 服务发送事件后无需等待响应，提高了系统的响应速度和可用性。</li><li><strong>同步通信</strong>: 发送服务必须等待接收服务响应。</li><li><strong>数据耦合</strong>: 在事件驱动架构中，数据可能会形成耦合点。</li><li><strong>数据拓扑</strong>: 数据库可以是单体也可以是服务专有的。</li><li><strong>事件驱动架构的优缺点</strong>: 具有高弹性、高可用性，但也更复杂。</li></ul></div><p class="component-content component"><strong>附录：其他</strong></p><div class="component-content component"><ul><li><strong>架构师的职责</strong>: 清晰、简洁地沟通，并与开发团队合作。</li><li><strong>清晰的架构图</strong>: 使用一致的形状、颜色和线条，并包含图例。</li><li><strong>学习路径</strong>: 从了解基础知识到扩展广度和深度.</li></ul></div></div><div id=comments class=utterances><script src=https://utteranc.es/client.js repo=smallnest/booslip.rpcx.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></article></section></main><script>var script=document.createElement("script");script.src="https://booslip.rpcx.io/js/initPost.js",document.head.appendChild(script)</script><div class=footer-main><div class="content-body footer-wraper"><div class=footer-box><div class=foot-nav><div class=foot-nav-items><div class=item><div class=logo></div><div class=email>Email: <a href=mailto:smallnest@gmail.com>smallnest@gmail.com</a></div></div><div class="item community"><div class=item-title>社交媒体</div><a href=https://github.com/smallnest target=_blank>Github</a></div><div class="item resources"><div class=item-title>友链</div><a href=https://colobu.com/ target=_blank>鸟窝</a></div></div></div><div class=bottom><div class="item copyright">鸟窝 &copy; 2025 All Rights Reserved.</div></div></div></div></div></body></html>