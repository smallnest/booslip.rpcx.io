<!doctype html><html class="js no-touch progressive-image no-reduced-motion progressive" lang=zh-hans><head><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=icon href=/img/favicon.ico><meta name=keyword content><meta property="og:url" content="https://booslip.rpcx.io/posts/system-programming-essentials-with-go/"><meta property="og:site_name" content="竹简书摘"><meta property="og:title" content="System Programming Essentials With Go"><meta property="og:description" content="Go系统编程精要"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-29T17:24:00+08:00"><meta property="article:modified_time" content="2024-12-29T17:24:00+08:00"><meta property="article:tag" content="Go"><title>System Programming Essentials With Go</title>
<link rel=canonical href=/posts/system-programming-essentials-with-go/><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/custom.css><link rel=stylesheet href=/css/search.css><link href="https://fonts.googleapis.com/css?family=Bree+Serif" rel=stylesheet><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?c80136b2ed102610dcafb84941e8df30",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head></head><body class=page-article><header><nav class=nav><div class=nav-wrapper><div class=nav-content-wrapper><div class=nav-content><a href=/ class=nav-title>竹简书摘</a><div class=nav-menu><div class=nav-item-wrapper><a href=/posts class=nav-item-content>书摘</a></div><div class=nav-item-wrapper><a href=/index.xml class=nav-item-content target=_blank>RSS</a></div></div></div></div></div></nav><script>function toggleSearchModal(){const t=`
    <div class="modal-body">
      <div id="autocomplete" onclick="event.stopPropagation();"></div>
    </div>
    `,e=document.querySelector("#modal-wrapper");if(e)document.body.removeAttribute("style"),document.body.removeChild(e);else{const e=document.createElement("div");document.body.setAttribute("style","overflow: hidden;"),e.setAttribute("id","modal-wrapper"),e.setAttribute("onclick","toggleSearchModal()"),e.innerHTML=t;const n=document.createElement("script");n.setAttribute("src","https://booslip.rpcx.io/js/algolia.js"),e.appendChild(n),document.body.append(e)}}</script></header><main id=main class=main><section><article class=article><div class=article-header><div class="category component"><div class=component-content><div class=category-eyebrow><span class="category-eyebrow__category category_original">go
</span><span class=category-eyebrow__date>2024年12月29日</span></div></div></div><div class="pagetitle component"><div class=component-content><h1 class=hero-headline>System Programming Essentials With Go</h1></div></div><div class="component article-subhead"><div class=component-content>Go系统编程精要</div></div><div class="tagssheet component"><div class=component-content><a href=/tags/go class=tag>go</a></div></div></div><div class="book-card component"><div class=book-cover><img data-src=/covers/System-Programming-Essentials-With-Go.jpg alt=书籍封面></div><div class=book-info><h1 class=book-title>System Programming Essentials With Go</h1><div class=book-meta><span>作者：Alex Rios</span>
<span>出版日期：2024-06-28</span>
<span>出版社：Packt Publishing</span></div><div class=book-description>本书主要介绍了使用Go语言进行系统级编程的知识。书中涵盖了并发编程、内存管理、性能分析、系统调用、网络编程、以及与硬件交互等多个方面。此外，还包含了命令行工具的开发、日志记录、监控和追踪等内容，并以一个分布式缓存的项目作为案例，展示了如何将所学知识应用于实践。最后，书中还讨论了高效编码技巧和一些些常见问题的避免方法。</div></div></div><div class=pagebody><p class="component-content component">本书主要介绍了使用Go语言进行系统级编程的知识。书中涵盖了并发编程、内存管理、性能分析、系统调用、网络编程、以及与硬件交互等多个方面。此外，还包含了命令行工具的开发、日志记录、监控和追踪等内容，并以一个分布式缓存的项目作为案例，展示了如何将所学知识应用于实践。最后，书中还讨论了高效编码技巧和一些常见问题的避免方法。</p><div class="component-content component"><ul><li><p class="component-content component"><strong>第一部分：导论</strong></p><div class="component-content component"><ul><li>本书旨在探讨如何使用 Go 语言进行系统编程，重点在于系统调用、网络、效率和安全实践。</li><li>Go 语言因其简洁、健壮和高效的设计理念，成为系统编程的理想选择。</li><li>本部分将介绍 Go 的并发模型、与操作系统交互的方式以及跨平台开发工具的使用。</li><li>书中提供了 GitHub 代码仓库，方便读者获取示例代码。</li><li>鼓励读者通过邮件或网站反馈意见和报告错误。</li></ul></div></li><li><p class="component-content component"><strong>第二部分：并发</strong></p><div class="component-content component"><ul><li>Go 语言使用 <strong>goroutine</strong> 实现并发，通过 <code>go</code> 关键字启动。</li><li><strong>sync.WaitGroup</strong> 用于同步 goroutine 的执行，<code>Add()</code> 方法添加 goroutine，<code>Done()</code> 方法标记完成，<code>Wait()</code> 方法等待所有 goroutine 完成.</li><li><strong>原子操作</strong>（atomic operations）用于同步和管理 goroutine 之间的并发，例如 <code>sync/atomic</code> 包提供的 <code>Load</code>, <code>Store</code>, <code>Add</code> 和 <code>CAS</code> 等操作。</li><li><strong>互斥锁（Mutexes）</strong> 用于保护共享数据，确保同一时间只有一个 goroutine 可以访问临界区。</li><li><strong>通道（Channels）</strong> 用于 goroutine 之间的通信，包括无缓冲通道和缓冲通道。</li><li>通道有三种状态：nil、打开（空或非空）和关闭，读写操作有不同的行为。</li><li>使用 <code>range</code> 循环可以从通道读取数据，直到通道关闭。</li><li><strong>缓冲通道</strong> 可以存储一定数量的数据，发送者在通道满时会阻塞，接收者在通道空时会阻塞。</li><li><strong>select</strong> 语句可以监听多个通道的操作，从而实现多路复用。</li></ul></div></li><li><p class="component-content component"><strong>第三部分：系统调用与命令行程序</strong></p><div class="component-content component"><ul><li>系统调用是操作系统提供的接口，允许程序访问内核功能。</li><li>Go 语言的 <code>syscall</code> 包提供了与操作系统交互的底层接口，但已被弃用，推荐使用 <code>x/sys</code> 包。</li><li><code>unix.Syscall()</code> 和 <code>unix.Syscall6()</code> 用于执行系统调用，<code>unix.SYS_*</code> 定义了各种系统调用的常量。</li><li>文件操作包括创建、删除文件和目录，以及创建链接。</li><li>标准输入（stdin）、标准输出（stdout）和标准错误（stderr）是程序启动时继承的三个文件描述符。</li><li>可以使用 <code>os</code> 包中的 <code>os.Args</code> 获取命令行参数。</li><li>可以使用 <code>fmt.Fprintf</code> 向标准输出和标准错误写入数据。</li><li><strong>函数式选项</strong>（Functional Options）模式可以灵活配置对象，避免多个构造函数参数或配置结构体。</li><li>使用 <strong>io.Writer</strong> 接口可以方便地切换输出流。</li><li>测试可以使用 <code>bytes.Buffer</code> 捕获输出，并断言结果。</li><li>可以使用管道 (<code>|</code>) 将一个命令的输出作为另一个命令的输入。</li><li><strong>命名管道（FIFO）</strong> 是进程间通信的一种机制。</li><li>通过 <code>os.Mkfifo</code> 创建命名管道，通过 <code>os.OpenFile</code> 打开和读写。</li><li>通过 <code>os.RemoveAll()</code> 删除命名管道。</li><li>可以使用 <code>exec.Command</code> 执行外部命令，并使用 <code>StdoutPipe</code> 或 <code>Output</code> 获取输出。</li></ul></div></li><li><p class="component-content component"><strong>第四部分：文件与目录操作</strong></p><div class="component-content component"><ul><li>符号链接（symlink）是指向另一个文件或目录的链接。</li><li><code>os.Readlink()</code> 用于读取符号链接的目标，<code>os.Stat()</code> 用于检查文件或目录是否存在。</li><li>可以使用 <code>filepath.Walk</code> 遍历目录，并处理每个文件。</li><li><strong>内存映射</strong>（mmap）可以将文件映射到内存中，实现高效的文件访问，可以使用 <code>syscall.Mmap</code> 和 <code>syscall.Munmap</code> 实现。</li><li>通过 <strong>fsnotify</strong> 可以监听文件系统事件。</li><li><strong>sync.Mutex</strong> 可用于同步文件访问。</li><li>日志轮转涉及关闭当前日志文件、重命名、创建新日志文件.</li><li>可以使用 <code>context.WithTimeout</code> 为命令执行设置超时。</li><li><strong>syscall.FcntlFlock</strong> 可以用于文件锁。</li></ul></div></li><li><p class="component-content component"><strong>第五部分：网络编程</strong></p><div class="component-content component"><ul><li><strong>TCP</strong> 是一种可靠的传输协议，确保数据包按顺序到达。</li><li><code>net.Dial</code> 用于建立 TCP 连接，<code>net.Listen</code> 用于监听 TCP 连接。</li><li><strong>HTTP</strong> 是一种基于 TCP 的应用层协议，用于传输网页内容。</li><li>HTTP 方法包括 GET、POST、PUT、DELETE 和 PATCH，用于指定对资源的操作。</li><li>HTTP 状态码用于指示 HTTP 请求的结果，例如 200 OK、404 Not Found 和 500 Internal Server Error。</li><li><strong>TLS</strong> 用于加密网络连接，<code>http.ListenAndServeTLS</code> 可以启动一个支持 TLS 的 HTTP 服务器。</li><li><strong>UDP</strong> 是一种无连接的传输协议，适用于实时应用和广播。</li><li><strong>WebSocket</strong> 是一种在单个 TCP 连接上进行全双工通信的协议。</li><li>使用 <code>ws.UpgradeHTTP</code> 将 HTTP 连接升级到 WebSocket 连接。</li><li>可以使用 <code>wsutil</code> 包发送和接收 WebSocket 消息。</li></ul></div></li><li><p class="component-content component"><strong>第六部分：应用遥测</strong></p><div class="component-content component"><ul><li><strong>日志</strong> 用于记录应用程序的运行状态和事件。</li><li>结构化日志使用键值对记录数据，方便分析和查询。</li><li><strong>slog</strong> 和 <strong>zap</strong> 是 Go 中常用的日志库。</li><li><strong>追踪</strong> 用于记录请求的执行路径，帮助识别性能瓶颈。</li><li><strong>指标</strong> 用于监控应用程序的性能，例如请求数、错误率和延迟。</li><li><strong>Prometheus</strong> 是一个常用的指标监控系统。</li><li><strong>OpenTelemetry（OTel）</strong> 旨在提供一个统一的遥测框架，支持多种日志、追踪和指标工具。</li></ul></div></li><li><p class="component-content component"><strong>第七部分：分布式缓存</strong></p><div class="component-content component"><ul><li><strong>分布式缓存</strong> 用于存储频繁访问的数据，减少延迟和提高读取吞吐量。</li><li>分布式缓存需要处理一致性、容错和数据过期等问题。</li><li>可以使用 <strong>sync.RWMutex</strong> 实现并发安全的缓存。</li><li>Go 标准库中的 <strong>list</strong> 包可以实现 <strong>LRU</strong> 缓存淘汰策略。</li><li>可以使用 <strong>HTTP</strong> 作为分布式缓存的接口。</li><li><strong>数据复制</strong> 可以确保数据在多个节点之间保持一致。</li><li>常见的复制方法包括主从复制、对等复制和发布-订阅模式。</li><li><strong>一致性哈希</strong> 可以用于数据分片，将数据均匀分布到多个节点。</li><li>可以使用 <code>json.Marshal</code> 和 <code>json.Unmarshal</code> 进行 JSON 序列化和反序列化。</li><li>使用 <strong>io.MultiWriter</strong> 可以将输出同时写入多个目标。</li></ul></div></li><li><p class="component-content component"><strong>第八部分：高效的编码实践</strong></p><div class="component-content component"><ul><li><strong>资源重用</strong> 可以减少资源分配和释放的开销，提高性能。</li><li><strong>sync.Pool</strong> 可以用于重用临时对象，例如 <code>bytes.Buffer</code>。</li><li><strong>sync.Once</strong> 可以确保代码只执行一次，例如初始化全局变量。</li><li><strong>sync.OnceValue</strong> 和 <strong>sync.OnceValues</strong> 是 <code>sync.Once</code> 的简化版本。</li><li><strong>singleflight.Group</strong> 可以防止重复执行相同的函数调用，减少资源浪费。</li><li><strong>mmap</strong> 可以用于高效地访问大文件和实现进程间通信。</li><li>必须始终确保资源在成功创建后被及时关闭，可以使用 <code>defer</code> 关键字</li></ul></div></li><li><p class="component-content component"><strong>第九部分：硬件自动化</strong></p><div class="component-content component"><ul><li>程序可以通过监听 <strong>USB</strong> 设备事件来触发特定操作。</li><li><code>os.MkdirAll</code> 创建多级目录，<code>os.Rename</code> 用于移动文件。</li><li><code>/proc/mounts</code> 列出所有挂载的文件系统信息，可用于找到 USB 设备的挂载点。</li><li>可以使用 D-Bus 发送 <strong>桌面通知</strong>。</li><li>D-Bus <code>AddMatch</code> 用于监听特定信号。</li><li>程序可以通过读取 <code>/sys/block</code> 获取存储设备的信息。</li></ul></div></li></ul></div><p class="component-content component">总而言之，本书涵盖了 Go 语言系统编程的多个方面，从并发控制、系统调用、文件操作、网络编程到应用遥测和硬件自动化。通过这些章节的学习，读者可以掌握使用 Go 构建高效、可靠的系统软件所需的技能。</p></div><div id=comments class=utterances><script src=https://utteranc.es/client.js repo=smallnest/booslip.rpcx.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></article></section></main><script>var script=document.createElement("script");script.src="https://booslip.rpcx.io/js/initPost.js",document.head.appendChild(script)</script><div class=footer-main><div class="content-body footer-wraper"><div class=footer-box><div class=foot-nav><div class=foot-nav-items><div class=item><div class=logo></div><div class=email>Email: <a href=mailto:smallnest@gmail.com>smallnest@gmail.com</a></div></div><div class="item community"><div class=item-title>社交媒体</div><a href=https://github.com/smallnest target=_blank>Github</a></div><div class="item resources"><div class=item-title>友链</div><a href=https://colobu.com/ target=_blank>鸟窝</a></div></div></div><div class=bottom><div class="item copyright">鸟窝 &copy; 2025 All Rights Reserved.</div></div></div></div></div></body></html>