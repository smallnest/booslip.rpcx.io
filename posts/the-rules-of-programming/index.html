<!doctype html><html class="js no-touch progressive-image no-reduced-motion progressive" lang=zh-hans><head><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=icon href=/img/favicon.ico><meta name=keyword content><meta property="og:url" content="https://booslip.rpcx.io/posts/the-rules-of-programming/"><meta property="og:site_name" content="竹简书摘"><meta property="og:title" content="The Rules of Programming"><meta property="og:description" content="编程规则：如何编写更好的代码"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-01T22:58:50+08:00"><meta property="article:modified_time" content="2025-01-01T22:58:50+08:00"><meta property="article:tag" content="Go"><meta property="article:tag" content="Programming"><title>The Rules of Programming</title>
<link rel=canonical href=/posts/the-rules-of-programming/><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/custom.css><link rel=stylesheet href=/css/search.css><link href="https://fonts.googleapis.com/css?family=Bree+Serif" rel=stylesheet><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?c80136b2ed102610dcafb84941e8df30",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head></head><body class=page-article><header><nav class=nav><div class=nav-wrapper><div class=nav-content-wrapper><div class=nav-content><a href=/ class=nav-title>竹简书摘</a><div class=nav-menu><div class=nav-item-wrapper><a href=/posts class=nav-item-content>书摘</a></div><div class=nav-item-wrapper><a href=/index.xml class=nav-item-content target=_blank>RSS</a></div></div></div></div></div></nav><script>function toggleSearchModal(){const t=`
    <div class="modal-body">
      <div id="autocomplete" onclick="event.stopPropagation();"></div>
    </div>
    `,e=document.querySelector("#modal-wrapper");if(e)document.body.removeAttribute("style"),document.body.removeChild(e);else{const e=document.createElement("div");document.body.setAttribute("style","overflow: hidden;"),e.setAttribute("id","modal-wrapper"),e.setAttribute("onclick","toggleSearchModal()"),e.innerHTML=t;const n=document.createElement("script");n.setAttribute("src","https://booslip.rpcx.io/js/algolia.js"),e.appendChild(n),document.body.append(e)}}</script></header><main id=main class=main><section><article class=article><div class=article-header><div class="category component"><div class=component-content><div class=category-eyebrow><span class="category-eyebrow__category category_original">go
</span><span class=category-eyebrow__date>2025年1月1日</span></div></div></div><div class="pagetitle component"><div class=component-content><h1 class=hero-headline>The Rules of Programming</h1></div></div><div class="component article-subhead"><div class=component-content>编程规则：如何编写更好的代码</div></div><div class="tagssheet component"><div class=component-content><a href=/tags/go class=tag>go
</a><a href=/tags/programming class=tag>programming</a></div></div></div><div class="book-card component"><div class=book-cover><img data-src=/covers/The-Rules-of-Programming.jpg alt=书籍封面></div><div class=book-info><h1 class=book-title>The Rules of Programming</h1><div class=book-meta><span>作者：Chris Zimmerman</span>
<span>出版日期：2023-01-17</span>
<span>出版社：O'Reilly Media</span></div><div class=book-description>书中作者结合其在微软和Sucker Punch游戏公司的编程团队管理经验，总结出一系列编程原则，旨在帮助程序员编写更简洁、易于测试和维护的代码。这些原则涵盖了代码简洁性、算法选择、测试策略、团队协作、代码审查以及代码重构等多个方面，并通过具体的代码示例和案例分析进行阐述。 书中还讨论了如何处理代码复杂性，以及如何平衡渐进式改进和彻底重构之间的关系。</div></div></div><div class=pagebody><p class="component-content component">这份规则摘自克里斯·齐默曼的《编程规则：如何编写更好的代码》一书。书中作者结合其在微软和Sucker Punch游戏公司的编程团队管理经验，总结出一系列编程原则，旨在帮助程序员编写更简洁、易于测试和维护的代码。这些原则涵盖了代码简洁性、算法选择、测试策略、团队协作、代码审查以及代码重构等多个方面，并通过具体的代码示例和案例分析进行阐述。 书中还讨论了如何处理代码复杂性，以及如何平衡渐进式改进和彻底重构之间的关系。</p><p class="component-content component">以下是对《编程规则》一书中每一条规则的总结：</p><div class="component-content component"><ul><li><p class="component-content component"><strong>Rule 1. 尽可能简单，但不能过于简单 (As Simple as Possible, but No Simpler)</strong></p><div class="component-content component"><ul><li>核心思想：<strong>代码应尽可能简单，但不能为了简单而牺牲必要的功能和清晰度 (Code should be as simple as possible, but not simpler than necessary)</strong>.</li><li>要点：<div class="component-content component"><ul><li>目标是在<strong>避免不必要的复杂性</strong>和<strong>确保代码完整解决问题</strong>之间找到平衡点.</li><li>代码应该<strong>易于理解和维护</strong>.</li><li>这个规则是本书中其他规则的基础.</li></ul></div></li></ul></div></li><li><p class="component-content component"><strong>Rule 2. 错误是会传染的 (Bugs Are Contagious)</strong></p><div class="component-content component"><ul><li>核心思想：<strong>一旦代码中存在错误，人们就会无意中编写依赖于这个错误的代码，使得修复错误更加困难 (Once a bug exists, people will unintentionally write code that relies on that bug)</strong>.</li><li>要点：<div class="component-content component"><ul><li><strong>越早发现错误，修复就越容易</strong>.</li><li>依赖于错误的代码可能出现在附近，也可能出现在上游或下游的代码中.</li><li>这使得<strong>调试和修复变得复杂</strong>，因为一个错误可能会导致多个地方出现问题.</li></ul></div></li></ul></div></li><li><p class="component-content component"><strong>Rule 3. 好的命名是最好的文档 (A Good Name Is the Best Documentation)</strong></p><div class="component-content component"><ul><li>核心思想：<strong>好的命名是代码最重要的文档形式，应清晰地表达代码的意图 (The name of a thing is the first and most important documentation you have)</strong>.</li><li>要点：<div class="component-content component"><ul><li>命名应准确地反映<strong>变量、函数或类的作用</strong>.</li><li>保持<strong>命名的一致性</strong>至关重要.</li><li><strong>避免使用过于简短或难以理解的命名</strong>.</li><li><strong>机械化的命名规则</strong>可以提高代码的一致性.</li></ul></div></li></ul></div></li><li><p class="component-content component"><strong>Rule 4. 通用化需要三个例子 (Generalization Takes Three Examples)</strong></p><div class="component-content component"><ul><li>核心思想：<strong>在尝试通用化之前，至少要有三个用例 (Don&rsquo;t generalize until you have at least three concrete examples)</strong>.</li><li>要点：<div class="component-content component"><ul><li><strong>一个例子不足以预测通用模式</strong>.</li><li>两个例子可能让你对错误的概括更自信.</li><li>三个例子能更准确地预测模式，使概括更保守.</li></ul></div></li><li>实践：<strong>在考虑通用化之前，确保至少有三个独立的用例</strong>.</li></ul></div></li><li><p class="component-content component"><strong>Rule 5. 稍后优化 (Optimize Later)</strong></p><div class="component-content component"><ul><li>核心思想：<strong>在没有实际的性能问题之前，不要进行过早的优化 (Don&rsquo;t optimize unless you have to)</strong>.</li><li>要点：<div class="component-content component"><ul><li><strong>先编写简单清晰的代码，然后测量性能</strong>.</li><li>优化应该基于<strong>性能分析</strong>，而不是猜测.</li><li>过早的优化可能会使代码更复杂，难以维护.</li></ul></div></li></ul></div></li><li><p class="component-content component"><strong>Rule 6. 代码审查有三个好处 (Code Reviews Are Good for Three Reasons)</strong></p><div class="component-content component"><ul><li>核心思想：<strong>代码审查对于提高代码质量至关重要 (Code reviews are good for three reasons)</strong>.</li><li>要点：<div class="component-content component"><ul><li>代码审查可以帮助<strong>发现错误和潜在问题</strong>.</li><li>代码审查有助于促进团队成员之间的<strong>知识共享</strong>.</li><li>代码审查可以提高代码的<strong>可维护性</strong>.</li></ul></div></li></ul></div></li><li><p class="component-content component"><strong>Rule 7. 消除失败情况 (Eliminate Failure Cases)</strong></p><div class="component-content component"><ul><li>核心思想：<strong>通过设计，使代码难以被错误地使用，而不是仅仅依赖于用户的正确使用 (Make it impossible to use the code incorrectly, rather than merely avoiding incorrect usage)</strong>.</li><li>要点：<div class="component-content component"><ul><li><strong>使错误用法不可能发生</strong>.</li><li>利用<strong>编译器进行类型检查</strong>.</li><li>将<strong>多阶段操作分解为独立的对象</strong>.</li><li>使用 <strong>C++ 模板来实现类型安全的可选参数</strong>.</li></ul></div></li></ul></div></li><li><p class="component-content component"><strong>Rule 8. 没有运行的代码是没用的 (Code That Isn’t Running Doesn’t Work)</strong></p><div class="component-content component"><ul><li>核心思想：<strong>未被实际执行的代码是不可靠的，应及时删除或修复 (Code that isn&rsquo;t running is code that isn&rsquo;t working)</strong>.</li><li>要点：<div class="component-content component"><ul><li>强调了<strong>测试和实际运行</strong>的重要性.</li><li>鼓励<strong>删除无用代码</strong>而不是保留着它.</li><li>假设其他部分的代码基本正常运作.</li></ul></div></li></ul></div></li><li><p class="component-content component"><strong>Rule 9. 编写可折叠的代码 (Write Collapsible Code)</strong></p><div class="component-content component"><ul><li>核心思想：<strong>编写易于理解和概括的代码，使得阅读者可以快速理解代码逻辑，避免在细节中迷失 (Code should be written to collapse easily into a few memorable ideas)</strong>.</li><li>要点：<div class="component-content component"><ul><li>使用<strong>抽象</strong>来简化复杂逻辑.</li><li>考虑人类<strong>短时记忆</strong>的限制，尽量减少读者需要同时记住的内容.</li><li>代码应该具有良好的<strong>可读性</strong>，方便快速理解.</li></ul></div></li></ul></div></li><li><p class="component-content component"><strong>Rule 10. 局部化复杂性 (Localize Complexity)</strong></p><div class="component-content component"><ul><li>核心思想：<strong>将复杂性限制在尽可能小的范围内，避免复杂性扩散到整个代码库 (Limit the scope of complexity as much as possible)</strong>.</li><li>要点：<div class="component-content component"><ul><li><strong>封装复杂逻辑</strong>，避免在多个地方重复实现.</li><li>保持接口的<strong>简洁和一致性</strong>.</li><li>通过抽象和封装来减少代码的理解难度.</li></ul></div></li></ul></div></li><li><p class="component-content component"><strong>Rule 11. 它好两倍吗？ (Is It Twice as Good?)</strong></p><div class="component-content component"><ul><li>核心思想：<strong>只有当重构后的系统比现有系统好两倍时，才值得进行大规模重构 (Don’t tear up something to replace it with something marginally better; that’s a bad strategy. Tear something up to replace it with something much better. Twice as good)</strong>.</li><li>要点：<div class="component-content component"><ul><li>重构是一项有风险的活动，只有当<strong>收益足够大</strong>时才值得进行.</li><li>如果收益不明显，则应采取<strong>增量式改进</strong>.</li><li>在架构改变时，需要考虑是否<strong>值得彻底重构</strong>.</li></ul></div></li></ul></div></li><li><p class="component-content component"><strong>Rule 12. 大型团队需要强大的约定 (Big Teams Need Strong Conventions)</strong></p><div class="component-content component"><ul><li>核心思想：<strong>大型团队需要严格的约定，以确保代码的一致性和可维护性 (Big teams need strong conventions to ensure consistency and maintainability)</strong>.</li><li>要点：<div class="component-content component"><ul><li>团队应采用统一的<strong>命名、格式化、错误处理和代码组织约定</strong>.</li><li>约定可以减少<strong>理解代码的认知负担</strong>.</li><li>统一的约定可以<strong>提高团队的效率和合作</strong>.</li></ul></div></li></ul></div></li><li><p class="component-content component"><strong>Rule 13. 找到引发雪崩的鹅卵石 (Find the Pebble That Started the Avalanche)</strong></p><div class="component-content component"><ul><li>核心思想：<strong>调试的关键在于找到导致问题的根本原因，而不是仅仅关注表面现象 (The key to debugging is finding the root cause, not just the surface symptom)</strong>.</li><li>要点：<div class="component-content component"><ul><li><strong>减少状态</strong>可以更容易定位问题.</li><li>通过<strong>断点和单步调试</strong>来定位错误.</li><li>如果问题的根本原因在代码附近，就<strong>很容易被发现</strong>.</li></ul></div></li></ul></div></li><li><p class="component-content component"><strong>Rule 14. 代码有四种类型 (Code Comes in Four Flavors)</strong></p><div class="component-content component"><ul><li>核心思想：<strong>根据问题和解决方案的复杂程度，代码可以分为四种类型 (Code can be classified into four types based on the complexity of the problem and solution)</strong>.</li><li>要点：<div class="component-content component"><ul><li><strong>简单问题，简单解决方案</strong></li><li>简单问题，复杂解决方案</li><li>复杂问题，复杂解决方案</li><li><strong>复杂问题，简单解决方案</strong></li></ul></div></li><li>强调了<strong>优秀程序员应追求使用简单方案解决问题</strong>.</li></ul></div></li><li><p class="component-content component"><strong>Rule 15. 拔掉杂草 (Pull the Weeds)</strong></p><div class="component-content component"><ul><li>核心思想：<strong>及时清理代码中的小问题，避免它们累积成大问题 (Pull out small problems in the code as they come up, to prevent them from accumulating into larger issues)</strong>.</li><li>要点：<div class="component-content component"><ul><li>清理<strong>不一致的命名、过时的注释和拼写错误</strong>.</li><li><strong>删除无用代码</strong>，保持代码的整洁.</li><li>即使是小问题，也<strong>值得花时间去修复</strong>.</li></ul></div></li></ul></div></li><li><p class="component-content component"><strong>Rule 16. 从结果出发，而不是从代码出发 (Work Backward from Your Result, Not Forward from Your Code)</strong></p><div class="component-content component"><ul><li>核心思想：<strong>在编写代码时，先考虑期望的结果，然后反向推导出实现方法 (Start with the desired result, and then reason backward to figure out how to achieve it)</strong>.</li><li>要点：<div class="component-content component"><ul><li>从<strong>最终目标</strong>出发，设计代码的结构.</li><li><strong>不要过早地陷入细节</strong>.</li><li>使用<strong>清晰的数据结构</strong>来组织代码.</li></ul></div></li></ul></div></li><li><p class="component-content component"><strong>Rule 17. 有时更大的问题更容易解决 (Sometimes the Bigger Problem Is Easier to Solve)</strong>
* 核心思想：<strong>有时，解决一个更通用的问题比解决一个特定问题更容易 (Sometimes, solving a more general problem is easier than solving a specific one)</strong>.
* 要点：</p><div class="component-content component"><ul><li>如果遇到难以解决的特定问题，考虑是否可以推广到<strong>更通用的情况</strong>.</li><li><strong>更通用的解决方案可能更简单、更优雅</strong>.</li><li>并不总是要使用通用的解决方法, 而是<strong>寻找最简单的方法</strong>.</li></ul></div></li><li><p class="component-content component"><strong>Rule 18. 让你的代码自己讲述故事 (Let Your Code Tell Its Own Story)</strong></p><div class="component-content component"><ul><li>核心思想：<strong>代码应该具有良好的自解释性，通过清晰的结构、命名和格式化来表达意图，减少对注释的依赖 (Code should be self-explanatory, with the structure, naming, and formatting clear to explain the intent, instead of relying on comments)</strong>.</li><li>要点：<div class="component-content component"><ul><li>使用<strong>有意义的变量和函数名</strong>.</li><li>通过<strong>空格和缩进组织代码结构</strong>.</li><li>用<strong>assert</strong>来验证代码的假设,而不是用注释.</li></ul></div></li></ul></div></li><li><p class="component-content component"><strong>Rule 19. 并行重构 (Rework in Parallel)</strong></p><div class="component-content component"><ul><li>核心思想：<strong>在重构代码时，并行进行，即保留旧代码的同时逐步引入新代码 (When refactoring code, do it in parallel, keeping the old code while introducing the new)</strong>.</li><li>要点：</li><li>使用<strong>适配器模式</strong>在旧代码和新代码之间切换.</li><li>通过<strong>运行时标志</strong>控制新旧代码路径.</li><li><strong>逐步迁移到新代码</strong>，降低风险.</li></ul></div></li><li><p class="component-content component"><strong>Rule 20. 做数学 (Do the Math)</strong></p><div class="component-content component"><ul><li>核心思想：<strong>在做出决策时，应该进行数学计算，而不是依赖直觉 (You should do the math in a decision rather than relying on intuition)</strong>.</li><li>要点：</li><li>权衡<strong>自动化带来的成本和收益</strong>.</li><li>使用<strong>实际的数据</strong>，而不是估计.</li><li><strong>考虑所有相关的因素</strong>.</li></ul></div></li><li><p class="component-content component"><strong>Rule 21. 有时你只需要敲钉子 (Sometimes You Just Need to Hammer the Nails)</strong></p><div class="component-content component"><ul><li>核心思想：<strong>编程有时需要直接和实际的解决方案，不要过度设计 (Sometimes, programming requires direct and practical solutions without over-engineering)</strong>.</li><li>要点：</li><li>并非所有问题都需要复杂的抽象或算法.</li><li>有时候，<strong>简单直接的代码</strong>就足够了.</li><li>不要为了追求完美而<strong>过度设计</strong>.</li></ul></div></li></ul></div></div><div id=comments class=utterances><script src=https://utteranc.es/client.js repo=smallnest/booslip.rpcx.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></article></section></main><script>var script=document.createElement("script");script.src="https://booslip.rpcx.io/js/initPost.js",document.head.appendChild(script)</script><div class=footer-main><div class="content-body footer-wraper"><div class=footer-box><div class=foot-nav><div class=foot-nav-items><div class=item><div class=logo></div><div class=email>Email: <a href=mailto:smallnest@gmail.com>smallnest@gmail.com</a></div></div><div class="item community"><div class=item-title>社交媒体</div><a href=https://github.com/smallnest target=_blank>Github</a></div><div class="item resources"><div class=item-title>友链</div><a href=https://colobu.com/ target=_blank>鸟窝</a></div></div></div><div class=bottom><div class="item copyright">鸟窝 &copy; 2025 All Rights Reserved.</div></div></div></div></div></body></html>