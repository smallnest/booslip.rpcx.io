<!doctype html><html class="js no-touch progressive-image no-reduced-motion progressive" lang=zh-hans><head><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=icon href=/img/favicon.ico><meta name=keyword content><meta property="og:url" content="https://booslip.rpcx.io/posts/learn-rust-in-a-month-of-lunches/"><meta property="og:site_name" content="竹简书摘"><meta property="og:title" content="Learn Rust in a Month of Lunches"><meta property="og:description" content="胡喝海吃一个月，学会Rust?"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-01T09:34:21+08:00"><meta property="article:modified_time" content="2025-01-01T09:34:21+08:00"><meta property="article:tag" content="Rust"><title>Learn Rust in a Month of Lunches</title>
<link rel=canonical href=/posts/learn-rust-in-a-month-of-lunches/><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/custom.css><link rel=stylesheet href=/css/search.css><link href="https://fonts.googleapis.com/css?family=Bree+Serif" rel=stylesheet><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?c80136b2ed102610dcafb84941e8df30",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head></head><body class=page-article><header><nav class=nav><div class=nav-wrapper><div class=nav-content-wrapper><div class=nav-content><a href=/ class=nav-title>竹简书摘</a><div class=nav-menu><div class=nav-item-wrapper><a href=/posts class=nav-item-content>书摘</a></div><div class=nav-item-wrapper><a href=/index.xml class=nav-item-content target=_blank>RSS</a></div></div></div></div></div></nav><script>function toggleSearchModal(){const t=`
    <div class="modal-body">
      <div id="autocomplete" onclick="event.stopPropagation();"></div>
    </div>
    `,e=document.querySelector("#modal-wrapper");if(e)document.body.removeAttribute("style"),document.body.removeChild(e);else{const e=document.createElement("div");document.body.setAttribute("style","overflow: hidden;"),e.setAttribute("id","modal-wrapper"),e.setAttribute("onclick","toggleSearchModal()"),e.innerHTML=t;const n=document.createElement("script");n.setAttribute("src","https://booslip.rpcx.io/js/algolia.js"),e.appendChild(n),document.body.append(e)}}</script></header><main id=main class=main><section><article class=article><div class=article-header><div class="category component"><div class=component-content><div class=category-eyebrow><span class="category-eyebrow__category category_original">rust
</span><span class=category-eyebrow__date>2025年1月1日</span></div></div></div><div class="pagetitle component"><div class=component-content><h1 class=hero-headline>Learn Rust in a Month of Lunches</h1></div></div><div class="component article-subhead"><div class=component-content>胡喝海吃一个月，学会Rust?</div></div><div class="tagssheet component"><div class=component-content><a href=/tags/rust class=tag>rust</a></div></div></div><div class="book-card component"><div class=book-cover><img data-src=/covers/Learn-Rust-in-a-Month-of-Lunches.png alt=书籍封面></div><div class=book-info><h1 class=book-title>Learn Rust in a Month of Lunches</h1><div class=book-meta><span>作者：Allen Wyma</span>
<span>出版日期：2024-03-26</span>
<span>出版社：Manning</span></div><div class=book-description>本书涵盖了Rust编程语言的方方面面。它从基础概念如变量、数据类型和内存管理开始，逐步深入到更高级的主题，例如所有权、生命周期、错误处理、并发编程和异步编程。书中包含大量的代码示例和练习，旨在帮助读者在短时间内掌握Rust编程。此外，书中还介绍了一些常用的外部库，以及如何使用Cargo构建和管理Rust项目。</div></div></div><div class=pagebody><div class="component-content component"><ul><li><p class="component-content component"><strong>第一章：Rust 基础入门</strong></p><div class="component-content component"><ul><li><strong>核心概念：</strong> 本章主要介绍了 Rust 的基本语法和概念，包括变量声明、代码块、打印输出、类型转换和字符串。</li><li><strong>变量与代码块：</strong><div class="component-content component"><ul><li>使用 <code>let</code> 关键字声明变量，代码块用 <code>{}</code> 表示。变量的作用域（lifetime）限制在代码块内部。</li><li><strong>Shadowing</strong> (遮蔽) 是指用新的 <code>let</code> 绑定同名变量，使之前的变量失效。</li><li>变量的类型通常由 Rust 自动推断，但可以使用 <code>as</code> 关键字进行显式类型转换。</li></ul></div></li><li><strong>打印输出:</strong><div class="component-content component"><ul><li><code>println!</code> 宏用于打印输出，<code>{}</code> 用来捕获变量的值。<code>{:?}</code> 用于调试输出，<code>{:#?}</code> 用于更美观的调试输出，可以分行显示结构体等复杂类型的内容。</li><li><code>print!</code> 宏与 <code>println!</code> 类似，但不添加换行符。</li><li>可以使用 <code>r#""#</code> 来创建原始字符串，避免转义字符的麻烦。</li><li>在字符串前加 <code>b</code> 可以打印字符串的字节表示。</li></ul></div></li><li><strong>字符串类型：</strong> <code>&amp;str</code> 是一种字符串切片类型，后续章节会详细介绍。</li></ul></div></li><li><p class="component-content component"><strong>第二章：内存、变量与所有权</strong></p><div class="component-content component"><ul><li><strong>核心概念：</strong> 本章深入探讨了 Rust 的内存管理机制，包括所有权、借用和引用。</li><li><strong>所有权：</strong> Rust 通过所有权系统来管理内存，每个值都有一个所有者。</li><li><strong>引用：</strong><div class="component-content component"><ul><li><strong>不可变引用</strong>（<code>&</code>）允许多个读取者同时访问数据，但不能修改。</li><li><strong>可变引用</strong>（<code>&amp;mut</code>）允许一个写入者修改数据，但不能同时存在其他引用。</li></ul></div></li><li><strong>打印输出格式化:</strong> <code>{:}</code> 用于显示打印, <code>{:?}</code>用于debug打印，<code>{:#?}</code>用于美化debug打印。可以使用 <code>"{:padding_char^min_length}"</code> 来控制打印的对齐和填充。<div class="component-content component"><ul><li>例如，<code>println!("{:ㅎ^11}", letter);</code> 会在字母 &ldquo;a&rdquo; 的左右两侧填充韩文字符 ㅎ，总长度为 11。</li></ul></div></li></ul></div></li><li><p class="component-content component"><strong>第三章：更复杂的类型</strong></p><div class="component-content component"><ul><li><strong>核心概念：</strong> 本章介绍了 Rust 中更复杂的数据类型和控制流，包括元组、枚举、结构体、<code>if</code> 语句、<code>match</code> 语句和循环。</li><li><strong>元组：</strong> 元组可以将多个不同类型的值组合在一起。可以使用 <code>_</code> 忽略元组中不需要的值。</li><li><strong>控制流：</strong><div class="component-content component"><ul><li><code>if</code> 语句用于根据条件执行代码块。</li><li><code>match</code> 语句用于模式匹配，可以根据不同的值执行不同的代码块。可以使用 <code>_</code> 作为通配符，匹配其他情况。<code>if</code> 关键字可以用于 <code>match</code> 语句中进行条件匹配。</li><li>循环包括 <code>loop</code>、<code>for</code> 等，<code>loop</code> 会一直循环直到 <code>break</code>。<code>for</code> 循环可以迭代一个范围，如 <code>0..3</code> (不包含3) 和 <code>0..=3</code> （包含3）。</li></ul></div></li><li><strong>结构体:</strong><div class="component-content component"><ul><li>结构体 (struct) 用于将多个相关的值组合成一个数据结构。可以使用 <code>struct ColorRgb(u8, u8, u8);</code> 定义一个元组结构体，也可以使用 <code>struct SizeAndColor { size: u32, color: ColorRgb, }</code> 定义一个命名结构体。</li></ul></div></li><li><strong>枚举:</strong><div class="component-content component"><ul><li>枚举 (enum) 用于定义一组可能的值，例如 <code>enum ThingsInTheSky { Sun, Stars, }</code>。可以使用 <code>::</code> 来选择枚举的变体。</li></ul></div></li></ul></div></li><li><p class="component-content component"><strong>第四章：构建自定义类型</strong></p><div class="component-content component"><ul><li><strong>核心概念：</strong> 本章继续深入探讨了 Rust 的自定义类型，包括如何在枚举中存储数据，以及 <code>use</code> 关键字的用法。</li><li><strong>枚举变体中的数据：</strong> 枚举的变体可以携带数据，例如 <code>enum Number { U32(u32), I32(i32), }</code>。</li><li><strong><code>use</code> 关键字：</strong> <code>use</code> 关键字用于简化代码，可以导入枚举的变体。<code>use</code> 可以避免在使用枚举变体时重复书写枚举名称。<code>use std::mem::size_of_val;</code> 可以使用 <code>size_of_val()</code> 函数，而无需每次都写 <code>std::mem::</code>。</li></ul></div></li><li><p class="component-content component"><strong>第五章：泛型、Option 和 Result</strong></p><div class="component-content component"><ul><li><strong>核心概念：</strong> 本章介绍了 Rust 的泛型、<code>Option</code> 和 <code>Result</code> 类型，用于编写更灵活、更健壮的代码。</li><li><strong>泛型：</strong> 泛型允许函数或结构体接受多种类型，可以使用 <code>&lt;T></code> 来声明泛型类型。<code>where</code> 关键字用于在泛型类型上添加约束，例如 <code>where T: Display</code> 表示 <code>T</code> 必须实现 <code>Display</code> trait。</li><li><strong><code>Option</code> 类型：</strong> <code>Option</code> 类型用于处理可能为空的值，它有两个变体：<code>Some(T)</code> 和 <code>None</code>。</li><li><strong><code>Result</code> 类型：</strong> <code>Result</code> 类型用于处理可能失败的操作，它有两个变体：<code>Ok(T)</code> 和 <code>Err(E)</code>。<code>Err</code> 变体通常包含描述错误信息的类型。</li><li><strong>模式匹配：</strong> 可以使用 <code>match</code> 语句对 <code>Option</code> 和 <code>Result</code> 类型进行模式匹配，处理不同的情况。</li></ul></div></li><li><p class="component-content component"><strong>第六章：更多集合类型和错误处理</strong></p><div class="component-content component"><ul><li><strong>核心概念：</strong> 本章介绍了更多的集合类型和 Rust 的错误处理机制，包括 <code>?</code> 运算符和 <code>panic!</code> 宏。</li><li><strong><code>?</code> 运算符：</strong> <code>?</code> 运算符用于简化 <code>Result</code> 类型的错误处理，如果结果是 <code>Ok</code>，则返回其值，否则提前返回错误。</li><li><strong><code>panic!</code> 宏：</strong> <code>panic!</code> 宏用于抛出不可恢复的错误，程序会终止。<code>assert!</code>、<code>assert_eq!</code> 和 <code>assert_ne!</code> 宏用于在测试中检查条件是否满足。</li><li><strong>集合类型：</strong> 本章提到 Rust 还有很多集合类型，例如 <code>BinaryHeap</code> (二叉堆), 但没有详细介绍。</li></ul></div></li><li><p class="component-content component"><strong>第七章：Traits：让不同的类型做相同的事</strong></p><div class="component-content component"><ul><li><strong>核心概念：</strong> 本章重点介绍了 Rust 的 trait，用于定义共享行为，实现多态。</li><li><strong>Traits:</strong> Traits 可以被不同的类型实现，从而实现代码的复用，类似于其他语言的接口 (interface)。<code>T: Display</code> 表示类型 <code>T</code> 必须实现 <code>Display</code> trait。</li><li><strong><code>unwrap_or</code> 和 <code>unwrap_or_else</code> 方法：</strong> <code>unwrap_or</code> 方法在 <code>Option</code> 为 <code>None</code> 或 <code>Result</code> 为 <code>Err</code> 时返回一个默认值。<code>unwrap_or_else</code> 方法则接收一个闭包来生成默认值。</li><li><strong>生命周期:</strong> <code>'a</code> 表示生命周期，例如 <code>struct City&lt;'a> { name: &'a str, date_founded: u32 }</code>，表示 <code>name</code> 的生命周期至少与 <code>City</code> 结构体一样长。</li></ul></div></li><li><p class="component-content component"><strong>第十章：生命周期</strong></p><div class="component-content component"><ul><li><strong>核心概念:</strong> 本章主要探讨了生命周期和内部可变性。</li><li><strong>生命周期:</strong> 生命周期用于确保引用不会悬空，<code>&lt;'a></code> 用于声明生命周期。</li><li><strong>内部可变性:</strong> <code>Cell</code>，<code>RefCell</code>，<code>Mutex</code>和 <code>RwLock</code> 这些类型提供了内部可变性，允许在不可变类型中修改数据。<div class="component-content component"><ul><li><code>Cell</code> 类型用于包装实现了 <code>Copy</code> trait 的类型，可以使用 <code>.get()</code> 和 <code>.set()</code> 方法修改其值。</li><li><code>RefCell</code> 类型使用 <code>.borrow()</code> 和 <code>.borrow_mut()</code> 方法提供运行时借用检查，允许多个不可变借用或一个可变借用。</li><li><code>Mutex</code> 和 <code>RwLock</code> 类型用于多线程编程，保证线程安全地访问共享数据。<code>Mutex</code> 提供互斥访问，<code>RwLock</code> 提供读写锁，允许多个读操作或一个写操作。</li></ul></div></li></ul></div></li><li><p class="component-content component"><strong>第十一章：多线程及其他</strong></p><div class="component-content component"><ul><li><strong>核心概念：</strong> 本章涵盖了多线程、<code>todo!</code> 宏、类型别名、<code>Cow</code> 类型和 <code>Rc</code> 类型等主题。</li><li><strong>多线程：</strong> 可以使用 <code>std::thread::spawn()</code> 创建新线程，使用 <code>JoinHandle</code> 等待线程结束。<code>move</code> 关键字用于将变量的所有权转移到闭包中。</li><li><strong><code>todo!</code> 宏：</strong> <code>todo!</code> 宏用于标记代码中尚未实现的部分，让编译器暂时忽略错误。</li><li><strong>类型别名：</strong> 使用 <code>type</code> 关键字创建类型别名，可以给现有类型取一个新名字。</li><li><strong><code>Cow</code> 类型：</strong> <code>Cow</code> 类型（Copy-on-Write）用于处理借用或拥有的数据，可以在需要时进行复制，提高效率。</li><li><strong><code>Rc</code> 类型：</strong> <code>Rc</code> 类型（Reference Counting）用于在多个所有者之间共享数据，当最后一个 <code>Rc</code> 实例被删除时，数据会被释放。</li></ul></div></li><li><p class="component-content component"><strong>第十二章：闭包、泛型和线程</strong></p><div class="component-content component"><ul><li><strong>核心概念：</strong> 本章深入探讨了闭包、泛型和线程，并介绍了闭包的三种 trait：<code>Fn</code>、<code>FnMut</code> 和 <code>FnOnce</code>。</li><li><strong>闭包：</strong> 闭包是一种可以捕获环境的匿名函数，具有三种 trait：<div class="component-content component"><ul><li><code>Fn</code>：捕获环境中的不可变引用。</li><li><code>FnMut</code>：捕获环境中的可变引用。</li><li><code>FnOnce</code>：捕获环境中的值，只能调用一次。</li></ul></div></li><li><strong>闭包作为参数：</strong> 函数可以接受闭包作为参数，并使用泛型来指定闭包的 trait。可以使用 <code>impl Trait</code> 来表示返回闭包的函数。</li><li><strong>线程:</strong> 本章继续讨论了线程，主要介绍了如何使用闭包在线程中执行代码。</li></ul></div></li><li><p class="component-content component"><strong>第十三章：Box 和 Rust 文档</strong></p><div class="component-content component"><ul><li><strong>核心概念：</strong> 本章介绍了 <code>Box</code> 类型、如何阅读 Rust 文档，以及一些高级错误处理技巧。</li><li><strong><code>Box</code> 类型：</strong> <code>Box</code> 类型用于在堆上分配内存，例如 <code>Box&lt;dyn Error></code> 用于存储实现了 <code>Error</code> trait 的类型。</li><li><strong>读取 Rust 文档：</strong> Rust 文档可以使用 <code>cargo doc</code> 命令生成。可以通过点击 <code>[src]</code> 查看源代码。</li><li><strong>高级错误处理：</strong> 可以使用 <code>thiserror</code> crate 创建自定义错误类型，并使用 <code>#[from]</code> 注解简化错误转换。还可以使用 blanket trait implementations 来处理所有实现了 <code>std::error::Error</code> 的类型。</li></ul></div></li><li><p class="component-content component"><strong>第十四章：测试和从测试构建代码</strong></p><div class="component-content component"><ul><li><strong>核心概念：</strong> 本章介绍了 Rust 的测试框架和如何使用测试驱动开发 (TDD) 方法构建代码。</li><li><strong>测试：</strong> 可以使用 <code>#[test]</code> 注解标记测试函数。<code>assert_eq!</code> 宏用于检查两个值是否相等，<code>#[should_panic]</code> 注解用于标记应该 panic 的测试。</li><li><strong>测试驱动开发 (TDD):</strong> 本章通过一个简单的减法计算器例子，说明了如何先写测试，再实现代码。</li></ul></div></li><li><p class="component-content component"><strong>第十五章：Default、构建者模式和 Deref</strong></p><div class="component-content component"><ul><li><strong>核心概念：</strong> 本章介绍了 <code>Default</code> trait、构建者模式和 <code>Deref</code> trait。</li><li><strong><code>Default</code> trait：</strong> <code>Default</code> trait 用于为类型提供默认值，可以使用 <code>::default()</code> 方法获取默认值。</li><li><strong>构建者模式：</strong> 构建者模式用于创建复杂对象，提供链式调用的方法来设置对象的属性。</li><li><strong><code>Deref</code> 和 <code>DerefMut</code> trait：</strong> <code>Deref</code> trait 允许像使用原始类型一样使用智能指针。<code>DerefMut</code> trait 允许可变借用 。</li></ul></div></li><li><p class="component-content component"><strong>第十六章：Const、”unsafe” Rust 和外部包</strong></p><div class="component-content component"><ul><li><strong>核心概念：</strong> 本章介绍了 <code>const</code>、<code>unsafe</code> Rust 和如何使用外部 crate。</li><li><strong><code>const</code>：</strong> <code>const</code> 关键字用于定义常量，<code>const</code> 可以用于泛型参数 。<code>const fn</code> 用于声明可以在编译时求值的函数 。</li><li><strong><code>unsafe</code> Rust：</strong> <code>unsafe</code> 关键字用于标记不安全的 Rust 代码，例如直接操作内存 。</li><li><strong>外部包:</strong> 可以使用 <code>Cargo.toml</code> 文件管理项目依赖，并使用 <code>use</code> 关键字导入外部 crate 的模块。</li></ul></div></li><li><p class="component-content component"><strong>第十七章：Anyhow 和 Thiserror</strong></p><div class="component-content component"><ul><li><strong>核心概念：</strong> 本章介绍了 <code>Anyhow</code> 和 <code>Thiserror</code> 两个常用的错误处理 crate。</li><li><strong><code>Anyhow</code>：</strong> <code>Anyhow</code> 提供了 <code>anyhow::Error</code> 类型，用于快速处理错误。<code>anyhow!</code> 宏用于快速创建错误。</li><li><strong><code>Thiserror</code>：</strong> <code>Thiserror</code> 允许使用 <code>#[derive(Error)]</code> 为自定义错误类型派生 <code>Error</code> trait。</li></ul></div></li><li><p class="component-content component"><strong>第十八章：文件操作</strong></p><div class="component-content component"><ul><li><strong>核心概念：</strong> 本章介绍了如何在 Rust 中进行文件操作，包括创建、打开、写入和读取文件。</li><li><strong>文件操作：</strong> <code>std::fs::File</code> 用于表示文件，可以使用 <code>File::create()</code> 创建新文件，<code>File::open()</code> 打开现有文件， <code>write_all()</code> 写入字节数据, <code>read_to_string()</code> 读取文件内容。</li><li><strong><code>OpenOptions</code>：</strong> <code>OpenOptions</code> 结构体用于自定义文件操作的行为，如只创建文件，不覆盖已有文件。</li></ul></div></li><li><p class="component-content component"><strong>第十九章：异步编程</strong></p><div class="component-content component"><ul><li><strong>核心概念：</strong> 本章介绍了 Rust 的异步编程，使用了 <code>tokio</code> crate。</li><li><strong>异步编程：</strong> 使用 <code>async</code> 关键字声明异步函数，使用 <code>.await</code> 等待异步操作完成。 <code>#[tokio::main]</code> 用于标记异步的 main 函数。可以使用 <code>tokio::try_join!</code> 来等待多个异步任务完成，并在其中任何一个任务失败时返回错误。</li></ul></div></li><li><p class="component-content component"><strong>第二十章：操作符重载和其他类型</strong></p><div class="component-content component"><ul><li><strong>核心概念：</strong> 本章介绍了 Rust 的操作符重载、关联类型和 <code>bool</code> 类型。</li><li><strong>操作符重载：</strong> 通过实现 <code>std::ops</code> 中的 trait 可以实现操作符重载，例如 <code>Add</code>、<code>Sub</code>、<code>Mul</code> 和 <code>Div</code>。</li><li><strong>关联类型和关联常量:</strong> Trait 可以包含关联类型和常量，使用 <code>const</code> 定义常量。</li><li><strong>bool 类型:</strong> Rust 的 <code>bool</code> 类型只有 <code>true</code> 和 <code>false</code> 两个值。</li></ul></div></li><li><p class="component-content component"><strong>第二十一章：继续探索</strong></p><div class="component-content component"><ul><li><strong>核心概念：</strong> 本章介绍了 Rust 标准库中的一些其他重要功能，包括 panic hook 和 backtrace。</li><li><strong>Panic Hook：</strong> 可以使用 <code>std::panic::set_hook</code> 设置自定义的 panic hook，在程序 panic 时执行。</li><li><strong>Backtrace：</strong> Backtrace 用于追踪程序调用栈，可以帮助调试错误。</li><li><strong><code>unreachable!</code> 宏:</strong> <code>unreachable!</code> 宏用于标记永远不会被执行的代码。</li></ul></div></li><li><p class="component-content component"><strong>第二十二章：编写自定义宏</strong></p><div class="component-content component"><ul><li><strong>核心概念：</strong> 本章介绍了如何编写自定义宏，用于代码生成。</li><li><strong>宏：</strong> 可以使用 <code>macro_rules!</code> 定义宏。宏可以使用 <code>ident</code>、<code>expr</code> 和 <code>tt</code> 等类型匹配不同的输入。</li><li><strong>宏的重复：</strong> 使用 <code>$(...)</code> 和 <code>*</code> 或 <code>+</code> 可以匹配零个或多个、一个或多个重复的标记。<code>?</code> 用于表示零个或一个重复。</li><li><strong>标准库宏：</strong> <code>format_args!</code> 宏 用于格式化字符串，<code>todo!</code> 宏用于标记未实现的代码。<code>dbg!</code> 宏用于调试打印。 <code>matches!</code> 宏用于匹配表达式和模式。</li></ul></div></li><li><p class="component-content component"><strong>第二十三章：终端时钟和秒表</strong></p><div class="component-content component"><ul><li><strong>核心概念：</strong> 本章展示了如何使用 Rust 构建一个终端时钟和秒表程序。</li><li><strong>Ratatui:</strong> 本章使用了 <code>ratatui</code> crate 来构建终端界面。</li><li><strong>程序结构：</strong> 秒表应该具有三种状态：未启动、运行和停止。</li></ul></div></li><li><p class="component-content component"><strong>第二十四章：Web 服务</strong></p><div class="component-content component"><ul><li><strong>核心概念:</strong> 本章介绍了如何构建一个简单的 Web 应用程序。</li><li><strong>Axum:</strong> 本章使用了 <code>Axum</code> crate 来构建 Web 服务。</li><li><strong>静态变量:</strong> 提到了如何使用 <code>Arc&lt;Mutex></code> 来在多线程环境中使用静态变量，但没有深入展开。</li></ul></div></li></ul></div><p class="component-content component">总结来说，这本书从 Rust 的基础语法开始，逐步深入到更高级的概念，如所有权、生命周期、泛型、闭包、多线程、宏和外部 crate 等，并通过实际例子展示了如何使用 Rust 构建各种应用程序。</p></div><div id=comments class=utterances><script src=https://utteranc.es/client.js repo=smallnest/booslip.rpcx.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></article></section></main><script>var script=document.createElement("script");script.src="https://booslip.rpcx.io/js/initPost.js",document.head.appendChild(script)</script><div class=footer-main><div class="content-body footer-wraper"><div class=footer-box><div class=foot-nav><div class=foot-nav-items><div class=item><div class=logo></div><div class=email>Email: <a href=mailto:smallnest@gmail.com>smallnest@gmail.com</a></div></div><div class="item community"><div class=item-title>社交媒体</div><a href=https://github.com/smallnest target=_blank>Github</a></div><div class="item resources"><div class=item-title>友链</div><a href=https://colobu.com/ target=_blank>鸟窝</a></div></div></div><div class=bottom><div class="item copyright">鸟窝 &copy; 2025 All Rights Reserved.</div></div></div></div></div></body></html>