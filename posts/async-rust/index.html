<!doctype html><html class="js no-touch progressive-image no-reduced-motion progressive" lang=zh-hans><head><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=icon href=/img/favicon.ico><meta name=keyword content><meta property="og:url" content="https://booslip.rpcx.io/posts/async-rust/"><meta property="og:site_name" content="竹简书摘"><meta property="og:title" content="Async Rust"><meta property="og:description" content="异步Rust：释放无畏并发能力"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-28T18:58:34+08:00"><meta property="article:modified_time" content="2024-12-28T18:58:34+08:00"><meta property="article:tag" content="Rust"><meta property="article:tag" content="并发"><title>Async Rust</title>
<link rel=canonical href=/posts/async-rust/><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/custom.css><link rel=stylesheet href=/css/search.css><link href="https://fonts.googleapis.com/css?family=Bree+Serif" rel=stylesheet><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?c80136b2ed102610dcafb84941e8df30",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head></head><body class=page-article><header><nav class=nav><div class=nav-wrapper><div class=nav-content-wrapper><div class=nav-content><a href=/ class=nav-title>竹简书摘</a><div class=nav-menu><div class=nav-item-wrapper><a href=/posts class=nav-item-content>书摘</a></div><div class=nav-item-wrapper><a href=/index.xml class=nav-item-content target=_blank>RSS</a></div></div></div></div></div></nav><script>function toggleSearchModal(){const t=`
    <div class="modal-body">
      <div id="autocomplete" onclick="event.stopPropagation();"></div>
    </div>
    `,e=document.querySelector("#modal-wrapper");if(e)document.body.removeAttribute("style"),document.body.removeChild(e);else{const e=document.createElement("div");document.body.setAttribute("style","overflow: hidden;"),e.setAttribute("id","modal-wrapper"),e.setAttribute("onclick","toggleSearchModal()"),e.innerHTML=t;const n=document.createElement("script");n.setAttribute("src","https://booslip.rpcx.io/js/algolia.js"),e.appendChild(n),document.body.append(e)}}</script></header><main id=main class=main><section><article class=article><div class=article-header><div class="category component"><div class=component-content><div class=category-eyebrow><span class="category-eyebrow__category category_original">rust
</span><span class=category-eyebrow__date>2024年12月28日</span></div></div></div><div class="pagetitle component"><div class=component-content><h1 class=hero-headline>Async Rust</h1></div></div><div class="component article-subhead"><div class=component-content>异步Rust：释放无畏并发能力</div></div><div class="tagssheet component"><div class=component-content><a href=/tags/rust class=tag>rust
</a><a href=/tags/%E5%B9%B6%E5%8F%91 class=tag>并发</a></div></div></div><div class="book-card component"><div class=book-cover><img data-src=/covers/async-rust.jpg alt=书籍封面></div><div class=book-info><h1 class=book-title>Async Rust</h1><div class=book-meta><span>作者：Maxwell Flitton</span>
<span>出版日期：2024-12-17</span>
<span>出版社：O'Reilly Media, Inc.</span></div><div class=book-description>本书详细讲解了异步Rust编程，涵盖了异步编程基础概念（例如Future、Task、async/await），自定义异步运行时构建，网络编程集成，Actor模型，反应式编程以及测试策略等方面。 它通过具体的代码示例和设计模式，帮助读者理解和掌握异步Rust编程的技巧，并探讨了并发编程中常见问题的解决方法，例如死锁和回压。书中还介绍了如何构建高效、可扩展的异步系统。</div></div></div><div class=pagebody><p class="component-content component">好的，我将按照您的要求，对每个章节的内容进行总结，并尽可能地包含关键代码，使其内容详实且易于理解。</p><div class="component-content pagebody component"><h2 id=第一章异步简介 class=pagebody-header>第一章：异步简介</h2></div><p class="component-content component">本章主要介绍了异步编程的概念以及在Rust中的应用。</p><div class="component-content component"><ul><li><strong>什么是异步？</strong> 异步编程允许任务并发执行，特别适用于处理I/O密集型操作，如网络请求或文件处理。与传统的同步编程不同，异步编程可以更有效地利用系统资源，提高应用程序的性能，而无需额外的CPU核心。</li><li><strong>进程和线程：</strong> 本章还介绍了进程和线程的基本概念。虽然线程可以实现并发，但当任务可以等待时，异步编程可以释放CPU资源，避免阻塞。</li><li><strong>为何需要异步？</strong> 随着硬件性能提升的放缓，以及微服务等系统对I/O网络调用的需求增加，我们需要更有效地利用资源。异步编程提供了一种解决方案，可以在不增加线程的情况下提高程序速度。</li><li><strong>异步示例</strong>：<div class="component-content component"><ul><li><strong>同步代码示例：</strong> 通过连续发送四个相同的网络请求，演示了同步代码的执行方式。 每个请求完成后才会开始下一个请求。</li></ul></div><div class="component-content pagebody component code"><div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> first <span style=color:#f92672>=</span> reqwest::get(url);
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> second <span style=color:#f92672>=</span> reqwest::get(url);
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> third <span style=color:#f92672>=</span> reqwest::get(url);
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> fourth <span style=color:#f92672>=</span> reqwest::get(url);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> first <span style=color:#f92672>=</span> first.<span style=color:#66d9ef>await</span><span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> second <span style=color:#f92672>=</span> second.<span style=color:#66d9ef>await</span><span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> third <span style=color:#f92672>=</span> third.<span style=color:#66d9ef>await</span><span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> fourth <span style=color:#f92672>=</span> fourth.<span style=color:#66d9ef>await</span><span style=color:#f92672>?</span>;</span></span></code></pre></div></div></div><div class="component-content component"><ul><li><strong>异步代码示例：</strong> 使用 <code>tokio::join!</code> 宏同时运行多个任务，展示了异步编程的优势，使程序速度提升了4.7倍，而无需增加线程。</li></ul></div></li></ul></div><div class="component-content pagebody component code"><div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> (_, _, _, _) <span style=color:#f92672>=</span> tokio::join!(
</span></span><span style=display:flex><span>    reqwest::get(url),
</span></span><span style=display:flex><span>    reqwest::get(url),
</span></span><span style=display:flex><span>    reqwest::get(url),
</span></span><span style=display:flex><span>    reqwest::get(url),
</span></span><span style=display:flex><span>);</span></span></code></pre></div></div></div><div class="component-content pagebody component"><h2 id=第二章基础异步rust class=pagebody-header>第二章：基础异步Rust</h2></div><p class="component-content component">本章深入探讨了Rust中异步编程的基础概念，包括Future、Waker以及如何创建自定义的Future。</p><div class="component-content component"><ul><li><strong>Future trait：</strong> Future trait是Rust异步编程的核心，代表一个可能尚未完成的异步计算。Future通过<code>poll</code>方法进行轮询，以检查是否已完成。<code>poll</code>方法返回<code>Poll::Pending</code>或<code>Poll::Ready</code>。<div class="component-content component"><ul><li><strong>自定义Future示例：</strong> <code>CounterFuture</code> 结构体演示了如何实现 <code>Future</code> trait，每次轮询时增加计数，并在计数达到5时返回 <code>Poll::Ready</code>.</li></ul></div><div class="component-content pagebody component code"><div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> Future <span style=color:#66d9ef>for</span> CounterFuture {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Output</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>u32</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>poll</span>(
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>mut</span> self: <span style=color:#a6e22e>Pin</span><span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>mut</span> Self<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>        cx: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Context<span style=color:#f92672>&lt;</span>&#39;_<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    ) -&gt; <span style=color:#a6e22e>Poll</span><span style=color:#f92672>&lt;</span>Self::Output<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        self.count <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        println!(<span style=color:#e6db74>&#34;polling with result: </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, self.count);
</span></span><span style=display:flex><span>        std::thread::sleep(Duration::from_secs(<span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self.count <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>5</span> {
</span></span><span style=display:flex><span>            cx.waker().wake_by_ref();
</span></span><span style=display:flex><span>            Poll::Pending
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            Poll::Ready(self.count)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></div></li><li><strong>Pin和Context</strong>：<div class="component-content component"><ul><li><strong>Pin:</strong> 为了防止Future在执行过程中被移动到内存中的其他位置，使用了<code>Pin</code>，保证了自引用结构的安全性。</li><li><strong>Context:</strong> <code>Context</code> 结构体包含了 <code>Waker</code>，用于通知执行器在Future准备好继续执行时唤醒任务。</li></ul></div></li><li><strong>Waker：</strong> <code>Waker</code> 用于在Future等待某些外部事件（如I/O操作完成）时，唤醒Future。<div class="component-content component"><ul><li><strong>远程唤醒示例：</strong> 通过通道模拟外部调用，展示了如何从外部唤醒Future，以及使用<code>Waker</code>。</li></ul></div></li><li><strong>共享数据：</strong> 介绍了如何在异步任务之间共享数据，例如使用 <code>Arc&lt;Mutex&lt;>></code> 来保护共享的可变数据，并使用 <code>Condvar</code> 进行条件通知。<div class="component-content component"><ul><li><strong>共享数据竞争示例：</strong> 展示了使用 <code>Mutex</code> 保护共享数据时可能出现的竞争条件，以及如何使用更高级的抽象（如 <code>async</code> 函数）来简化实现。</li></ul></div></li><li><strong>AsyncWriteFuture：</strong> 一个实现了Future trait的结构体，展示了如何在异步环境中进行写入操作，其中使用 <code>try_lock</code> 来尝试获取锁，并在无法立即获取锁时返回 <code>Poll::Pending</code>。</li></ul></div><div class="component-content pagebody component"><h2 id=第三章构建我们自己的异步队列 class=pagebody-header>第三章：构建我们自己的异步队列</h2></div><p class="component-content component">本章介绍了如何构建自定义的异步运行时，包括任务队列和线程池，以及如何使用通道在线程之间传递任务。</p><div class="component-content component"><ul><li><strong>异步运行时:</strong> 运行时负责执行异步任务，包括任务调度、事件循环和资源管理。<div class="component-content component"><ul><li><strong>运行时比喻：</strong> 将运行时比作干洗店，Future是衣服上的标签，描述清洗方法，而Task是带有号码的取衣凭证。</li></ul></div></li><li><strong>任务队列：</strong> 使用 <code>flume::unbounded</code> 创建无界通道作为任务队列，并通过多个线程消费队列中的任务。</li><li><strong>多队列和优先级：</strong> 使用枚举 <code>FutureType</code> 表示任务优先级，并使用不同的队列处理不同优先级的任务。<div class="component-content component"><ul><li><strong>自定义任务调度:</strong> 可以通过为高优先级和低优先级任务设置不同的队列来实现任务调度。</li></ul></div></li><li><strong><code>spawn_task!</code> 宏：</strong> 创建一个宏来简化任务的生成，并允许指定任务的优先级。</li><li><strong>自定义 <code>join</code> 宏:</strong> 创建一个宏来等待多个任务完成并返回结果，避免重复阻塞主函数。</li><li><strong>配置运行时：</strong> 介绍了如何配置自定义运行时，例如通过设置环境变量来定义高优先级和低优先级队列的线程数。</li><li><strong>Tokio运行时：</strong> 展示了如何使用Tokio库配置运行时，并与自定义运行时进行比较，同时也指出Tokio也使用了宏来设置运行时。</li></ul></div><div class="component-content pagebody component"><h2 id=第四章将网络集成到我们自己的异步运行时 class=pagebody-header>第四章：将网络集成到我们自己的异步运行时</h2></div><p class="component-content component">本章介绍了如何将网络功能集成到自定义的异步运行时中，包括使用 <code>hyper</code> 库进行HTTP请求，并实现 <code>AsyncRead</code> 和 <code>AsyncWrite</code> trait。</p><div class="component-content component"><ul><li><strong>HTTP客户端：</strong> 使用 <code>hyper</code> 库创建HTTP客户端，发送HTTP和HTTPS请求。</li><li><strong>Executor和Connector:</strong> 介绍了 <code>Executor</code> 和 <code>Connector</code> 的概念。其中 <code>Connector</code> 用于处理连接， <code>Executor</code> 用于执行异步任务。</li><li><strong>自定义Stream：</strong> 创建一个名为 <code>CustomStream</code> 的枚举，支持HTTP和HTTPS连接，使用 <code>Async&lt;TcpStream></code> 和 <code>TlsStream&lt;Async&lt;TcpStream>></code> 。</li><li><strong>Service Trait：</strong> 为自定义的连接器结构体实现<code>hyper::service::Service</code> trait。</li><li><strong>AsyncRead Trait：</strong> 介绍了 <code>AsyncRead</code> trait，并通过实现 <code>poll_read</code> 方法将 <code>CustomStream</code> 集成到异步任务系统中。</li><li><strong>AsyncWrite Trait：</strong> 介绍了 <code>AsyncWrite</code> trait，并通过实现 <code>poll_write</code>、<code>poll_flush</code> 和 <code>poll_shutdown</code> 方法来异步写入和关闭连接。</li><li><strong>连接和运行客户端：</strong> 展示如何连接到服务器并发送请求，测试 <code>CustomStream</code> 的实现。</li><li><strong>mio crate:</strong> 使用 <code>mio</code> crate 创建TCP服务器，并使用token来区分不同的socket。</li><li><strong>Future 和 Mio Poll:</strong> 将 <code>mio</code> 的socket轮询功能集成到Future中，允许异步地等待socket事件。</li><li><strong>客户端发送数据：</strong> 创建客户端代码以发送数据到服务器，并使用 <code>ErrorKind::WouldBlock</code> 处理阻塞情况。</li></ul></div><div class="component-content pagebody component"><h2 id=第五章使用协程进行异步编程 class=pagebody-header>第五章：使用协程进行异步编程</h2></div><p class="component-content component">本章介绍了如何使用 Rust 的协程（coroutines）进行异步编程，并使用 <code>rand</code> 创建随机数。</p><div class="component-content component"><ul><li><strong>协程基础：</strong> 协程是一种轻量级的并发机制，可以通过 <code>Coroutine</code> trait 实现。 协程可以暂停和恢复执行，这使得它适用于异步编程。</li><li><strong>协程和 Future 接口：</strong> 将协程的输出映射到等价的异步输出，实现了协程和 Future 的结合。</li></ul></div><div class="component-content pagebody component code"><div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span> <span style=color:#66d9ef>impl</span> Future <span style=color:#66d9ef>for</span> MutexCoRoutine {
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Output</span> <span style=color:#f92672>=</span> ();
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>poll</span>(<span style=color:#66d9ef>mut</span> self: <span style=color:#a6e22e>Pin</span><span style=color:#f92672>&lt;&amp;</span><span style=color:#66d9ef>mut</span> Self<span style=color:#f92672>&gt;</span>, cx: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> Context<span style=color:#f92672>&lt;</span>&#39;_<span style=color:#f92672>&gt;</span>)
</span></span><span style=display:flex><span>         -&gt; <span style=color:#a6e22e>Poll</span><span style=color:#f92672>&lt;</span>Self::Output<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>match</span> Pin::new(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self).resume(()) {
</span></span><span style=display:flex><span>             CoroutineState::Complete(_) <span style=color:#f92672>=&gt;</span> Poll::Ready(()),
</span></span><span style=display:flex><span>             CoroutineState::Yielded(_) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                 cx.waker().wake_by_ref();
</span></span><span style=display:flex><span>                 Poll::Pending
</span></span><span style=display:flex><span>             },
</span></span><span style=display:flex><span>         }
</span></span><span style=display:flex><span>     }
</span></span><span style=display:flex><span> }</span></span></code></pre></div></div></div><div class="component-content component"><ul><li><strong>基本测试：</strong> 构建了一个简单的测试，演示了如何使用协程进行文件写入。</li><li><strong>反应式编程</strong>：提到了反应式编程，这会在第六章中详细介绍。</li></ul></div><div class="component-content pagebody component"><h2 id=第六章反应式编程 class=pagebody-header>第六章：反应式编程</h2></div><p class="component-content component">本章介绍了反应式编程的概念，以及如何使用异步编程来构建一个基本的反应式系统。</p><div class="component-content component"><ul><li><strong>反应式编程：</strong> 是一种编程范式，其中代码对数据值或事件的变化作出反应。反应式编程允许构建实时动态响应变化的系统。</li><li><strong>观察者模式：</strong> 通过实现观察者模式来构建一个简单的加热系统。其中，温度和期望温度是主题，加热器和显示器是观察者。</li><li><strong>主题定义：</strong> 使用 <code>LazyLock</code> 和原子变量 (<code>AtomicI16</code> 和 <code>AtomicBool</code>) 定义温度、期望温度和加热器开关状态等主题。</li><li><strong>显示器 Future：</strong> 实现了一个 <code>DisplayFuture</code>，它通过不断轮询温度主题来更新显示，并在温度变化时触发加热器开关。<div class="component-content component"><ul><li><code>DisplayFuture</code> 通过比较当前温度和快照的温度来决定是否更新显示，以及是否开启或关闭加热器。</li></ul></div></li><li><strong>加热器 Future：</strong> 实现了一个 <code>HeaterFuture</code>，它根据 <code>HEAT_ON</code> 标志增加温度，并在加热器打开时持续加热。</li><li><strong>热损耗 Future：</strong> 实现了一个 <code>HeatLossFuture</code>，它持续减少温度，模拟热损耗。</li><li><strong>使用 <code>compare_exchange</code>：</strong> 使用 <code>compare_exchange</code> 函数来确保原子操作的原子性，并避免数据竞争。</li><li><strong>事件循环和回调：</strong> 介绍了事件循环和回调的概念，通过传递事件到线程池，在方便的时候将数据发送回事件的源头。</li><li><strong>输入处理：</strong> 使用原子变量、Mutex和队列来处理输入事件并更新显示。</li><li><strong>事件总线：</strong> 创建一个事件总线结构体 <code>EventBus</code>，可以发布事件到多个订阅者，并使用 <code>AsyncMutex</code> 和 <code>HashMap</code> 来管理订阅者。
* <strong><code>EventHandle</code>：</strong> 为 <code>EventBus</code> 创建了一个句柄 <code>EventHandle</code>，使订阅者可以轮询事件。
* <code>send</code> 函数向所有订阅者发送事件。</li><li><strong>背压：</strong> 提到了事件的创建速率可能大于处理速率，导致背压，并指出一些解决背压的方法。</li><li><strong>垃圾回收器：</strong> 创建一个 <code>garbage_collector</code> 函数来清理不再使用的句柄，以防止资源泄漏。</li></ul></div><div class="component-content pagebody component"><h2 id=第七章自定义tokio class=pagebody-header>第七章：自定义Tokio</h2></div><p class="component-content component">本章深入探讨了如何自定义 Tokio 运行时，并控制其配置和行为。</p><div class="component-content component"><ul><li><strong>Tokio运行时配置：</strong> 使用 <code>tokio::runtime::Builder</code> 构建和配置 Tokio 运行时，包括设置线程数、线程名称、时间驱动等。</li><li><strong>使用 <code>LazyLock</code> 延迟初始化：</strong> 通过 <code>LazyLock</code> 实现运行时的延迟初始化，确保运行时只创建一次。</li><li><strong><code>spawn_task</code> 函数：</strong> 定义 <code>spawn_task</code> 函数来将任务生成到运行时，与第三章自定义的 <code>spawn_task</code> 函数类似，但返回的是 <code>tokio::task::JoinHandle</code>。</li><li><strong>多运行时：</strong> 在一个程序中创建多个不同的 Tokio 运行时，并演示了如何将不同的任务发送到不同的运行时。<div class="component-content component"><ul><li>高优先级和低优先级运行时：通过创建高优先级和低优先级运行时来模拟具有不同优先级的任务队列。</li></ul></div></li><li><strong>本地池：</strong> 介绍了本地池（local pools）的概念，并展示了如何使用 <code>spawn_pinned</code> 在本地池中处理任务。<div class="component-content component"><ul><li>使用本地池可以避免使用原子操作等手段来保护共享数据，因为在同一个线程内访问的数据始终是安全的。</li></ul></div></li><li><strong>优雅关闭：</strong> 介绍了如何优雅地关闭 Tokio 运行时，包括使用 <code>tokio::signal::ctrl_c</code> 监听 Ctrl-C 事件，并使用 <code>std::process::exit</code> 关闭程序。</li><li><strong>总结：</strong> 回顾了本章的主要内容，强调了对 Tokio 运行时的控制，包括线程数、阻塞线程数和任务轮询。</li></ul></div><div class="component-content pagebody component"><h2 id=第八章actor-模型 class=pagebody-header>第八章：Actor 模型</h2></div><p class="component-content component">本章介绍了 Actor 模型，以及如何使用 Rust 的异步特性来实现一个简单的 Actor 系统。</p><div class="component-content component"><ul><li><strong>Actor 模型：</strong> 是一种并发模型，其中 Actor 是独立的执行单元，通过消息传递进行通信。每个 Actor 都有自己的状态和行为，并且是隔离的。</li><li><strong>基本 Actor：</strong> 演示了如何使用通道 (channel) 来创建基本的 Actor，并通过通道传递消息。</li><li><strong>路由器 Actor：</strong> 创建了一个路由器 Actor，它接收消息并将其路由到相应的 Actor，以实现系统模块化。</li><li><strong>全局 Sender：</strong> 使用 <code>OnceLock</code> 创建了一个全局的 <code>Sender</code> 以便在程序的任何地方发送消息给 Actor。</li><li><strong>键值存储 Actor：</strong> 创建了一个键值存储 Actor，可以设置、获取和删除键值对。</li><li><strong>Writer Actor：</strong> 添加了一个 Writer Actor，负责将键值对操作写入文件，以实现数据备份。</li><li><strong>Actor 监督：</strong> 介绍了如何通过心跳机制来监控 Actor，并在 Actor 失败时自动重启它们。</li><li><strong>消息枚举：</strong> 定义了 <code>RoutingMessage</code> 枚举来区分不同类型的消息，并将消息路由到不同的 Actor。</li><li><strong>重置 Actor：</strong> 演示了如何重置 Actor，并确保Actor系统在重置后依然可以正常工作。</li><li><strong>总结：</strong> 强调了本章中构建的 Actor 系统，包括键值存储、数据备份和心跳监控，以及路由器模式的简化作用。</li></ul></div><div class="component-content pagebody component"><h2 id=第九章设计模式 class=pagebody-header>第九章：设计模式</h2></div><p class="component-content component">本章介绍了一些常用的异步设计模式，以及如何在 Rust 中实现它们。</p><div class="component-content component"><ul><li><strong>异步模块:</strong> 展示了如何创建具有最小占用空间的异步模块，并管理异步任务的执行。</li><li><strong>瀑布模式：</strong> 又称责任链模式，将异步任务串联在一起，前一个任务的输出作为后一个任务的输入。<div class="component-content component"><ul><li>利用 Rust 的错误处理机制简化了链式调用。</li></ul></div></li><li><strong>装饰器模式：</strong> 通过包装结构体来扩展现有功能，并且不需要修改原始结构体的代码，可以通过实现相同的 trait 来实现。<div class="component-content component"><ul><li>可以在不更改原有代码的前提下，动态地添加或修改现有类的功能。</li></ul></div></li><li><strong>状态机模式：</strong> 使用枚举和模式匹配来管理状态转换，通过不同的事件来改变状态，并将异步代码集成到状态机中。<div class="component-content component"><ul><li>可以通过状态机来实现不同状态下的异步任务调度，使代码更加清晰和可维护。</li></ul></div></li><li><strong>重试模式：</strong> 使用循环和 <code>tokio::time::sleep</code> 实现任务的自动重试，并设置最大重试次数和退避策略。</li><li><strong>断路器模式：</strong> 当错误超过阈值时，阻止新的任务执行，避免系统崩溃。<div class="component-content component"><ul><li>利用原子变量来记录错误次数，并控制断路器的状态。</li></ul></div></li><li><strong>总结：</strong> 强调了在应用设计模式时需要注意适度，避免过度工程。</li></ul></div><div class="component-content pagebody component"><h2 id=第十章使用标准库构建异步服务器 class=pagebody-header>第十章：使用标准库构建异步服务器</h2></div><p class="component-content component">本章介绍了如何仅使用 Rust 标准库构建一个异步 TCP 服务器，而不依赖任何外部库。</p><div class="component-content component"><ul><li><strong>数据层逻辑：</strong> 构建了一个用于序列化和反序列化数据的模块，并将 <code>Data</code> 结构体公开。</li><li><strong>原始 Waker:</strong> 创建自定义的 <code>RawWaker</code>，以更精细地控制任务的执行过程。<div class="component-content component"><ul><li>定义 <code>RawWakerTable</code> 中的函数，如克隆、唤醒和删除 <code>RawWaker</code>。</li></ul></div></li><li><strong>执行器：</strong> 构建了一个简单的执行器（Executor），使用 <code>VecDeque</code> 作为任务队列，并通过轮询执行任务。<div class="component-content component"><ul><li>执行器负责轮询任务并执行Future。</li></ul></div></li><li><strong>自定义 Future：</strong> 创建了一个简单的 <code>CountingFuture</code>，展示了如何定义自定义的Future。</li><li><strong>使用标准库实现异步运行时：</strong> 使用标准库中的 <code>Future</code> 和 <code>Context</code> 来实现一个简单的异步运行时，并验证其正常工作。</li><li><strong>TCP发送器：</strong> 构建了一个 <code>TcpSender</code> 结构体，用于异步发送数据到 TCP 连接。<div class="component-content component"><ul><li><code>TcpSender</code> 实现了 <code>Future</code> trait，使用 <code>try_lock</code> 获取锁，并在无法立即写入时返回 <code>Pending</code>。</li></ul></div></li><li><strong>TCP接收器：</strong> 构建了一个 <code>TcpReceiver</code> 结构体，用于异步接收来自 TCP 连接的数据。<div class="component-content component"><ul><li><code>TcpReceiver</code> 实现了 <code>Future</code> trait, 使用 <code>try_lock</code> 获取锁，并在没有数据可读取或阻塞时返回 <code>Pending</code>。</li></ul></div></li><li><strong>休眠 Future：</strong> 构建了一个 <code>Sleep</code> 结构体，用于模拟异步休眠。</li><li><strong>多线程处理：</strong> 使用多线程处理传入的 TCP 请求，并使用 AtomicBool 控制线程的挂起和唤醒。</li><li><strong>宏的使用：</strong> 使用宏来简化线程的创建和任务分发过程。</li><li><strong>请求处理：</strong> 处理传入的 TCP 请求，并将请求分发到不同的线程，并在每个线程中执行异步任务。</li></ul></div><div class="component-content pagebody component"><h2 id=第十一章测试 class=pagebody-header>第十一章：测试</h2></div><p class="component-content component">本章介绍了如何测试异步代码，包括同步测试、模拟异步代码、测试死锁、测试竞争条件以及测试网络交互。</p><div class="component-content component"><ul><li><strong>测试概述：</strong> 介绍了异步测试的概念，包括隔离测试和模拟依赖项。</li><li><strong>模拟异步代码：</strong> 使用 <code>mockall</code> crate 模拟异步代码，并验证函数的调用和参数。<div class="component-content component"><ul><li>使用 <code>mock!</code> 宏创建模拟对象，并指定模拟对象的行为。</li></ul></div></li><li><strong>通道容量测试:</strong> 使用 <code>tokio::sync::mpsc::channel</code> 创建通道，并测试通道的容量限制。<div class="component-content component"><ul><li>使用 <code>timeout</code> 来测试通道阻塞的情况，以及防止死锁的发生。</li></ul></div></li><li><strong>网络交互测试：</strong> 使用 <code>mockito</code> crate 模拟网络服务器，并测试客户端的网络交互。<div class="component-content component"><ul><li>使用 <code>mockito</code> crate 创建模拟服务器，并指定服务器的返回状态码和响应体。</li></ul></div></li><li><strong>细粒度的 Future 测试：</strong> 使用 <code>tokio_test</code> crate 更细致地测试 Future，包括轮询 Future 并断言其状态。<div class="component-content component"><ul><li>使用 <code>assert_pending!</code> 来断言 future 处于 pending 状态，从而测试 Future 的执行细节。</li></ul></div></li></ul></div></div><div id=comments class=utterances><script src=https://utteranc.es/client.js repo=smallnest/booslip.rpcx.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></article></section></main><script>var script=document.createElement("script");script.src="https://booslip.rpcx.io/js/initPost.js",document.head.appendChild(script)</script><div class=footer-main><div class="content-body footer-wraper"><div class=footer-box><div class=foot-nav><div class=foot-nav-items><div class=item><div class=logo></div><div class=email>Email: <a href=mailto:smallnest@gmail.com>smallnest@gmail.com</a></div></div><div class="item community"><div class=item-title>社交媒体</div><a href=https://github.com/smallnest target=_blank>Github</a></div><div class="item resources"><div class=item-title>友链</div><a href=https://colobu.com/ target=_blank>鸟窝</a></div></div></div><div class=bottom><div class="item copyright">鸟窝 &copy; 2025 All Rights Reserved.</div></div></div></div></div></body></html>