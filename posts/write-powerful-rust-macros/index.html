<!doctype html><html class="js no-touch progressive-image no-reduced-motion progressive" lang=zh-hans><head><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=icon href=/img/favicon.ico><meta name=keyword content><meta property="og:url" content="https://booslip.rpcx.io/posts/write-powerful-rust-macros/"><meta property="og:site_name" content="竹简书摘"><meta property="og:title" content="Write Powerful Rust Macros"><meta property="og:description" content="编写强大的 Rust 宏"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-01T10:30:41+08:00"><meta property="article:modified_time" content="2025-01-01T10:30:41+08:00"><title>Write Powerful Rust Macros</title>
<link rel=canonical href=/posts/write-powerful-rust-macros/><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/custom.css><link rel=stylesheet href=/css/search.css><link href="https://fonts.googleapis.com/css?family=Bree+Serif" rel=stylesheet><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?c80136b2ed102610dcafb84941e8df30",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head></head><body class=page-article><header><nav class=nav><div class=nav-wrapper><div class=nav-content-wrapper><div class=nav-content><a href=/ class=nav-title>竹简书摘</a><div class=nav-menu><div class=nav-item-wrapper><a href=/posts class=nav-item-content>书摘</a></div><div class=nav-item-wrapper><a href=/index.xml class=nav-item-content target=_blank>RSS</a></div></div></div></div></div></nav><script>function toggleSearchModal(){const t=`
    <div class="modal-body">
      <div id="autocomplete" onclick="event.stopPropagation();"></div>
    </div>
    `,e=document.querySelector("#modal-wrapper");if(e)document.body.removeAttribute("style"),document.body.removeChild(e);else{const e=document.createElement("div");document.body.setAttribute("style","overflow: hidden;"),e.setAttribute("id","modal-wrapper"),e.setAttribute("onclick","toggleSearchModal()"),e.innerHTML=t;const n=document.createElement("script");n.setAttribute("src","https://booslip.rpcx.io/js/algolia.js"),e.appendChild(n),document.body.append(e)}}</script></header><main id=main class=main><section><article class=article><div class=article-header><div class="category component"><div class=component-content><div class=category-eyebrow><span class="category-eyebrow__category category_original"></span><span class=category-eyebrow__date>2025年1月1日</span></div></div></div><div class="pagetitle component"><div class=component-content><h1 class=hero-headline>Write Powerful Rust Macros</h1></div></div><div class="component article-subhead"><div class=component-content>编写强大的 Rust 宏</div></div><div class="tagssheet component"><div class=component-content><a href=/tags/ class=tag></a></div></div></div><div class="book-card component"><div class=book-cover><img data-src=/covers/Write-Powerful-Rust-Macros.png alt=书籍封面></div><div class=book-info><h1 class=book-title>Write Powerful Rust Macros</h1><div class=book-meta><span>作者：Sam Van Overmeire</span>
<span>出版日期：2024-07-16</span>
<span>出版社：Manning</span></div><div class=book-description>书中系统讲解了Rust宏的编写技巧，从简单的声明式宏到复杂的函数式宏，涵盖了多种类型的宏及其应用场景，例如构建DSL（领域特定语言）和改进代码结构。书中还深入探讨了宏的测试和调试方法，并结合实际案例分析了宏在不同项目中的应用，例如构建器模式和基础设施即代码（IaC）。此外，本书还介绍了Rust相关的编程概念，例如纯函数和杂质函数，以及如何利用它们来提高代码质量和可维护性。</div></div></div><div class=pagebody><p class="component-content component">这本书《Write Powerful Rust Macros》旨在教导读者如何使用 Rust 的宏进行元编程。本书从元编程的基础概念讲起，逐步深入到各种宏的类型和实际应用，并通过大量的示例和练习，帮助读者掌握编写强大 Rust 宏的技能。</p><div class="component-content component"><ul><li><p class="component-content component"><strong>第一章：元编程入门</strong></p><div class="component-content component"><ul><li>介绍了元编程的概念，即编写可以操作或生成其他代码的代码 [第一章]。</li><li>讨论了 Rust 中元编程的主要方式——<strong>宏</strong>，并强调了其重要性 [第一章]。</li><li>列举了宏的适用场景，如消除重复代码、实现代码生成和抽象复杂模式 [第一章]。</li><li>同时指出了不应使用宏的情况，如过度使用、复杂逻辑和潜在的性能问题 [第一章]。</li><li>概述了本书的重点是 Rust 宏 [第一章]。</li></ul></div></li><li><p class="component-content component"><strong>第二章：声明宏（Declarative Macros）</strong></p><div class="component-content component"><ul><li>介绍了声明宏的基础知识，包括语法、匹配器（matcher）和转录器（transcriber）。</li><li>解释了如何使用 <strong><code>macro_rules!</code></strong> 创建声明宏。</li><li>讨论了<strong>代码展开</strong>（expanding）的概念，并介绍了 <code>trace_macros!</code> 和 <code>log_syntax!</code> 等工具来辅助理解宏的展开过程。</li><li>讲解了如何使用 <strong><code>$()</code></strong> 来捕获和引用宏变量。</li><li>说明了如何使用 <strong><code>$()</code></strong> 匹配不同的输入类型，如 <code>ident</code>、<code>literal</code>、<code>expr</code>、<code>ty</code> 等。</li><li>展示了如何使用声明宏实现 <strong>DSL (领域特定语言)</strong>。</li><li>解释了如何使用 <strong>newtype</strong> 来提高类型系统的表达能力。</li><li>讨论了如何使用声明宏实现递归。</li><li>介绍了如何通过<strong>组合</strong>（compose）宏来增强代码的灵活性。</li><li>讲解了<strong>柯里化</strong>（currying）的概念，并演示了如何使用宏实现柯里化。</li><li>讨论了<strong>卫生性</strong>（hygiene）在宏中的作用，以及如何避免命名冲突。</li><li>展示了不同括号在宏调用中的使用方法。</li></ul></div></li><li><p class="component-content component"><strong>第三章：过程宏（Procedural Macros）</strong></p><div class="component-content component"><ul><li>介绍了过程宏的基本概念和分类：派生宏（derive macros）、属性宏（attribute macros）和函数式宏（function-like macros）。</li><li>详细讲解了如何设置<strong>过程宏项目</strong>，包括创建库项目，添加依赖项等。</li><li>解释了<strong>派生宏</strong>的工作原理，以及如何使用 <code>#[proc_macro_derive]</code> 注解创建派生宏。</li><li>说明了如何使用 <code>quote!</code> 宏生成代码。</li><li>讲解了如何解析输入<strong>抽象语法树（AST）</strong>，并获取结构体的名称。</li><li>强调了过程宏必须位于库的根目录。</li><li>提供了一个派生宏的练习。</li></ul></div></li><li><p class="component-content component"><strong>第四章：使用属性宏修改字段</strong></p><div class="component-content component"><ul><li>介绍了<strong>属性宏</strong>的概念，以及如何使用 <code>#[proc_macro_attribute]</code> 注解创建属性宏。</li><li>讲解了属性宏与派生宏的区别，并说明了属性宏可以修改现有代码。</li><li>演示了如何使用属性宏来使结构体的字段公开。</li><li>说明了如何使用 <strong><code>ParseStream</code></strong> 来解析输入流。</li><li>强调了良好的错误处理在生产级宏中的重要性。</li><li>介绍了 <strong><code>no-panic</code></strong> 宏的实现原理，以及如何使用宏来证明函数不会发生 panic。</li><li>提供了一个属性宏的练习。</li></ul></div></li><li><p class="component-content component"><strong>第五章：函数式宏</strong></p><div class="component-content component"><ul><li>讲解了<strong>函数式宏</strong>（function-like macros）的工作原理，以及如何使用 <code>#[proc_macro]</code> 注解创建函数式宏。</li><li>解释了函数式宏可以使用 <code>!</code> 操作符在代码的几乎任何位置调用。</li><li>讨论了<strong>卫生性</strong>在过程宏中的重要性，以及如何使用 <code>call_site</code> 和 <code>mixed_site</code> 来控制 span。</li><li>展示了如何使用函数式宏来扩展语言的功能。</li><li>强调了不同类型宏的适用场景。</li><li>介绍了 <strong><code>format_ident!</code></strong> 宏，用于动态创建标识符。</li></ul></div></li><li><p class="component-content component"><strong>第六章：测试构建器宏</strong></p><div class="component-content component"><ul><li>通过一个<strong>构建器宏</strong>的例子，详细讲解了如何测试过程宏。</li><li>介绍了<strong>白盒测试</strong>和<strong>黑盒测试</strong>的概念，并说明了它们在宏测试中的应用。</li><li>演示了如何使用 <code>quote!</code> 宏生成测试代码。</li><li>强调了<strong>测试驱动开发</strong>（TDD）在宏开发中的重要性。</li><li>介绍了<strong>cargo expand</strong> 工具，用于查看宏展开后的代码。</li><li>讨论了不同类型的测试，如单元测试、集成测试、端到端测试和冒烟测试。</li><li>展示了如何使用 <strong>trybuild</strong> 包进行测试。</li><li>总结了构建器模式，并强调了单元测试的重要性。</li></ul></div></li><li><p class="component-content component"><strong>第七章：错误处理</strong></p><div class="component-content component"><ul><li>讨论了<strong>异常</strong>的缺点，并介绍了函数式编程中<strong>纯函数</strong>的概念。</li><li>讲解了使用 <strong><code>Result</code></strong> 枚举来处理错误。</li><li>强调了 <code>panic!</code> 的使用场景，并说明了 <code>unwrap</code> 和 <code>expect</code> 方法在实验性代码中的作用。</li><li>演示了如何使用属性宏来修改函数，并将其中的 <code>panic!</code> 转换为 <code>Result</code>。</li><li>说明了如何使用 <code>syn::Error</code> 来创建编译时错误。</li><li>介绍了 <strong><code>abort</code></strong> 和 <strong><code>abort_call_site</code></strong> 宏，用于生成详细的错误信息。</li><li>展示了如何使用 <strong><code>proc_macro_error</code></strong> crate 进行错误处理。</li></ul></div></li><li><p class="component-content component"><strong>第八章：宏的灵活性</strong></p><div class="component-content component"><ul><li>讲解了如何使用<strong>属性</strong>来扩展宏的功能。</li><li>介绍了如何使用 <code>syn::meta</code> 来解析属性信息，包括 <code>NamedValue</code>、<code>Path</code> 和 <code>List</code> 等类型。</li><li>讨论了 <strong><code>lazy</code></strong> 和 <strong><code>eager</code></strong> 求值的概念，并说明了如何使用 <code>unwrap_or_else</code> 来进行延迟求值。</li><li>介绍了 <strong><code>Default</code></strong> trait，以及如何使用默认值作为宏的备选方案。</li><li>讨论了如何使用 <strong>type state</strong> 模式来增强类型系统的表达能力，并避免不合法的状态。</li><li>展示了如何将构建器模式与类型状态模式相结合。</li><li>介绍了其他类型的属性，如外部属性、内部属性和文档注释。</li></ul></div></li><li><p class="component-content component"><strong>第九章：编写基础设施 DSL</strong></p><div class="component-content component"><ul><li>介绍了 <strong>IaC（基础设施即代码）</strong> 的概念，并说明了如何使用宏创建 DSL。</li><li>演示了如何使用函数式宏来解析 DSL 输入，并将其转换为 Rust 代码。</li><li>讲解了如何使用 <code>syn</code> 库的 <code>Parse</code> trait 来解析输入流。</li><li>说明了如何使用 <strong><code>lookahead1</code></strong> 来查看下一个 token 并返回错误。</li><li>介绍了两种其他的解析方法，并使用了 <strong><code>Punctuated</code></strong> 结构体和构建器模式。</li><li>展示了如何在宏中使用异步代码来创建 AWS 基础设施。</li><li>讨论了如何使用 <strong><code>thiserror</code></strong> crate 来简化错误处理。</li><li>强调了对宏进行端到端测试的重要性。</li></ul></div></li><li><p class="component-content component"><strong>第十章：宏与外部世界</strong></p><div class="component-content component"><ul><li>讨论了如何在一个库中暴露多个宏。</li><li>介绍了如何使用 <strong>feature flags</strong> 来添加或禁用宏的功能。</li><li>说明了如何使用属性来控制生成代码。</li><li>强调了为宏编写<strong>文档</strong>的重要性，并介绍了如何使用 doctest。</li><li>讨论了如何发布宏库，以及开源的意义。</li><li>总结了本书的内容，并鼓励读者继续探索宏的世界。</li></ul></div></li><li><p class="component-content component"><strong>附录：练习解答</strong></p><div class="component-content component"><ul><li>提供了所有章节的练习解答。</li></ul></div></li><li><p class="component-content component"><strong>重要概念总结</strong></p><div class="component-content component"><ul><li><strong>宏（Macros）：</strong> Rust 中进行元编程的主要工具，用于在编译时生成代码。</li><li><strong>声明宏（Declarative Macros）：</strong> 基于模式匹配和代码替换的宏，使用 <code>macro_rules!</code> 定义。</li><li><strong>过程宏（Procedural Macros）：</strong> 使用 Rust 代码编写的宏，可以执行更复杂的代码生成逻辑。包括派生宏、属性宏和函数式宏。</li><li><strong>AST（抽象语法树）：</strong> 代码的结构化表示，用于过程宏进行代码分析和修改。</li><li><strong><code>quote!</code> 宏：</strong> 用于生成 Rust 代码的宏。</li><li><strong><code>syn</code> 库：</strong> 用于解析 Rust 代码的库。</li><li><strong><code>proc_macro</code> 和 <code>proc_macro2</code>:</strong> 用于编写过程宏的库。</li><li><strong>DSL（领域特定语言）：</strong> 为特定领域设计的语言。</li><li><strong>类型状态模式 (Type State Pattern):</strong> 使用类型参数来编码系统的状态，避免不合法的状态转换。</li><li><strong>卫生性（Hygiene）：</strong> 宏中避免命名冲突的机制。</li><li><strong>Result:</strong> 用于处理可能失败的操作的枚举类型</li><li><strong>单元测试：</strong> 用于测试代码的最小单元的测试方法。</li><li><strong>白盒测试：</strong> 知道代码内部实现的测试方法</li><li><strong>黑盒测试：</strong> 不知道代码内部实现，只关注输入和输出的测试方法。</li></ul></div></li></ul></div></div><div id=comments class=utterances><script src=https://utteranc.es/client.js repo=smallnest/booslip.rpcx.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></article></section></main><script>var script=document.createElement("script");script.src="https://booslip.rpcx.io/js/initPost.js",document.head.appendChild(script)</script><div class=footer-main><div class="content-body footer-wraper"><div class=footer-box><div class=foot-nav><div class=foot-nav-items><div class=item><div class=logo></div><div class=email>Email: <a href=mailto:smallnest@gmail.com>smallnest@gmail.com</a></div></div><div class="item community"><div class=item-title>社交媒体</div><a href=https://github.com/smallnest target=_blank>Github</a></div><div class="item resources"><div class=item-title>友链</div><a href=https://colobu.com/ target=_blank>鸟窝</a></div></div></div><div class=bottom><div class="item copyright">鸟窝 &copy; 2025 All Rights Reserved.</div></div></div></div></div></body></html>