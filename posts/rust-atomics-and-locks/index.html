<!doctype html><html class="js no-touch progressive-image no-reduced-motion progressive" lang=zh-hans><head><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta http-equiv=X-UA-Compatible content="IE=edge"><link rel=icon href=/img/favicon.ico><meta name=keyword content><meta property="og:url" content="https://booslip.rpcx.io/posts/rust-atomics-and-locks/"><meta property="og:site_name" content="竹简书摘"><meta property="og:title" content="Rust Atomics and Locks"><meta property="og:description" content="Rust 并发编程内幕"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-12-28T12:43:47+08:00"><meta property="article:modified_time" content="2024-12-28T12:43:47+08:00"><meta property="article:tag" content="Rust"><meta property="article:tag" content="并发"><title>Rust Atomics and Locks</title>
<link rel=canonical href=/posts/rust-atomics-and-locks/><link rel=stylesheet href=/css/global.css><link rel=stylesheet href=/css/custom.css><link rel=stylesheet href=/css/search.css><link href="https://fonts.googleapis.com/css?family=Bree+Serif" rel=stylesheet><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?c80136b2ed102610dcafb84941e8df30",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head></head><body class=page-article><header><nav class=nav><div class=nav-wrapper><div class=nav-content-wrapper><div class=nav-content><a href=/ class=nav-title>竹简书摘</a><div class=nav-menu><div class=nav-item-wrapper><a href=/posts class=nav-item-content>书摘</a></div><div class=nav-item-wrapper><a href=/index.xml class=nav-item-content target=_blank>RSS</a></div></div></div></div></div></nav><script>function toggleSearchModal(){const t=`
    <div class="modal-body">
      <div id="autocomplete" onclick="event.stopPropagation();"></div>
    </div>
    `,e=document.querySelector("#modal-wrapper");if(e)document.body.removeAttribute("style"),document.body.removeChild(e);else{const e=document.createElement("div");document.body.setAttribute("style","overflow: hidden;"),e.setAttribute("id","modal-wrapper"),e.setAttribute("onclick","toggleSearchModal()"),e.innerHTML=t;const n=document.createElement("script");n.setAttribute("src","https://booslip.rpcx.io/js/algolia.js"),e.appendChild(n),document.body.append(e)}}</script></header><main id=main class=main><section><article class=article><div class=article-header><div class="category component"><div class=component-content><div class=category-eyebrow><span class="category-eyebrow__category category_original">rust
</span><span class=category-eyebrow__date>2024年12月28日</span></div></div></div><div class="pagetitle component"><div class=component-content><h1 class=hero-headline>Rust Atomics and Locks</h1></div></div><div class="component article-subhead"><div class=component-content>Rust 并发编程内幕</div></div><div class="tagssheet component"><div class=component-content><a href=/tags/rust class=tag>rust
</a><a href=/tags/%E5%B9%B6%E5%8F%91 class=tag>并发</a></div></div></div><div class="book-card component"><div class=book-cover><img data-src=/covers/rust-atomics.jpg alt=书籍封面></div><div class=book-info><h1 class=book-title>Rust Atomics and Locks</h1><div class=book-meta><span>作者：Mara Bos</span>
<span>出版日期：2022-12-14</span>
<span>出版社：O'Reilly Media, Inc.</span></div><div class=book-description>该书旨在帮助Rust程序员理解底层并发编程，涵盖了原子操作、内存排序、锁的实现（包括互斥锁和读写锁）以及操作系统相关的并发原语。书中包含大量Rust代码示例，并解释了不同处理器架构（x86-64和ARM64）的底层细节，以及缓存一致性对并发性能的影响。</div></div></div><div class=pagebody><p class="component-content component"><strong>前言</strong></p><div class="component-content component"><ul><li>本书作者 Mara Bos 在 Rust 标准库团队工作，并有多年并发实时系统开发经验。</li><li>本书的重点是 Rust 中 <strong>底层的并发</strong> 实现，而不是高级的抽象。</li><li>本书适合那些对并发编程的底层机制感兴趣的读者，例如原子操作、锁、内存排序等.</li><li>本书通过从零开始构建各种并发原语，来深入理解其工作原理.</li><li>本书的写作灵感来源于 Rust 社区关于并发的讨论，作者希望通过实践来深入理解软件安全特性.</li></ul></div><p class="component-content component"><strong>目录</strong></p><div class="component-content component"><ul><li>本书目录列出了主要章节，包括原子操作、自旋锁、通道、Arc 智能指针、锁、条件变量等主题.<div class="component-content component"><ul><li>第一章：Rust 并发基础</li><li>第二章：原子操作</li><li>第三章：内存排序</li><li>第四章：构建自己的自旋锁</li><li>第五章：构建自己的通道</li><li>第六章：构建自己的"Arc"</li><li>第七章：理解处理器</li><li>第八章：Linux Futex</li><li>第九章：构建自己的锁</li></ul></div></li></ul></div><div class="component-content pagebody component"><h2 id=第一章rust-并发基础 class=pagebody-header>第一章：Rust 并发基础</h2></div><div class="component-content component"><ul><li>本章介绍了 Rust 并发编程的基础概念，包括线程、<code>Send</code> 和 <code>Sync</code> Trait.<div class="component-content component"><ul><li><code>Send</code> Trait 表示类型可以安全地在线程之间转移所有权. 例如 <code>Arc&lt;i32></code> 是 <code>Send</code> 的，但 <code>Rc&lt;i32></code> 不是.</li><li><code>Sync</code> Trait 表示类型可以安全地在线程之间共享引用. 例如 <code>i32</code> 是 <code>Sync</code> 的，但 <code>Cell&lt;i32></code> 不是.</li><li><strong>自动 Trait</strong>：<code>Send</code> 和 <code>Sync</code> 是自动 Trait，如果结构体中的所有字段都满足 <code>Send</code> 和 <code>Sync</code>，则该结构体本身也满足. 可以通过添加 <code>PhantomData</code> 字段来选择不实现这些 trait.</li><li><strong>静态变量</strong>：静态变量的生命周期是整个程序，多个线程可以同时借用静态变量.</li></ul></div><div class="component-content pagebody component code"><div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>static</span> X: [<span style=color:#66d9ef>i32</span>; <span style=color:#ae81ff>3</span>] <span style=color:#f92672>=</span>;
</span></span><span style=display:flex><span>thread::spawn(<span style=color:#f92672>||</span> dbg!(<span style=color:#f92672>&amp;</span>X));
</span></span><span style=display:flex><span>thread::spawn(<span style=color:#f92672>||</span> dbg!(<span style=color:#f92672>&amp;</span>X));</span></span></code></pre></div></div></div><div class="component-content component"><ul><li><strong>内部可变性</strong>：<code>Cell</code> 和 <code>RefCell</code> 允许通过不可变引用进行修改.<div class="component-content component"><ul><li><code>Cell</code> 仅适用于单线程，只能整体替换值，或者复制值（如果类型实现 <code>Copy</code>）.</li><li><code>RefCell</code> 在运行时检查借用规则，允许多个共享借用或一个独占借用.</li></ul></div></li><li><strong><code>Mutex</code> 和 <code>RwLock</code></strong>: <code>Mutex</code> 和 <code>RwLock</code> 是多线程环境下的可变性类型.<div class="component-content component"><ul><li><code>Mutex</code> 允许独占访问.</li><li><code>RwLock</code> 允许多个读者同时访问，或者一个写者独占访问.</li></ul></div></li><li><strong>原子类型</strong>：原子类型是多线程环境下的 <code>Cell</code>.
* 通过复制的方式写入和读取，避免数据竞争.</li><li><strong>线程停车</strong>：线程停车是一种等待条件满足的机制.
* <code>Condvar</code>（条件变量）用于等待 <code>Mutex</code> 保护的数据上的条件，比线程停车更方便和高效.</li></ul></div></li><li>本章还讨论了 <strong>共享所有权</strong> 和 <strong>引用计数</strong> (例如 <code>Arc</code>)，以及如何使用 <code>thread::scope</code> 创建 <strong>作用域线程</strong>.</li></ul></div><div class="component-content pagebody component"><h2 id=第二章原子操作 class=pagebody-header>第二章：原子操作</h2></div><div class="component-content component"><ul><li>本章深入探讨了 <strong>原子操作</strong>，这是并发编程的基石.<div class="component-content component"><ul><li><strong>原子性</strong>：原子操作是不可分割的操作，要么完全完成，要么完全不发生.</li><li><strong><code>AtomicI32</code></strong>：本章以 <code>AtomicI32</code> 为例，介绍了原子类型的基本操作.<div class="component-content component"><ul><li><strong><code>load</code></strong>：原子加载操作，读取原子变量的值.</li><li><strong><code>store</code></strong>：原子存储操作，向原子变量写入新值.</li></ul></div></li></ul></div><div class="component-content pagebody component code"><div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> AtomicI32 {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>load</span>(<span style=color:#f92672>&amp;</span>self, ordering: <span style=color:#a6e22e>Ordering</span>) -&gt; <span style=color:#66d9ef>i32</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>store</span>(<span style=color:#f92672>&amp;</span>self, value: <span style=color:#66d9ef>i32</span>, ordering: <span style=color:#a6e22e>Ordering</span>);
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></div><div class="component-content component"><ul><li><strong><code>fetch_add</code>， <code>fetch_sub</code> 等</strong>：原子获取并修改操作，例如原子加法，减法，按位或等.<div class="component-content pagebody component code"><div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>  <span style=color:#66d9ef>impl</span> AtomicI32 {
</span></span><span style=display:flex><span>     <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>fetch_add</span>(<span style=color:#f92672>&amp;</span>self, v: <span style=color:#66d9ef>i32</span>, ordering: <span style=color:#a6e22e>Ordering</span>) -&gt; <span style=color:#66d9ef>i32</span>;
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></div></li><li><strong><code>compare_exchange</code></strong>：原子比较和交换操作，只有当原子变量的值等于预期值时，才将其替换为新值.<div class="component-content pagebody component code"><div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>impl</span> AtomicI32 {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>compare_exchange</span>(<span style=color:#f92672>&amp;</span>self, expected: <span style=color:#66d9ef>i32</span>, new: <span style=color:#66d9ef>i32</span>) -&gt; Result<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span>, <span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></div><div class="component-content component"><ul><li>此操作返回之前的值，以及是否进行了替换.</li></ul></div></li><li><strong>使用场景</strong>：<div class="component-content component"><ul><li><strong>自增计数器</strong>：通过 <code>fetch_add</code> 来实现.</li><li><strong>懒加载</strong>：使用 <code>compare_exchange</code> 初始化变量，避免重复初始化.</li></ul></div></li></ul></div></li><li><strong>内存排序</strong>：本章开始介绍了内存排序的概念，原子操作的内存排序参数决定了其在不同线程之间的可见性.</li></ul></div><div class="component-content pagebody component"><h2 id=第三章内存排序 class=pagebody-header>第三章：内存排序</h2></div><div class="component-content component"><ul><li>本章详细介绍了 <strong>内存排序</strong> 的概念，以及如何在并发程序中保证数据的一致性.<div class="component-content component"><ul><li><strong><code>happens-before</code> 关系</strong>：<code>happens-before</code> 关系定义了操作之间的顺序.<div class="component-content component"><ul><li>在同一个线程内的操作，按照代码顺序执行，构成 <code>happens-before</code> 关系.</li><li>线程的 <code>spawn</code> 和 <code>join</code> 操作也会建立 <code>happens-before</code> 关系.</li><li><strong>互斥锁</strong> 的加锁和解锁操作会建立 <code>happens-before</code> 关系.</li><li>使用 <strong>非 <code>Relaxed</code> 内存排序的原子操作</strong> 会建立 <code>happens-before</code> 关系.</li></ul></div></li><li><strong><code>Relaxed</code> 内存排序</strong>：最基本的内存排序，不建立跨线程的 <code>happens-before</code> 关系，只保证<strong>单个</strong>原子变量的修改顺序在所有线程中是一致的.<div class="component-content component"><ul><li>使用 <code>Relaxed</code> 排序的原子操作，可能导致不同的线程看到不一致的数据状态.</li></ul></div></li><li><strong><code>Release</code> 和 <code>Acquire</code> 内存排序</strong>：用于同步线程之间的数据，建立 <code>happens-before</code> 关系.<div class="component-content component"><ul><li><code>Release</code> 存储操作保证该操作之前的写入对其他线程可见.</li><li><code>Acquire</code> 加载操作保证该操作之后的操作能看到其他线程的写入.</li><li><code>Release</code> 和 <code>Acquire</code> 通常配对使用，例如，解锁操作使用 <code>Release</code>，加锁操作使用 <code>Acquire</code>.</li><li>当一个 <code>Acquire</code> 加载操作观察到一个 <code>Release</code> 存储操作的结果时，会形成一个 <code>happens-before</code> 关系.</li></ul></div></li><li><strong><code>SeqCst</code> 内存排序</strong>：最强的内存排序，保证所有操作的全局一致性.</li><li><strong>Fences</strong>：内存屏障，用于显式地插入内存排序.<div class="component-content component"><ul><li><code>Release</code> 存储操作可以分解为 <code>Release</code> 内存屏障和 <code>Relaxed</code> 存储操作.</li><li><code>Acquire</code> 加载操作可以分解为 <code>Relaxed</code> 加载操作和 <code>Acquire</code> 内存屏障.</li></ul></div></li></ul></div></li><li>本章还通过实例，讲解了如何使用内存排序来解决并发编程中的常见问题，例如 <strong>懒初始化</strong> 和 <strong>锁的实现</strong>.</li></ul></div><div class="component-content pagebody component"><h2 id=第四章构建自己的自旋锁 class=pagebody-header>第四章：构建自己的自旋锁</h2></div><div class="component-content component"><ul><li>本章从零开始构建了一个 <strong>自旋锁</strong>， 学习如何使用原子操作来实现锁.<div class="component-content component"><ul><li><strong>自旋锁</strong>：一种忙等待锁，当锁被占用时，线程会不断循环检查锁是否可用.</li><li><strong>最小实现</strong>：自旋锁可以使用一个原子布尔变量来实现，用 <code>swap</code> 获取锁，用 <code>store</code> 释放锁.</li></ul></div><div class="component-content pagebody component code"><div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>   <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>SpinLock</span> {
</span></span><span style=display:flex><span>       locked: <span style=color:#a6e22e>AtomicBool</span>,
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>impl</span> SpinLock {
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span>self) {
</span></span><span style=display:flex><span>         <span style=color:#66d9ef>while</span> self.locked.swap(<span style=color:#66d9ef>true</span>, Acquire) {
</span></span><span style=display:flex><span>           std::hint::spin_loop();
</span></span><span style=display:flex><span>         }
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span>self) {
</span></span><span style=display:flex><span>         self.locked.store(<span style=color:#66d9ef>false</span>, Release);
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>   }</span></span></code></pre></div></div></div><div class="component-content component"><ul><li><strong>安全接口</strong>：通过使用 <code>UnsafeCell</code> 和 <code>LockGuard</code> 来提供安全的接口.<div class="component-content component"><ul><li><code>UnsafeCell</code> 用于封装可变数据.</li><li><code>LockGuard</code> 在 <code>Drop</code> 时自动释放锁.</li><li><code>Deref</code> 和 <code>DerefMut</code> Trait 用于实现类似引用的行为.</li></ul></div></li><li>自旋锁适合于 <strong>短时间持有的锁</strong>，避免上下文切换的开销.</li></ul></div></li></ul></div><div class="component-content pagebody component"><h2 id=第五章构建自己的通道 class=pagebody-header>第五章：构建自己的通道</h2></div><div class="component-content component"><ul><li>本章从零开始构建了一个 <strong>单次发送通道</strong>， 学习如何在线程之间传递消息.<div class="component-content component"><ul><li><strong>通道</strong>：用于在线程之间传递消息的机制.</li><li><strong><code>Mutex</code> 和 <code>Condvar</code> 实现</strong>：简单的通道可以使用 <code>Mutex</code> 和 <code>Condvar</code> 来实现，但是效率可能不高.</li><li><strong>单次发送通道</strong>：只能发送一次消息的通道.<div class="component-content component"><ul><li>使用 <code>UnsafeCell</code> 和 <code>AtomicBool</code> 来存储和同步消息.</li><li><code>MaybeUninit&lt;T></code> 用于表示未初始化的数据.</li><li>通过使用 <code>Release</code> 和 <code>Acquire</code> 内存排序来同步发送和接收操作.</li></ul></div></li><li><strong>运行时检查</strong>：通过运行时检查来保证通道的安全性，例如，避免多次发送或多次接收.</li><li><strong>使用单原子变量表示状态</strong>：可以使用单个 <code>AtomicU8</code> 来表示通道的多种状态，节省内存.</li><li><strong>通过类型系统实现安全</strong>：通过类型系统来实现通道的安全性，例如，使用 <code>Sender</code> 和 <code>Receiver</code> 类型，避免多次发送或多次接收.</li><li><strong>通过借用来避免分配</strong>：通过借用机制，避免通道的额外内存分配.</li></ul></div></li><li>本章演示了如何在 Rust 中使用各种技巧来实现并发编程的安全性和效率，同时提供了不同设计决策之间的权衡.</li></ul></div><div class="component-content pagebody component"><h2 id=第六章构建自己的-arc class=pagebody-header>第六章：构建自己的 &ldquo;Arc&rdquo;</h2></div><div class="component-content component"><ul><li>本章从零开始构建了一个类似于 <code>std::sync::Arc</code> 的 <strong>原子引用计数智能指针</strong>，学习如何管理共享所有权.<div class="component-content component"><ul><li><code>Arc</code>：允许多个所有者共享同一块内存，直到所有所有者都释放.</li><li><strong>手动管理所有权</strong>：使用 <code>NonNull</code> 来表示非空指针.</li><li><strong><code>Send</code> 和 <code>Sync</code> 的实现</strong>： <code>Arc&lt;T></code> 只有在 <code>T</code> 同时实现 <code>Send</code> 和 <code>Sync</code> 时，才是 <code>Send</code> 和 <code>Sync</code> 的.</li><li><strong>引用计数</strong>：使用原子变量来维护引用计数.</li><li><strong><code>Weak</code> 指针</strong>：弱引用指针，不增加引用计数，可以避免循环引用.<div class="component-content component"><ul><li>使用 <code>compare_exchange</code> 来升级弱指针到强指针.</li></ul></div></li><li><strong>性能优化</strong>：<div class="component-content component"><ul><li>通过减少原子操作，优化克隆操作的性能.</li><li>通过使用 <code>ManuallyDrop</code> 来减少内存占用.</li><li>通过 “锁定” 弱指针计数器来避免竞争条件.</li></ul></div></li><li><strong>可变性</strong>：<code>get_mut</code> 方法用于获取独占引用，前提是只剩下一个 <code>Arc</code>.</li></ul></div></li></ul></div><div class="component-content pagebody component"><h2 id=第七章理解处理器 class=pagebody-header>第七章：理解处理器</h2></div><div class="component-content component"><ul><li>本章深入探讨了 <strong>处理器</strong> 的工作原理，以及如何影响并发程序的性能.<div class="component-content component"><ul><li><strong>指令集</strong>：本章介绍了 x86-64 和 ARM64 指令集中的一些指令，包括原子操作和内存屏障.<div class="component-content component"><ul><li>x86-64: <code>mov</code>、<code>add</code>、<code>cmpxchg</code>、<code>lock</code> prefix, <code>mfence</code>.</li><li>ARM64: <code>ldxr</code>, <code>stxr</code>, <code>cas</code>.</li></ul></div></li><li><strong>缓存一致性</strong>：本章介绍了缓存一致性的概念，以及 MESI 协议.<div class="component-content component"><ul><li><strong>MESI</strong>：修改 (Modified)、独占 (Exclusive)、共享 (Shared) 和无效 (Invalid) 状态.</li></ul></div></li><li><strong>缓存行</strong>：本章解释了缓存行的概念，以及 <strong>伪共享</strong> 的问题.<div class="component-content component"><ul><li><strong>伪共享</strong>：当多个线程访问位于同一缓存行的数据时，会导致性能下降.</li><li>可以使用 <code>#[repr(align(64))]</code> 来避免伪共享.</li></ul></div></li><li><strong>内存排序</strong>：展示了不同的内存排序在汇编代码上的区别.</li></ul></div></li><li>本章的目的是让读者理解底层硬件如何影响并发程序，从而编写更高效的代码.</li></ul></div><div class="component-content pagebody component"><h2 id=第八章linux-futex class=pagebody-header>第八章：Linux Futex</h2></div><div class="component-content component"><ul><li>本章介绍了 Linux 中的 <strong>futex</strong> 系统调用，这是实现许多并发原语的基础.<div class="component-content component"><ul><li><strong><code>futex</code></strong>：快速用户空间互斥量 (fast userspace mutex)，用于实现用户空间的同步原语.</li><li><strong><code>futex</code> 操作</strong>：
* <code>FUTEX_WAIT</code>：等待原子变量的值变为指定值.
* <code>FUTEX_WAKE</code>：唤醒等待在原子变量上的线程.
* <code>FUTEX_REQUEUE</code>：唤醒一些线程，并将其他线程重新排队到另一个原子变量.
* <code>FUTEX_CMP_REQUEUE</code>：原子比较并重排队列.</li><li><strong>线程停车</strong>：Linux 中的线程停车机制使用一个原子变量来表示线程的状态.</li></ul></div></li><li>本章旨在让读者了解 Linux 中底层的同步机制，以便更好地理解并发原语的实现.</li></ul></div><div class="component-content pagebody component"><h2 id=第九章构建自己的锁 class=pagebody-header>第九章：构建自己的锁</h2></div><div class="component-content component"><ul><li>本章从零开始构建了自己的 <strong>互斥锁</strong>， <strong>条件变量</strong> 和 <strong>读者-写者锁</strong>，学习如何使用 <code>futex</code> 或类似的平台 API 实现锁机制.<div class="component-content component"><ul><li><strong>互斥锁 (<code>Mutex</code>)</strong>:<div class="component-content component"><ul><li>使用 <code>AtomicU32</code> 来表示锁的状态，0 表示解锁，1 表示锁定.</li><li>使用 <code>wait</code> 和 <code>wake_one</code> 来实现阻塞和唤醒.</li><li>使用 <code>compare_exchange</code> 来获取锁.</li><li><strong>优化</strong>：通过在 <code>wait</code> 前进行自旋，减少系统调用的开销.</li></ul></div></li><li><strong>条件变量 (<code>Condvar</code>)</strong>:<div class="component-content component"><ul><li>使用一个额外的原子计数器 <code>num_waiters</code> 来优化唤醒操作，只唤醒需要唤醒的线程.</li></ul></div></li><li><strong>读者-写者锁 (<code>RwLock</code>)</strong>:<div class="component-content component"><ul><li>允许多个读者同时访问，但只允许一个写者独占访问.</li><li>使用 <code>AtomicU32</code> 来表示锁的状态，并通过比较和交换操作来获取锁.</li><li>使用 <code>wait</code> 和 <code>wake_all</code> 来实现阻塞和唤醒.</li><li><strong>优化</strong>：通过使用两个原子变量 <code>state</code> 和 <code>writer_wake_counter</code> 来优化唤醒操作.</li><li>通过使用奇数和偶数来区分读者和写者，优化了读取效率.</li></ul></div></li></ul></div></li><li>本章展示了如何通过使用原子操作和系统调用来构建复杂的同步原语.</li></ul></div><p class="component-content component"><strong>总结</strong></p><div class="component-content component"><ul><li>本书涵盖了 Rust 并发编程的底层知识，从原子操作到高级同步原语，通过实践来深入理解并发编程.</li><li>本书强调了 <strong>内存排序</strong> 和 <strong>缓存一致性</strong> 的重要性.</li><li>本书不仅讲解了理论，还提供了大量的代码示例和实现细节.</li><li>本书强调，每个设计决策都存在权衡，需要根据具体用例进行选择.</li></ul></div></div><div id=comments class=utterances><script src=https://utteranc.es/client.js repo=smallnest/booslip.rpcx.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></div></article></section></main><script>var script=document.createElement("script");script.src="https://booslip.rpcx.io/js/initPost.js",document.head.appendChild(script)</script><div class=footer-main><div class="content-body footer-wraper"><div class=footer-box><div class=foot-nav><div class=foot-nav-items><div class=item><div class=logo></div><div class=email>Email: <a href=mailto:smallnest@gmail.com>smallnest@gmail.com</a></div></div><div class="item community"><div class=item-title>社交媒体</div><a href=https://github.com/smallnest target=_blank>Github</a></div><div class="item resources"><div class=item-title>友链</div><a href=https://colobu.com/ target=_blank>鸟窝</a></div></div></div><div class=bottom><div class="item copyright">鸟窝 &copy; 2025 All Rights Reserved.</div></div></div></div></div></body></html>